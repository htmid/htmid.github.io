<html>
<head>
<meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Continuous 22-Animation Transition Suite</title>
    <style>

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;

            justify-content: center;
            align-items: center;
            background-color: #111;
            overflow: hidden;
        }

        /* --- Viewport Container (Fixed Size) --- */
        #zoom-wrapper {
            /* This defines the visible area (800x800) */
            width: 100%;
            height: 100%;
            overflow: hidden; /* **CRUCIAL: Hides the zoomed content edges** */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            background-color: #111;
    
            justify-content: center;
            align-items: center;
            background-color: #111;
            overflow: hidden;
        }

        /* --- Zoomable Container (The element that moves and scales) --- */
        #iframe-container {
            width: 103.0%;
            height: 103.0%;
            position: relative; 
            
            /* **CRUCIAL: Smooth Transition** */
            /* Apply a transition to the 'transform' property over 20 seconds for slow movement */
            transition: transform 20s ease-in-out; 
            
            /* Initial transformation: Zoomed in (1.1) and moved to an 'end' position */
            transform: scale(1) translate(-1.25%, -1.25%); 
        }

        /* --- Iframe Styles (Same as before) --- */
    
        #animationCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 102.5%;
            height: 102.5%;
            border: none;
            /* Transition for the crossfade */
            transition: opacity 1.0s ease-in-out;
            will-change: opacity;
    
        }



        
        #animationTitle {
width:1;
height:1
display:none;
        }
    </style>
</head>
<script>



rbenr="";


ste="";


var imgll=ste.split("<br>");
var images=new Array();
for(i=0;i<imgll.length;i++){
images[i]="data:image/jpeg;base64,"+imgll[i];
}


var imglll=rbenr.split("<br>");
var imagesr=new Array();
for(i=0;i<imglll.length;i++){
imagesr[i]="data:image/jpeg;base64,"+imglll[i];
}
	


var modulus101 = Math.pow(2, 32); // Still needed for the final division

// Retain only the necessary LCG constants
var a11xx33 = 1664525;
var c11333 = 1013904223;
var sseed1142 = Date.now(); // **Crucial:** Use a dynamic seed like the current time

function wielsieder() {
    // 1. Perform the multiplication and addition. 
    //    Use parentheses to ensure correct order of operations.
    // 2. The result of the LCG formula is a 64-bit float.
    // 3. The `>>> 0` operator performs an unsigned right shift by 0, 
    //    which effectively forces the number to be an **unsigned 32-bit integer (modulo 2^32)**.
    sseed1142 = (a11xx33 * sseed1142 + c11333) >>> 0;
    
    // Divide by the modulus to get a float between 0 and 1
    return (sseed1142 / modulus101);
}

function getRandom() {
    var randomIndex = Math.floor(500 * Math.random());
    return "/images/foto" + randomIndex + ".jpg";
}

</script>
<body>
<textarea style='display:none' id='idee'>
</textarea>
<div id="zoom-wrapper">
    <div id="iframe-container">
    <div id="animationTitle" style='display:none'>Loading...</div>
    <canvas id="animationCanvas" width=640 height=640></canvas>
    </div>
</div>
<script>
    // --- Global Configuration and State (from user's original code) ---
    const WIDTH = 640;
    const HEIGHT = 640;
    const TOTAL_ANIMATIONS = 154; // // Set to the highest index + 1 (12 + 1)
    
    let canvas, ctx;
    let currentImage = new Image();
    let nextImage = new Image();
    let currentURL = "";
    let nextURL = "";

    let ANIMATION_INDEX = 0; // Start with the first uploaded animation logic (index 4)
    
    // --- Controller Functions (from user's original code) ---

    function requestRandom(context = 0) {
        // Log the current animation for context
        const titleElement = document.getElementById('animationTitle');
        const currentAnim = ANIMATION_LOGIC[ANIMATION_INDEX % TOTAL_ANIMATIONS] || {title: "Loading Animation"};
        titleElement.textContent = `Animatie ${ANIMATION_INDEX % TOTAL_ANIMATIONS}: ${currentAnim.title}`;

        const imageSrc = getRandom();

        if (context === 0) { // Initial load (Image A)
            currentURL = imageSrc;
            requestRandom(1); // Load Image B next
        } else if (context === 1) { // Load Image B
            nextURL = imageSrc;
            loadImages(currentURL, nextURL);
        } else if (context >= 2) { // Load Image C (new next image)
            nextURL = imageSrc;
            loadNextImage(nextURL);
        }
    }

    function loadImages(urlA, urlB) {
        let loadedCount = 0;
        const totalToLoad = 2;

        const checkReady = () => {
            loadedCount++;
            if (loadedCount === totalToLoad) {
                if (currentImage.complete && nextImage.complete && currentImage.naturalWidth > 0 && nextImage.naturalWidth > 0) {
                    console.log(`Initial Load Complete. Starting Animation ${ANIMATION_INDEX}.`);
                    const index = ANIMATION_INDEX % TOTAL_ANIMATIONS;
                    if (ANIMATION_LOGIC[index]) {
                       ANIMATION_LOGIC[index].init();
                       ANIMATION_LOGIC[index].animate();
                    } else {
                        console.error(`ANIMATION_LOGIC at index ${index} is missing.`);
                    }
                } else {
                    console.error("Error loading one or both initial images.");
                }
            }
        };

        currentImage.onload = checkReady;
        nextImage.onload = checkReady;

        currentImage.onerror = () => { console.error("Error loading Image A:", urlA); };
        nextImage.onerror = () => { console.error("Error loading Image B:", urlB); };

        currentImage.src = urlA;
        nextImage.src = urlB;
    }

    function loadNextImage(urlC) {
        const newImageC = new Image();	
        newImageC.crossOrigin = "anonymous";

        newImageC.onload = () => {
            // Replace the GLOBAL nextImage object with the new image C.
            nextImage = newImageC;
  //console.error(`ANIMATION_LOGIC at index ${index} is missing.`);
            console.log(ANIMATION_INDEX+" Image C loaded successfully. Ready for next transition.");
		document.title=ANIMATION_INDEX+"";
        };

        newImageC.onerror = () => {	
            console.error("Error loading Image C:", urlC);
            newImageC.src = 'https://via.placeholder.com/640x640/555555/FFFFFF?text=Error';
            nextImage = newImageC; // Still assign the fallback
        };
        
        newImageC.src = urlC; // Start loading Image C
    }

var progress;
    function startNextTransition() {
        // 1. Swap B (nextImage) to A (currentImage)
        currentImage = nextImage;
        
        // 2. Request the new next image (C) right away
        requestRandom(2); 
        
        // 3. Advance the animation index and loop back if needed
        ANIMATION_INDEX++;
        const nextIndex = ANIMATION_INDEX % TOTAL_ANIMATIONS;
        
        // 4. Update the title
        const titleElement = document.getElementById('animationTitle');
        const nextAnim = ANIMATION_LOGIC[nextIndex];
        titleElement.textContent = `Animatie ${nextIndex} of ${TOTAL_ANIMATIONS - 1}: ${nextAnim.title}`;

        // 5. Start the next animation (B -> C) after a brief pause
        setTimeout(() => {
            if (ANIMATION_LOGIC[nextIndex]) {
                ANIMATION_LOGIC[nextIndex].init();
                ANIMATION_LOGIC[nextIndex].animate();
            } else {
                // If an animation index is missing, skip it and call the next transition
                console.error(`Animation logic for index ${nextIndex} not defined. Skipping.`);
                startNextTransition();
            }
        }, 1000); // Shorter 1-second pause for faster continuous loop
    }

    // --- Animation Logic (Consolidated) ---

    let ANIMATION_LOGIC = [];

    // Helper to get raw pixel data from an image object (used in multiple animations)
    function getPixelData(img) {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = WIDTH;
        tempCanvas.height = HEIGHT;
        tempCtx.drawImage(img, 0, 0, WIDTH, HEIGHT);
        return tempCtx.getImageData(0, 0, WIDTH, HEIGHT);
    }
    
    // Helper function to get average color of a block (used in animations 8 and 10)
    function getAvgColor(imageData, startX, startY, w, h) {
        let r = 0, g = 0, b = 0, count = 0;
        const data = imageData.data;
        const width = imageData.width;

        for (let y = startY; y < startY + h; y++) {
            for (let x = startX; x < startX + w; x++) {
                const i = (y * width + x) * 4;
                r += data[i];
                g += data[i + 1];
                b += data[i + 2];
                count++;
            }
        }
        return count > 0 ? { r: r / count, g: g / count, b: b / count } : { r: 0, g: 0, b: 0 };
    }
    




function easeOutQuad(t) {
    // The formula is 1 - (1 - t)^2
    return t * (2 - t);
    // Alternatively: return 1 - (1 - t) * (1 - t);
}




var easeInOutQuint = (t) => t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t;



function easeInQuad(t) {
    // The formula is t^2
    return t * t;
}

function lerp(a, b, t) {
        return a + (b - a) * t;
    }


function easeInOutQuad(t) {
    // Check if we are in the first half (0 <= t < 0.5)
    if (t < 0.5) {
        // Double t and apply easeInQuad (t * t), then halve the result
        return 2 * t * t;
    } else {
        // This is equivalent to applying easeOutQuad to the second half (t > 0.5)
        // Adjust t to be between 0 and 1 for the second half: 2 * t - 1
        // The easeOutQuad formula is t * (2 - t)
        // With the adjusted t: (2 * t - 1) * (2 - (2 * t - 1))
        // Simplified: 1 - Math.pow(-2 * t + 2, 2) / 2
        return 1 - Math.pow(-2 * t + 2, 2) / 2;
        
        // Simpler implementation using a mathematical equivalent:
        // t = 2 * t - 1;
        // return 0.5 * t * t + 0.5;
    }
}





// Perlin Noise Helper (Placeholder for complexity)
    const perlinNoise = (x, y, t) => {
        // A simple 2D periodic function to simulate organic flow
        return Math.sin(x * 0.05 + t) * Math.cos(y * 0.03 + t) * 0.5 + 0.5;
    };















// Quintic Easing (Smooth start and end)
function easeInOutQuint(t) {
    t *= 2;
    if (t < 1) return 0.5 * t * t * t * t * t;
    t -= 2;
    return 0.5 * (t * t * t * t * t + 2);
}

// Quartic Easing (Stronger acceleration/deceleration)
function easeInOutQuartic(t) { 
    return t < .5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t;
}

// --- Chaos Systems / Randomness ---

// Wielsieder: High-quality, fast pseudo-random number generator (0 to 1)
function wielsieder() { 
    // Simplified version for demo, a real PRNG should be more complex
    return Math.random(); 
}








// Utility to safely retrieve ImageData from an Image object
function getPixelData(image) {
    // This function must be robustly implemented in the calling environment.
    // Here is a minimal implementation assumption:
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = WIDTH;
    tempCanvas.height = HEIGHT;
    const tempCtx = tempCanvas.getContext('2d');
    tempCtx.drawImage(image, 0, 0, WIDTH, HEIGHT);
    return tempCtx.getImageData(0, 0, WIDTH, HEIGHT);
}

// Utility to safely get the color at a coordinate
function getPixelColor(dataArray, x, y) {
    const px = Math.max(0, Math.min(WIDTH - 1, Math.round(x)));
    const py = Math.max(0, Math.min(HEIGHT - 1, Math.round(y)));

    const i = (py * WIDTH + px) * 4;

    if (i < dataArray.length) {
        return { r: dataArray[i], g: dataArray[i + 1], b: dataArray[i + 2] };
    }
    return { r: 0, g: 0, b: 0 }; 
}

// Lorenz Map (for ANIMATION_LOGIC[68])
function lorenzMap(x, y, z, sigma, rho, beta, dt) {
    const dx = sigma * (y - x) * dt;
    const dy = (x * (rho - z) - y) * dt;
    const dz = (x * y - beta * z) * dt;
    return { x: x + dx, y: y + dy, z: z + dz };
}




    // --- ANIMATION 0: Quantum Flux Transition (from animatie-serie4.html) ---
    ANIMATION_LOGIC[0] = (function() {
        // --- Animation-specific state variables ---
        const uniqueState = {
            pixbixels: [],
            totalFramesbb: 120, // 2 seconds at 60fps
            currentFramebb: 0,
        };
        
        // --- Utility ---
    

        /**
         * Prepares pixel data for the animation. (Original setupInitialCanvas)
         */
        function init() {
            // Clear previous pixel data
            uniqueState.pixbixels = [];
            uniqueState.currentFramebb = 0;

            // Get image data using global helper
            const imageDataA = getPixelData(currentImage);
            const data1 = imageDataA.data;
            const imageDataB = getPixelData(nextImage);
            const data2 = imageDataB.data;

            // Populate pixbixels with structured data for each pixel
            for (let y = 0; y < HEIGHT; y++) {
                for (let x = 0; x < WIDTH; x++) {
                    let i = (y * WIDTH + x) * 4;
                    uniqueState.pixbixels.push({
                        x: x,
                        y: y,
                        r1: data1[i], g1: data1[i+1], b1: data1[i+2], a1: data1[i+3],
                        r2: data2[i], g2: data2[i+1], b2: data2[i+2], a2: data2[i+3],
                        // Randomize delay and duration for individual pixel transitions
                        delay: wielsieder() * uniqueState.totalFramesbb * 0.3, 
                        duration: uniqueState.totalFramesbb * (0.4 + wielsieder() * 0.6), 
                        // Initial "quantum fluctuation" offset
                        initialOffsetX: (wielsieder() - 0.5) * 5,
                        initialOffsetY: (wielsieder() - 0.5) * 5,
                        // Unique "quantum phase" for each pixel
                        quantumPhase: wielsieder() * Math.PI * 2
                    });
                }
            }
        }

        /**
         * The main animation loop. (Original ANIMATE)
         */
        function animate() {
            const currentFramebb = uniqueState.currentFramebb;
            const totalFramesbb = uniqueState.totalFramesbb;

            // Create an ImageData object for the current frame
            let imageData = ctx.createImageData(WIDTH, HEIGHT);
            let pixelsData = imageData.data; 

            uniqueState.pixbixels.forEach(pixel => {
                let progress = (currentFramebb - pixel.delay) / pixel.duration;
                progress = Math.max(0, Math.min(1, progress)); // Clamp progress between 0 and 1

                let easedProgress = easeInOutQuint(progress);

                // --- Quantum Effects & Boundary Breaking ---
                let currentR, currentG, currentB, currentA;
                let currentX = pixel.x;
                let currentY = pixel.y;

                // 1. Probabilistic Teleportation/Flicker (Quantum Uncertainty)
                if (wielsieder() < 0.01 && progress > 0 && progress < 1) { 
                    if (wielsieder() < 0.5) { 
                        currentR = pixel.r2; currentG = pixel.g2; currentB = pixel.b2; currentA = pixel.a2;
                    } else { 
                        currentR = wielsieder() * 255; currentG = wielsieder() * 255; currentB = wielsieder() * 255; currentA = 255;
                    }
                } else {
                    // 2. Chaotic Trajectories & "Unreal Simulation"
                    let oscillationFactor = 1 - easedProgress; 
                    currentX += pixel.initialOffsetX * oscillationFactor * Math.sin(currentFramebb * 0.05 + pixel.quantumPhase);
                    currentY += pixel.initialOffsetY * oscillationFactor * Math.cos(currentFramebb * 0.05 + pixel.quantumPhase);

                    // 3. "Boundary Breaking" Insight 
                    const boundaryFactor = (674520 % 1000) / 100; 
                    let displacementAmplitude = Math.sin(currentFramebb / (totalFramesbb / 5) + pixel.x / boundaryFactor) * boundaryFactor * (1 - Math.abs(2 * progress - 1));
                    
                    currentX += displacementAmplitude * Math.sin(currentFramebb * 0.1);
                    currentY += displacementAmplitude * Math.cos(currentFramebb * 0.1);

                    // Normal color interpolation
                    currentR = pixel.r1 + (pixel.r2 - pixel.r1) * easedProgress;
                    currentG = pixel.g1 + (pixel.g2 - pixel.g1) * easedProgress;
                    currentB = pixel.b1 + (pixel.b2 - pixel.b1) * easedProgress;
                    currentA = pixel.a1 + (pixel.a2 - pixel.a1) * easedProgress;
                }

                // Ensure coordinates are within canvas bounds
                currentX = Math.round(Math.max(0, Math.min(WIDTH - 1, currentX)));
                currentY = Math.round(Math.max(0, Math.min(HEIGHT - 1, currentY)));

                // Calculate index for ImageData
                let i = (currentY * WIDTH + currentX) * 4;

                // Set pixel data directly
                pixelsData[i] = Math.round(currentR);
                pixelsData[i+1] = Math.round(currentG);
                pixelsData[i+2] = Math.round(currentB);
                pixelsData[i+3] = Math.round(currentA);
            });

            // Put the manipulated pixel data onto the canvas
            ctx.putImageData(imageData, 0, 0);

            if (currentFramebb < totalFramesbb) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                // Animation (A -> B) is complete. Prepare the next round (B -> C).

                // Draw the final image (B) to the canvas to completely cover the transition pixels.
                ctx.clearRect(0, 0, WIDTH, HEIGHT);
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);

                // Use the continuous framework's transition function
                startNextTransition();
            }
        }

        return { title: "Quantum Flux Transition (ANIMATION_LOGIC[0])", init: init, animate: animate };
    })();

   
    
    // --- ANIMATION 5: Mirrored Spin Transition (from animatie-serie6.html) ---
    // Note: Re-using index 5 for the logic from animatie-serie6.html
    ANIMATION_LOGIC[1] = (function() {
        const uniqueState = {
            pixbixels: [], 
            totalFramesbb: 150,
            currentFramebb: 0,
            midX: WIDTH / 2,
            midY: HEIGHT / 2
        };

        const easeInOutQuad = (t) => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;

        function init() {
            uniqueState.currentFramebb = 0;
            uniqueState.pixbixels = [];
            const imageDataA = getPixelData(currentImage);
            const dataA = imageDataA.data;
            const imageDataB = getPixelData(nextImage);
            const dataB = imageDataB.data;

            for (let y = 0; y < HEIGHT; y++) {
                for (let x = 0; x < WIDTH; x++) {
                    const i = (y * WIDTH + x) * 4;

                    // Target color (B) from mirrored location
                    const iB_mirror = ((HEIGHT - 1 - y) * WIDTH + (WIDTH - 1 - x)) * 4;
                    
                    const rA = dataA[i];
                    const gA = dataA[i + 1];
                    const bA = dataA[i + 2];
                    
                    // Check bounds for mirror pixel
                    const rB_mirror = dataB[iB_mirror] || 0;
                    
                    const waveAmplitude = Math.abs(rA - rB_mirror);
                    const spinRadius = ((rA + gA + bA) / 3) + waveAmplitude; 
                    
                    uniqueState.pixbixels.push({
                        startX: x,
                        startY: y,
                        startR: rA,
                        startG: gA,
                        startB: bA,
                        endR: dataB[iB_mirror] || 0,
                        endG: dataB[iB_mirror + 1] || 0,
                        endB: dataB[iB_mirror + 2] || 0,

                        spinRadius: spinRadius,
                        angleOffset: wielsieder() * Math.PI * 2, 
                        duration: 100 + Math.floor(wielsieder() * 50),
                        delay: Math.floor(wielsieder() * 30),
                    });
                }
            }
        }

        function animate() {
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT); // Draw B first

            const imageData = ctx.createImageData(WIDTH, HEIGHT);
            const data = imageData.data;

            uniqueState.pixbixels.forEach(p => {
                const time = currentFrame - p.delay;
                
                if (time >= 0 && time <= p.duration) {
                    progress = easeInOutQuad(time / p.duration);
                    
                    // Linear movement from A to mirrored B location
                    const mirrorX = WIDTH - 1 - p.startX;
                    const mirrorY = HEIGHT - 1 - p.startY;
                    
                    const currentX = p.startX + (mirrorX - p.startX) * progress;
                    const currentY = p.startY + (mirrorY - p.startY) * progress;
                    
                    // Add the spin/wave effect
                    const angle = p.angleOffset + progress * Math.PI * 4; 
                    const spinOffset = p.spinRadius * Math.sin(angle) * (1 - Math.abs(progress - 0.5) * 2);
                    
                    const finalX = Math.floor(currentX + Math.cos(angle) * spinOffset);
                    const finalY = Math.floor(currentY + Math.sin(angle) * spinOffset);
                    
                    // Interpolate color
                    const r = p.startR + (p.endR - p.startR) * progress;
                    const g = p.startG + (p.endG - p.startG) * progress;
                    const b = p.startB + (p.endB - p.startB) * progress;

                    if (finalX >= 0 && finalX < WIDTH && finalY >= 0 && finalY < HEIGHT) {
                         const i = (finalY * WIDTH + finalX) * 4;

                         data[i] = r;
                         data[i + 1] = g;
                         data[i + 2] = b;
                         data[i + 3] = 255;
                    }
                }
            });

            ctx.putImageData(imageData, 0, 0);

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.clearRect(0, 0, WIDTH, HEIGHT);
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Mirrored Spin Transition (ANIMATION_LOGIC[5])", init: init, animate: animate };
    })();

    // --- ANIMATION 8: Quantum Segmentation Image Transition (from animatie-serie8.html) ---
    ANIMATION_LOGIC[2] = (function() {
        const BLOCK_SIZE = 10;
        const uniqueState = {
            segments: [], 
            totalFramesbb: 120,
            currentFramebb: 0,
            numCols: Math.floor(WIDTH / BLOCK_SIZE),
            numRows: Math.floor(HEIGHT / BLOCK_SIZE),
        };

        const easeInOutQuint = (t) => t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t;

        function init() {
            uniqueState.currentFramebb = 0;
            uniqueState.segments = [];
            
            const imageDataA = getPixelData(currentImage);
            const imageDataB = getPixelData(nextImage);

            for (let r = 0; r < uniqueState.numRows; r++) {
                for (let c = 0; c < uniqueState.numCols; c++) {
                    const x = c * BLOCK_SIZE;
                    const y = r * BLOCK_SIZE;

                    const avgColorA = getAvgColor(imageDataA, x, y, BLOCK_SIZE, BLOCK_SIZE);
                    const avgColorB = getAvgColor(imageDataB, x, y, BLOCK_SIZE, BLOCK_SIZE);
                    
                    const midX = x + BLOCK_SIZE / 2;
                    const midY = y + BLOCK_SIZE / 2;

                    uniqueState.segments.push({
                        x: x,
                        y: y,
                        midX: midX,
                        midY: midY,
                        startR: avgColorA.r,
                        startG: avgColorA.g,
                        startB: avgColorA.b,
                        endR: avgColorB.r,
                        endG: avgColorB.g,
                        endB: avgColorB.b,
                        delay: Math.floor(wielsieder() * 60),
                        duration: 80 + Math.floor(wielsieder() * 40),
                        startAngle: wielsieder() * Math.PI * 2,
                        endAngle: (wielsieder() * 2 - 1) * Math.PI * 4,
                        maxDistance: (0.5 + wielsieder() * 0.5) * WIDTH / 2
                    });
                }
            }
        }

        function animate() {
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            
            uniqueState.segments.forEach(s => {
                const time = currentFrame - s.delay;
                
                if (time >= 0 && time <= s.duration) {
                    progress = easeInOutQuint(time / s.duration);
                    
                    // PhaseProgress goes 1.0 -> 0.0 -> 1.0 (max spread at 50%)
                    const phaseProgress = Math.abs(progress - 0.5) * 2; 
                    const distance = s.maxDistance * phaseProgress;
                    
                    const angle = s.startAngle + (s.endAngle - s.startAngle) * progress;
                    
                    const offsetX = Math.cos(angle) * distance;
                    const offsetY = Math.sin(angle) * distance;

                    const finalX = s.x + offsetX;
                    const finalY = s.y + offsetY;
                    
                    // Interpolate color
                    const r = s.startR + (s.endR - s.startR) * progress;
                    const g = s.startG + (s.endG - s.startG) * progress;
                    const b = s.startB + (s.endB - s.startB) * progress;
                    
                    // Draw Segment
                    ctx.save();
                    ctx.beginPath();
                    
                    ctx.translate(s.midX, s.midY);
                    ctx.rotate(angle * progress); 
                    ctx.translate(-s.midX, -s.midY);
                    
                    ctx.fillStyle = `rgb(${Math.floor(r)},${Math.floor(g)},${Math.floor(b)})`;
                    ctx.fillRect(finalX, finalY, BLOCK_SIZE, BLOCK_SIZE);
                    
                    ctx.restore();
                }
            });
            
            // Draw Image B to fill in the gaps as the animation ends
            if (currentFrame >= totalFrames) {
                ctx.clearRect(0, 0, WIDTH, HEIGHT);
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
            }

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                startNextTransition();
            }
        }

        return { title: "Quantum Segmentation Transition (ANIMATION_LOGIC[8])", init: init, animate: animate };
    })();

   

ANIMATION_LOGIC[3] = (function() {
    // --- Animation-specific state variables ---
    const uniqueState = {
        pixbixels: [],
        totalFramesbb: 120, // Frames from original script
        currentFramebb: 0,
    };

    // --- Utility Functions (Adapted from original script for framework use) ---
    // Note: Assuming global existence of WIDTH, HEIGHT, ctx, currentImage, nextImage, and startNextTransition()
    
    // Placeholder for a framework randomizer, defaulting to standard JS random
    // We use Math.random() directly in the logic below for fidelity to the original script's behavior.
    var wielsieder = Math.random;

    // Easing function for smoother acceleration/deceleration (from original script)
    var easeInOutQuint = (t) => t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t;

    // Interpolates between two color components (from original script)
    var interpolateColor = (color1, color2, progress) => {
        var r = Math.round(color1[0] + (color2[0] - color1[0]) * progress);
        var g = Math.round(color1[1] + (color2[1] - color1[1]) * progress);
        var b = Math.round(color1[2] + (color2[2] - color1[2]) * progress);
        var a = color1[3] + (color2[3] - color1[3]) * progress;
        return [r, g, b, a];
    };

    /**
     * Helper to extract ImageData from an image object, assuming the framework exposes this.
     */
    function getPixelData(img) {
        let tempCanvas = document.createElement('canvas');
        let tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = WIDTH; // Assuming global WIDTH/HEIGHT
        tempCanvas.height = HEIGHT; // Assuming global WIDTH/HEIGHT
        tempCtx.drawImage(img, 0, 0, WIDTH, HEIGHT);
        return tempCtx.getImageData(0, 0, WIDTH, HEIGHT);
    }

    /**
     * Prepares pixel data for the animation. (Original setupInitialCanvas)
     */
    function init() {
        // Clear previous pixel data
        uniqueState.pixbixels = [];
        uniqueState.currentFramebb = 0;

        // The specific seed from the original script
        const quantumSeed = 907217;
        const pixelCount = WIDTH * HEIGHT;

        // Get image data using framework helper
        const imageDataA = getPixelData(currentImage); // Assuming global currentImage
        const data1 = imageDataA.data;
        const imageDataB = getPixelData(nextImage); // Assuming global nextImage
        const data2 = imageDataB.data;

        // Populate pixbixels with structured data for each pixel (based on original script logic)
        for (let i = 0; i < pixelCount; i++) {
            let idx = i * 4;
            let x = i % WIDTH;
            let y = Math.floor(i / WIDTH);

            // Calculation for collapse frame based on original script's logic (using seed)
            let randomFactor = (Math.sin(x * y * quantumSeed / pixelCount) * 0.5 + 0.5);
            let collapseFrame = Math.floor(uniqueState.totalFramesbb * (0.3 + 0.6 * randomFactor));

            uniqueState.pixbixels.push({
                x: x,
                y: y,
                r1: data1[idx], g1: data1[idx + 1], b1: data1[idx + 2], a1: data1[idx + 3],
                r2: data2[idx], g2: data2[idx + 1], b2: data2[idx + 2], a2: data2[idx + 3],

                // Custom parameters from original script
                collapseFrame: collapseFrame,
                jitterStrength: 1 + Math.random() * 2,
                chromaShiftStrength: 0.5 + Math.random() * 1.5,
                initialDelay: Math.random() * 0.4
            });
        }
    }

    /**
     * The main animation loop. (Original ANIMATE)
     */
    function animate() {
        const currentFramebb = uniqueState.currentFramebb;
        const totalFramesbb = uniqueState.totalFramesbb;

        // Create an ImageData object for the current frame
        let imageData = ctx.createImageData(WIDTH, HEIGHT); // Assuming global ctx, WIDTH, HEIGHT
        let pixelData = imageData.data;

        uniqueState.pixbixels.forEach(p => {
            let originalPixelIdx = (p.y * WIDTH + p.x) * 4;
            let currentColor = [0, 0, 0, 255];

            // Adjust individual pixel progress based on its initialDelay
            let progress = Math.max(0, (currentFramebb / totalFramesbb) - p.initialDelay);
            let pixelEasedProgress = easeInOutQuint(progress);

            if (currentFramebb < p.collapseFrame) {
                // --- QUANTUM JITTER / SUPERPOSITION PHASE ---
                // Introduce positional jitter, fading out as collapse approaches
                let jitterMagnitude = p.jitterStrength * (1 - pixelEasedProgress) * 5;
                let jitterX = Math.sin(currentFramebb * 0.5 + p.x * 0.1) * jitterMagnitude;
                let jitterY = Math.cos(currentFramebb * 0.5 + p.y * 0.1) * jitterMagnitude;

                // Calculate the (potentially jittered) render position
                let renderX = Math.round(p.x + jitterX);
                let renderY = Math.round(p.y + jitterY);

                // Clamp render position to canvas bounds
                renderX = Math.max(0, Math.min(WIDTH - 1, renderX));
                renderY = Math.max(0, Math.min(HEIGHT - 1, renderY));

                let renderPixelIdx = (renderY * WIDTH + renderX) * 4;

                // Quantum color state: blend based on a probabilistic factor and eased progress
                let blendFactor = (Math.random() * 0.3 + pixelEasedProgress * 0.7);
                let startColor = [p.r1, p.g1, p.b1, p.a1];
                let targetColor = [p.r2, p.g2, p.b2, p.a2];
                currentColor = interpolateColor(startColor, targetColor, blendFactor);

                // "Breaking boundaries" with temporary intense color shifts
                if (Math.random() < (1 - pixelEasedProgress) * 0.4) {
                    let shift = (Math.random() - 0.5) * 80 * p.chromaShiftStrength * (1 - pixelEasedProgress);
                    currentColor[0] = Math.min(255, Math.max(0, currentColor[0] + shift));
                    currentColor[1] = Math.min(255, Math.max(0, currentColor[1] - shift / 2));
                    currentColor[2] = Math.min(255, Math.max(0, currentColor[2] + shift / 2));
                }

                // Apply slight transparency to jittering pixels
                currentColor[3] = Math.max(0, p.a1 * (0.4 + 0.6 * (1 - pixelEasedProgress)));

                // Set pixel data at the (possibly jittered) position
                pixelData[renderPixelIdx] = Math.round(currentColor[0]);
                pixelData[renderPixelIdx + 1] = Math.round(currentColor[1]);
                pixelData[renderPixelIdx + 2] = Math.round(currentColor[2]);
                pixelData[renderPixelIdx + 3] = Math.round(currentColor[3]);

            } else {
                // --- COLLAPSE PHASE ---
                let framesAfterCollapse = currentFramebb - p.collapseFrame;
                let targetColor = [p.r2, p.g2, p.b2, p.a2];

                // Apply a temporary "residual energy" glow/flicker after collapse.
                if (framesAfterCollapse < 15) {
                    let glowIntensity = 1 - (framesAfterCollapse / 15);
                    currentColor = interpolateColor(targetColor, [255, 255, 255, 255], glowIntensity * 0.3);
                    currentColor[3] = p.a2; // Maintain original alpha
                } else {
                    currentColor = targetColor; // Fully resolved to target color
                }

                // Set pixel data at its original, stable position
                pixelData[originalPixelIdx] = Math.round(currentColor[0]);
                pixelData[originalPixelIdx + 1] = Math.round(currentColor[1]);
                pixelData[originalPixelIdx + 2] = Math.round(currentColor[2]);
                pixelData[originalPixelIdx + 3] = Math.round(currentColor[3]);
            }
        });

        // Draw all accumulated pixel data to the canvas in one go
        ctx.putImageData(imageData, 0, 0);

        if (currentFramebb < totalFramesbb) {
            uniqueState.currentFramebb++;
            requestAnimationFrame(animate);
        } else {
            // Animation (A -> B) is complete. Prepare the next round (B -> C).

            // Draw the final image (B) to the canvas to completely cover the transition pixels.
            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);

            // Use the framework's transition function
            startNextTransition(); // Assuming global startNextTransition() handles the swap and image load
        }
    }

    return { title: "Quantum Jitter & Collapse Transition (ANIMATION_LOGIC[0])", init: init, animate: animate };
})();

    













ANIMATION_LOGIC[4] = (function() {
    // --- Animation-specific state variables ---
    const uniqueState = {
        pixbixels: [], // Stores segment data
        totalFramesbb: 120, // Duration of the animation
        currentFramebb: 0,
    };

    // --- Utility (from original source code) ---
    // Easing function for smoother animation acceleration/deceleration
    var easeInOutQuint = (t) => t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t;

    /**
     * Helper to extract ImageData from an image object using the global canvas dimensions.
     */
    function getPixelData(img) {
        let tempCanvas = document.createElement('canvas');
        let tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = WIDTH; // Assuming global WIDTH/HEIGHT
        tempCanvas.height = HEIGHT;
        tempCtx.drawImage(img, 0, 0, WIDTH, HEIGHT);
        return tempCtx.getImageData(0, 0, WIDTH, HEIGHT);
    }

    /**
     * Prepares segment data for the animation. (Original setupInitialCanvas)
     * Divides the images into segments and calculates "quantum" parameters for each.
     */
    function init() {
        if (!currentImage || !nextImage) return; // Check if images are available

        uniqueState.pixbixels = [];
        uniqueState.currentFramebb = 0;

        // Use temporary canvases to extract pixel data without interrupting the main canvas draw
        const imageDataA = getPixelData(currentImage);
        const imageDataB = getPixelData(nextImage);

        // --- Quantum Segmentation Parameters from source ---
        const segmentSize = 25;
        const maxInitialOffset = 70;
        const maxDelayFrames = uniqueState.totalFramesbb / 3;
        const flickerProbability = 0.15; // Base probability for segment flicker
        // ---

        // Iterate through the canvas in a grid pattern to create segments
        for (let y = 0; y < HEIGHT; y += segmentSize) { // Assuming global HEIGHT
            for (let x = 0; x < WIDTH; x += segmentSize) { // Assuming global WIDTH
                const width = Math.min(segmentSize, WIDTH - x);
                const height = Math.min(segmentSize, HEIGHT - y);

                if (width <= 0 || height <= 0) continue;

                // Create temporary canvases to get ImageData for the segment
                let tempCanvas1 = document.createElement('canvas');
                let tempCtx1 = tempCanvas1.getContext('2d');
                tempCanvas1.width = WIDTH; tempCanvas1.height = HEIGHT;
                tempCtx1.putImageData(imageDataA, 0, 0);
                const startImageData = tempCtx1.getImageData(x, y, width, height);

                let tempCanvas2 = document.createElement('canvas');
                let tempCtx2 = tempCanvas2.getContext('2d');
                tempCanvas2.width = WIDTH; tempCanvas2.height = HEIGHT;
                tempCtx2.putImageData(imageDataB, 0, 0);
                const endImageData = tempCtx2.getImageData(x, y, width, height);
                
                uniqueState.pixbixels.push({
                    x: x,
                    y: y,
                    width: width,
                    height: height,
                    startImageData: startImageData,
                    endImageData: endImageData,
                    initialOffsetX: (Math.random() - 0.5) * 2 * maxInitialOffset,
                    initialOffsetY: (Math.random() - 0.5) * 2 * maxInitialOffset,
                    transitionDelayFrames: Math.floor(Math.random() * maxDelayFrames),
                    flickerProbability: flickerProbability
                });
            }
        }
    }

    /**
     * The main animation loop. (Original ANIMATE)
     * Draws each segment, applying quantum displacement and probabilistic flickering.
     */
    function animate() {
        const currentFramebb = uniqueState.currentFramebb;
        const totalFramesbb = uniqueState.totalFramesbb;

        ctx.clearRect(0, 0, WIDTH, HEIGHT); // Clear the main canvas (assuming global ctx, WIDTH, HEIGHT)

        uniqueState.pixbixels.forEach(segment => {
            // Calculate segment progress (0 to 1), factoring in its individual delay
            let segmentProgress = Math.max(0, (currentFramebb - segment.transitionDelayFrames) / (totalFramesbb - segment.transitionDelayFrames));
            segmentProgress = easeInOutQuint(Math.min(1, Math.max(0, segmentProgress)));

            let drawX = segment.x;
            let drawY = segment.y;

            // Apply "Quantum Jiggle" / Displacement, which decays as progress increases
            const currentInitialOffsetX = segment.initialOffsetX * (1 - segmentProgress);
            const currentInitialOffsetY = segment.initialOffsetY * (1 - segmentProgress);
            drawX += currentInitialOffsetX;
            drawY += currentInitialOffsetY;

            let imageDataToDraw;

            // Calculate "uncertainty factor": highest in the middle of the transition
            const uncertaintyFactor = Math.abs(0.5 - segmentProgress) * 2;
            const effectiveFlickerProbability = segment.flickerProbability * uncertaintyFactor;

            if (Math.random() < effectiveFlickerProbability) {
                // Superposition/Flicker State: Randomly show one of the two image segments
                imageDataToDraw = Math.random() < 0.5 ? segment.startImageData : segment.endImageData;
            } else {
                // Collapse State: Smoothly blend the pixel data
                imageDataToDraw = ctx.createImageData(segment.width, segment.height);
                for (let i = 0; i < segment.startImageData.data.length; i += 4) {
                    // Interpolate R, G, B channels
                    imageDataToDraw.data[i] = Math.round(segment.startImageData.data[i] + (segment.endImageData.data[i] - segment.startImageData.data[i]) * segmentProgress);
                    imageDataToDraw.data[i + 1] = Math.round(segment.startImageData.data[i + 1] + (segment.endImageData.data[i + 1] - segment.startImageData.data[i + 1]) * segmentProgress);
                    imageDataToDraw.data[i + 2] = Math.round(segment.startImageData.data[i + 2] + (segment.endImageData.data[i + 2] - segment.startImageData.data[i + 2]) * segmentProgress);
                    // Alpha channel (always 255 for solid segments)
                    imageDataToDraw.data[i + 3] = 255;
                }
            }

            // Draw the segment at its current displaced position
            ctx.putImageData(imageDataToDraw, drawX, drawY);
        });

        if (currentFramebb < totalFramesbb) {
            uniqueState.currentFramebb++;
            requestAnimationFrame(animate);
        } else {
            // Animation is complete.
            // Draw the final image to ensure a clean result
            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);

            // Use the continuous framework's transition function to swap images and load the next one
            startNextTransition(); // Assuming global startNextTransition()
        }
    }

    // Return the required functions for the animation framework
    return { title: "Quantum Segmentation Transition (ANIMATION_LOGIC[0])", init: init, animate: animate };
})();



ANIMATION_LOGIC[5] = (function() {
    // --- Animation-specific state variables ---
    const uniqueState = {
        blocks: [], // Array to store block data and their animation properties
        totalFramesbb: 90, // Duration of the animation
        currentFramebb: 0,
    };

    // --- Utility Functions (Adapted from original source code) ---
    // Easing function for smoother animation acceleration/deceleration
    var easeInOutQuint = (t) => t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t;

    /**
     * Sets up the initial state for the block animation. (Original setupInitialCanvas)
     * This prepares blocks with start/end data for the "unreal dynamics" transition.
     */
    function init() {
        if (!currentImage || !nextImage) return;

        uniqueState.blocks = []; // Clear previous blocks data
        uniqueState.currentFramebb = 0;

        // --- Core Parameters from Source ---
        const blockSize = 20; // Size of each square block
        const maxOffsetFactor = 1.5; // Factor for off-screen start
        const maxDelayFactor = 0.4; // Stagger blocks over first 40% of animation
        // ---

        // Assuming global WIDTH and HEIGHT are set by the framework
        const numCols = Math.ceil(WIDTH / blockSize);
        const numRows = Math.ceil(HEIGHT / blockSize);
        const maxOffset = Math.max(WIDTH, HEIGHT) * maxOffsetFactor;

        // Draw the current image fully at the start to prevent a blank frame
        ctx.drawImage(currentImage, 0, 0, WIDTH, HEIGHT); // Assuming global ctx

        for (let y = 0; y < numRows; y++) {
            for (let x = 0; x < numCols; x++) {
                let blockX = x * blockSize;
                let blockY = y * blockSize;
                let width = Math.min(blockSize, WIDTH - blockX);
                let height = Math.min(blockSize, HEIGHT - blockY);

                if (width <= 0 || height <= 0) continue;

                let initialXOffset = 0;
                let initialYOffset = 0;
                let initialRotation = (Math.random() - 0.5) * Math.PI * 2;

                // Randomize entry direction ("kung fu effect thai in doen")
                let direction = Math.floor(Math.random() * 4);
                switch(direction) {
                    case 0: initialXOffset = -maxOffset; break; // Come from far left
                    case 1: initialXOffset = maxOffset; break;  // Come from far right
                    case 2: initialYOffset = -maxOffset; break; // Come from far top
                    case 3: initialYOffset = maxOffset; break;  // Come from far bottom
                }

                // Staggered entry with randomized delay ("Su Ta chi tsi tsu Tha")
                let delayFrames = Math.random() * (uniqueState.totalFramesbb * maxDelayFactor);

                uniqueState.blocks.push({
                    // Source rectangle from `nextImage`
                    sx: blockX, sy: blockY, sWidth: width, sHeight: height,

                    // Destination rectangle on canvas (final position)
                    dWidth: width, dHeight: height,

                    // Animation start properties
                    startDX: blockX + initialXOffset + (Math.random() - 0.5) * blockSize * 2, // Add slight random jitter
                    startDY: blockY + initialYOffset + (Math.random() - 0.5) * blockSize * 2,
                    startRotation: initialRotation,
                    startAlpha: 0, // Blocks of new image start invisible

                    // Animation end properties
                    endDX: blockX,
                    endDY: blockY,
                    endRotation: 0,
                    endAlpha: 1,

                    delay: delayFrames,
                    animationDuration: uniqueState.totalFramesbb - delayFrames
                });
            }
        }
    }

    /**
     * The main animation loop. (Original ANIMATE)
     * Handles the fading/distorting of the current image and the entry of the new image's blocks.
     */
    function animate() {
        const currentFramebb = uniqueState.currentFramebb;
        const totalFramesbb = uniqueState.totalFramesbb;

        // Clear the entire canvas
        ctx.clearRect(0, 0, WIDTH, HEIGHT); // Assuming global ctx, WIDTH, HEIGHT

        // --- Phase 1: Current image fade-out ("I smoke Till I Slip") ---
        let fadeOutProgress = easeInOutQuint(currentFramebb / (totalFramesbb * 0.6));
        
        if (fadeOutProgress < 1) {
            ctx.save();
            // Alpha decreases
            ctx.globalAlpha = Math.max(0, 1 - fadeOutProgress); 
            // Apply blur and color shift (filter only works on subsequent draws in some browsers, but it's the intended effect)
            ctx.filter = `blur(${fadeOutProgress * 5}px) hue-rotate(${fadeOutProgress * 30}deg)`; 
            ctx.drawImage(currentImage, 0, 0, WIDTH, HEIGHT);
            ctx.restore();
        }

        // --- Phase 2: Next image blocks entry ("Rahman Kunfu effect thai in doen") ---
        uniqueState.blocks.forEach(block => {
            let blockCurrentFrame = currentFramebb - block.delay;
            if (blockCurrentFrame < 0) return;

            // Calculate progress for this individual block
            let progress = Math.min(1, blockCurrentFrame / block.animationDuration);
            let easedProgress = easeInOutQuint(progress);

            // Interpolate properties
            let dx = block.startDX + (block.endDX - block.startDX) * easedProgress;
            let dy = block.startDY + (block.endDY - block.startDY) * easedProgress;
            let rotation = block.startRotation + (block.endRotation - block.startRotation) * easedProgress;
            let alpha = block.startAlpha + (block.endAlpha - block.startAlpha) * easedProgress;

            ctx.save();
            ctx.globalAlpha = Math.max(0, Math.min(1, alpha));

            // Apply transformations (move to center, rotate, move back)
            ctx.translate(dx + block.dWidth / 2, dy + block.dHeight / 2);
            ctx.rotate(rotation);
            ctx.translate(-(dx + block.dWidth / 2), -(dy + block.dHeight / 2));

            // Draw the segment of the next image
            ctx.drawImage(nextImage,
                          block.sx, block.sy, block.sWidth, block.sHeight, // Source
                          dx, dy, block.dWidth, block.dHeight);            // Destination
            ctx.restore();
        });

        if (currentFramebb < totalFramesbb) {
            uniqueState.currentFramebb++;
            requestAnimationFrame(animate);
        } else {
            // Animation (A -> B) is complete.

            // 1. Ensure the final image (B) is drawn perfectly to cover all block effects.
            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);

            // 2. Use the continuous framework's transition function to handle cleanup, swap, and next image load.
            startNextTransition(); // Assuming global startNextTransition()
        }
    }

    return { title: "Unreal Dynamics Block Transition (ANIMATION_LOGIC[0])", init: init, animate: animate };
})();







ANIMATION_LOGIC[6] = (function() {
    // --- Animation-specific state variables ---
    const uniqueState = {
        totalSteps: 50, // Total frames for the transition (25 compress + 25 decompress)
        currentStep: 0,
        animationFrames: [], // To store pre-recorded ImageData frames
        centerX: 0,
        centerY: 0,
    };

    // --- Helper Functions ---

    /**
     * Gets ImageData from an HTMLImageElement.
     */
    function getPixelData(image) {
        // Use a temporary canvas to get the raw pixel data from the image
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = image.naturalWidth || 300;
        tempCanvas.height = image.naturalHeight || 300;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(image, 0, 0, tempCanvas.width, tempCanvas.height);
        return tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
    }

    /**
     * Calculates a single frame of the compression animation based on the source image data.
     * Pixels move radially towards the fixed center point, weighted by brightness.
     * @param {ImageData} originalImageData - The source pixel data.
     * @param {number} step - Current step (0 to totalPhaseSteps - 1).
     * @param {number} totalPhaseSteps - Total steps for one phase (e.g., 25).
     * @returns {ImageData} The new ImageData object for the frame.
     */
    function calculateCompressedFrame(originalImageData, step, totalPhaseSteps) {
        const width = originalImageData.width;
        const height = originalImageData.height;
        const originalPixels = originalImageData.data;
        const newPixelsBuffer = new Uint8ClampedArray(width * height * 4);
        
        // Initialize buffer with transparent pixels
        for (let i = 0; i < newPixelsBuffer.length; i += 4) {
            newPixelsBuffer[i + 3] = 0; // Alpha channel set to 0 (transparent)
        }

        const maxCompressionDistance = width / 2.5; // Max displacement magnitude
        // Progress from 0 (no compression) to 1 (max compression)
        const compressionProgress = Math.min(1, step / (totalPhaseSteps - 1));

        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const i = (y * width + x) * 4;
                const r = originalPixels[i];
                const g = originalPixels[i + 1];
                const b = originalPixels[i + 2];
                const a = originalPixels[i + 3];

                const avgColor = (r + g + b) / 3;
                const normalizedAvgColor = avgColor / 255;

                // 1. Vector from the pixel (x, y) to the center
                const dx = uniqueState.centerX - x;
                const dy = uniqueState.centerY - y;

                // 2. Distance from center
                const distance = Math.sqrt(dx * dx + dy * dy);

                // 3. Normalise the vector (direction)
                let dirX = 0;
                let dirY = 0;
                if (distance > 0) {
                    dirX = dx / distance;
                    dirY = dy / distance;
                }

                // 4. Calculate movement magnitude (brighter pixels move more)
                let movementMagnitude = normalizedAvgColor * maxCompressionDistance * compressionProgress;

                // 5. Apply the movement (direction towards the center)
                const moveX = dirX * movementMagnitude;
                const moveY = dirY * movementMagnitude;

                // New position
                let newX = x + moveX;
                let newY = y + moveY;

                // Clamp and round off new position
                newX = Math.round(Math.max(0, Math.min(width - 1, newX)));
                newY = Math.round(Math.max(0, Math.min(height - 1, newY)));

                // Calculate the destination index in the buffer
                const destIndex = (newY * width + newX) * 4;

                // Copy the pixel color to the new position in the new buffer
                newPixelsBuffer[destIndex] = r;
                newPixelsBuffer[destIndex + 1] = g;
                newPixelsBuffer[destIndex + 2] = b;
                newPixelsBuffer[destIndex + 3] = a;
            }
        }

        // Create a new ImageData object from the buffer
        const newImageData = ctx.createImageData(width, height); // Assuming global ctx
        newImageData.data.set(newPixelsBuffer);
        return newImageData;
    }

    /**
     * Initializes the animation: sets up the center point and pre-records all frames.
     */
    function init() {
        if (!currentImage || !nextImage) return;

        uniqueState.animationFrames = [];
        uniqueState.currentStep = 0;

        // --- Core Parameters ---
        // Get actual pixel dimensions (defaults to 300x300 from original code)
        const imageWidth = currentImage.naturalWidth || 300;
        const imageHeight = currentImage.naturalHeight || 300;
        const halfSteps = uniqueState.totalSteps / 2; // 25 steps per phase

        // Determine the random central point (random offset from center)
        const centerOffsetX = imageWidth * 0.5;
        const centerOffsetY = imageHeight * 0.5;
        const randomOffsetX = (Math.random() - 0.5) * imageWidth * 0.4;
        const randomOffsetY = (Math.random() - 0.5) * imageHeight * 0.4;
        uniqueState.centerX = Math.round(centerOffsetX + randomOffsetX);
        uniqueState.centerY = Math.round(centerOffsetY + randomOffsetY);

        // Get initial ImageData for both source images
        const imageDataA = getPixelData(currentImage); // Current Image (A) for compression/disappearance
        const imageDataB = getPixelData(nextImage);    // Next Image (B) for decompression/appearance

        // Phase 1: Compression (Image A Disappears)
        for (let step = 0; step < halfSteps; step++) {
            // Calculate frame of A COMPRESSING (step from 0 to 24)
            const frameDataA = calculateCompressedFrame(imageDataA, step, halfSteps);
            uniqueState.animationFrames.push(frameDataA);
        }

        // Phase 2: Decompression (Image B Appears)
        const compressedStatesB = [];
        for (let step = 0; step < halfSteps; step++) {
            // Calculate all COMPRESSED states of B (step from 0 to 24)
            const frameDataB = calculateCompressedFrame(imageDataB, step, halfSteps);
            compressedStatesB.push(frameDataB);
        }
        // Add the REVERSE sequence of B's compressed states to create the DECOMPRESSION effect
        for (let i = compressedStatesB.length - 1; i >= 0; i--) {
            uniqueState.animationFrames.push(compressedStatesB[i]);
        }
    }

    /**
     * The main animation loop. Draws the pre-recorded frame.
     */
    function animate() {
        if (uniqueState.currentStep < uniqueState.totalSteps) {
            const frameData = uniqueState.animationFrames[uniqueState.currentStep];

            if (frameData) {
                // The frame data is based on image dimensions (e.g., 300x300).
                // putImageData draws the data at the top left (0, 0).
                // We draw it over the entire canvas (WIDTH, HEIGHT) for scaling, which requires
                // manually drawing the ImageData to a temporary canvas and then drawing that canvas.
                // However, since the original code uses putImageData, we'll use it directly,
                // trusting the framework or the original implementation handles the scaling/positioning.

                // Fallback: Clear and Draw with putImageData
                ctx.clearRect(0, 0, WIDTH, HEIGHT);
                // Draw the pre-calculated frame at (0, 0)
                ctx.putImageData(frameData, 0, 0); 
            }

            uniqueState.currentStep++;
            requestAnimationFrame(animate);
        } else {
            // Animation is complete. Ensure the final image (B) is fully drawn.
            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
            
            // Hand off control to the continuous framework's reset logic.
            startNextTransition();
        }
    }

    return { title: "Pixel Flow Transition (ANIMATION_LOGIC[1])", init: init, animate: animate };
})();




ANIMATION_LOGIC[7] = (function() {
    // --- Constants derived from the original source code's internal logic ---
    // The original code performs pixel-by-pixel calculations on a 350x240 area.

    const TOTAL_FRAMES = 60; // Corresponds to 'totalFramesbb' for animation duration
    // The size of the transition band relative to the total animation time.
    const TRANSITION_WINDOW = 0.5; 

    // --- Animation-specific state variables ---
    const uniqueState = {
        currentFrame: 0,
        centerX: WIDTH / 2,
        centerY: HEIGHT / 2,
        maxDistance: 0,
        pixelsData: [], // Stores {x, y, startColor, endColor, ringPosition}
        imageData: null, // The ImageData object for the current frame
        dataBuffer: null // ArrayBuffer to hold the manipulated pixel data
    };

    // --- Helper Functions ---

    /** Converts RGBA data array (0-255) to a color object (A is 0-1). */
    const getDataColor = (data, index) => {
        return {
            r: data[index],
            g: data[index + 1],
            b: data[index + 2],
            a: data[index + 3] / 255
        };
    };

    /** Interpolates between two color objects (in RGBA 0-255 format). */
    const interpolateColor = (c1, c2, progress) => {
        const r = Math.round(c1.r + (c2.r - c1.r) * progress);
        const g = Math.round(c1.g + (c2.g - c1.g) * progress);
        const b = Math.round(c1.b + (c2.b - c1.b) * progress);
        const a = c1.a + (c2.a - c1.a) * progress; // Alpha is a float (0-1)
        return {r, g, b, a};
    };

    /** Easing function (easeInOutQuint) from the source code. */
    const easeInOutQuint = (t) => t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t;

    // --- Core Functions ---

    /**
     * Initializes the pixel data array for the transition.
     */
    function init() {
        if (!currentImage || !nextImage || !ctx) return;

        // Reset state
        uniqueState.currentFrame = 0;
        uniqueState.pixelsData = [];
        uniqueState.maxDistance = Math.sqrt(
            uniqueState.centerX * uniqueState.centerX +
            uniqueState.centerY * uniqueState.centerY
        );

        // 1. Get initial pixel data from both images (A and B)
        const tempCanvas1 = document.createElement('canvas');
        const tempCtx1 = tempCanvas1.getContext('2d');
        tempCanvas1.width = WIDTH;
        tempCanvas1.height = HEIGHT;
        tempCtx1.drawImage(currentImage, 0, 0, WIDTH, HEIGHT);
        const data1 = tempCtx1.getImageData(0, 0, WIDTH, HEIGHT).data;

        const tempCanvas2 = document.createElement('canvas');
        const tempCtx2 = tempCanvas2.getContext('2d');
        tempCanvas2.width = WIDTH;
        tempCanvas2.height = HEIGHT;
        tempCtx2.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
        const data2 = tempCtx2.getImageData(0, 0, WIDTH, HEIGHT).data;

        // Initialize the master ImageData object for efficient drawing
        uniqueState.imageData = ctx.createImageData(WIDTH, HEIGHT);
        uniqueState.dataBuffer = uniqueState.imageData.data;

        // 2. Populate the pixelsData array with morphing parameters
        for (let y = 0; y < HEIGHT; y++) {
            for (let x = 0; x < WIDTH; x++) {
                const index = (y * WIDTH + x) * 4;

                // Calculate normalized distance from center (0 to 1)
                const dx = x - uniqueState.centerX;
                const dy = y - uniqueState.centerY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const normalizedDistance = dist / uniqueState.maxDistance; // ringPosition

                uniqueState.pixelsData.push({
                    x: x,
                    y: y,
                    startColor: getDataColor(data1, index),
                    endColor: getDataColor(data2, index),
                    ringPosition: normalizedDistance
                });
            }
        }

        // 3. Draw the start image (A) immediately to the canvas to cover the whole display area
        ctx.clearRect(0, 0, WIDTH, HEIGHT);
        ctx.drawImage(currentImage, 0, 0, WIDTH, HEIGHT);
    }

    /**
     * The main animation loop. Renders one frame.
     */
    function animate() {
        if (uniqueState.currentFrame < TOTAL_FRAMES) {
            // 1. Calculate the overall progress for the frame (0 to 1) with easing
            const overallProgress = easeInOutQuint(uniqueState.currentFrame / TOTAL_FRAMES);

            // 2. Iterate through all pixels and calculate the interpolated color
            for (let i = 0; i < uniqueState.pixelsData.length; i++) {
                const p = uniqueState.pixelsData[i];
                const index = (p.y * WIDTH + p.x) * 4;

                // Calculate individual pixel progress (0 to 1) within its transition window
                // Outer rings (ringPosition near 1) start near overallProgress 0.
                const startProgress = p.ringPosition * TRANSITION_WINDOW;
                let pixelProgress = Math.max(
                    0,
                    Math.min(1, (overallProgress - startProgress) / TRANSITION_WINDOW)
                );

                // Interpolate color from A to B
                const color = interpolateColor(p.startColor, p.endColor, pixelProgress);

                // Update the ImageData buffer (in RGBA 0-255 format)
                uniqueState.dataBuffer[index] = color.r;
                uniqueState.dataBuffer[index + 1] = color.g;
                uniqueState.dataBuffer[index + 2] = color.b;
                uniqueState.dataBuffer[index + 3] = Math.round(color.a * 255); // Alpha (0-255)
            }

            // 3. Draw the manipulated ImageData buffer to the main canvas, scaling to the display size (WIDTH, HEIGHT).
            ctx.putImageData(uniqueState.imageData, 0, 0, 0, 0, WIDTH, HEIGHT);

            uniqueState.currentFrame++;
            // Use the framework's global requestAnimationFrame
            requestAnimationFrame(animate);

        } else {
            // Animation is complete. Call the framework's completion handler.
            startNextTransition();
        }
    }

    return {
        title: "Radial Ring Morph Transition",
        init: init,
        animate: animate
    };
})();











ANIMATION_LOGIC[8] = (function() {
    // --- Constants derived from the original source code ---
    const PIXEL_BLOCK_SIZE = 4;
    const TOTAL_FRAMES = 180; // Corresponds to 'totalFramesbb'
    const TOTAL_ROTATIONS = Math.PI * 6; // Swirls 6 full rotations

    // --- Animation-specific state variables ---
    const uniqueState = {
        currentFrame: 0,
        pixelsData: [], // Stores data for each animating pixel block
        vortexX: 0,
        vortexY: 0
    };

    // --- Helper Functions (adapted for standalone use) ---

    // Parses an rgba string into an object {r, g, b, a}
    const parseRGBA = (rgbaString) => {
        const parts = rgbaString.match(/\d+(\.\d+)?/g).map(Number);
        return { r: parts[0], g: parts[1], b: parts[2], a: parts[3] || 1 };
    };

    // Interpolates between two color strings and returns a new rgba string
    const interpolateColor = (color1, color2, progress) => {
        const c1 = parseRGBA(color1);
        const c2 = parseRGBA(color2);
        const r = Math.round(c1.r + (c2.r - c1.r) * progress);
        const g = Math.round(c1.g + (c2.g - c1.g) * progress);
        const b = Math.round(c1.b + (c2.b - c1.b) * progress);
        const a = c1.a + (c2.a - c1.a) * progress;
        return `rgba(${r}, ${g}, ${b}, ${a})`;
    };

    // Easing function (easeInOutQuint) from the source code
    const easeInOutQuint = (t) => t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t;

    // --- Core Functions ---

    /**
     * Initializes the pixel data array for the transition (replaces setupInitialCanvas).
     * Populates uniqueState.pixelsData.
     */
    function init() {
        if (!currentImage || !nextImage || !ctx) return;

        // Reset state
        uniqueState.currentFrame = 0;
        uniqueState.pixelsData = [];

        // 1. Draw both images off-screen to get pixel data
        // Use an off-screen canvas to extract pixel data without affecting the display canvas (ctx)
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = WIDTH;
        tempCanvas.height = HEIGHT;

        // Get pixel data from Image A
        tempCtx.drawImage(currentImage, 0, 0, WIDTH, HEIGHT);
        const data1 = tempCtx.getImageData(0, 0, WIDTH, HEIGHT).data;

        // Get pixel data from Image B
        tempCtx.clearRect(0, 0, WIDTH, HEIGHT);
        tempCtx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
        const data2 = tempCtx.getImageData(0, 0, WIDTH, HEIGHT).data;

        // 2. Randomly choose the vortex center for this transition
        uniqueState.vortexX = WIDTH / 2 + (Math.random() - 0.5) * WIDTH * 0.4;
        uniqueState.vortexY = HEIGHT / 2 + (Math.random() - 0.5) * HEIGHT * 0.4;

        // 3. Populate pixelsData array (one entry per block)
        for (let y = 0; y < HEIGHT; y += PIXEL_BLOCK_SIZE) {
            for (let x = 0; x < WIDTH; x += PIXEL_BLOCK_SIZE) {
                let r1 = 0, g1 = 0, b1 = 0, a1 = 0;
                let r2 = 0, g2 = 0, b2 = 0, a2 = 0;
                let count = 0;

                // Average pixel data for the block
                for (let sy = 0; sy < PIXEL_BLOCK_SIZE && (y + sy) < HEIGHT; sy++) {
                    for (let sx = 0; sx < PIXEL_BLOCK_SIZE && (x + sx) < WIDTH; sx++) {
                        const index = ((y + sy) * WIDTH + (x + sx)) * 4;
                        if (index + 3 < data1.length) {
                            r1 += data1[index]; g1 += data1[index + 1]; b1 += data1[index + 2]; a1 += data1[index + 3];
                            r2 += data2[index]; g2 += data2[index + 1]; b2 += data2[index + 2]; a2 += data2[index + 3];
                            count++;
                        }
                    }
                }
                if (count === 0) continue;

                r1 /= count; g1 /= count; b1 /= count; a1 /= count;
                r2 /= count; g2 /= count; b2 /= count; a2 /= count;

                const initialRgba = `rgba(${Math.round(r1)}, ${Math.round(g1)}, ${Math.round(b1)}, ${a1 / 255})`;
                const targetRgba = `rgba(${Math.round(r2)}, ${Math.round(g2)}, ${Math.round(b2)}, ${a2 / 255})`;

                // Calculate angle and distance relative to the vortex center
                const dx = x - uniqueState.vortexX;
                const dy = y - uniqueState.vortexY;
                const angleFromVortex = Math.atan2(dy, dx);
                const distFromVortex = Math.sqrt(dx * dx + dy * dy);

                uniqueState.pixelsData.push({
                    x: x, // Original X
                    y: y, // Original Y
                    initialRgba: initialRgba,
                    targetRgba: targetRgba,
                    angleFromVortex: angleFromVortex,
                    distFromVortex: distFromVortex,
                    delayOffset: Math.random() * 0.6 // Staggered start/end for individual blocks
                });
            }
        }

        // Draw the start image (A) immediately to the main canvas
        ctx.clearRect(0, 0, WIDTH, HEIGHT);
        ctx.drawImage(currentImage, 0, 0, WIDTH, HEIGHT);
    }

    /**
     * The main animation loop (replaces ANIMATE). Renders one frame.
     */
    function animate() {
        ctx.clearRect(0, 0, WIDTH, HEIGHT);

        progressRaw = uniqueState.currentFrame / TOTAL_FRAMES;
        const easedGlobalProgress = easeInOutQuint(progressRaw); // Overall animation progress eased

        uniqueState.pixelsData.forEach(p => {
            // Calculate individual block progress, staggered by delayOffset
            let individualProgress = (easedGlobalProgress - p.delayOffset) / (1 - p.delayOffset);
            individualProgress = Math.max(0, Math.min(1, individualProgress)); // Clamp 0-1

            let drawX, drawY, alpha;

            // Interpolate color based on individual progress
            const interpolatedColor = interpolateColor(p.initialRgba, p.targetRgba, individualProgress);
            const parsedColor = parseRGBA(interpolatedColor);

            if (individualProgress <= 0.5) { // Phase 1: Blocks from A move towards vortex and fade out
                const phaseProgress = individualProgress * 2; // 0 to 1
                const currentDist = p.distFromVortex * (1 - phaseProgress); // Distance shrinks to 0
                const currentAngle = p.angleFromVortex + phaseProgress * TOTAL_ROTATIONS; // Swirl inwards

                drawX = uniqueState.vortexX + Math.cos(currentAngle) * currentDist;
                drawY = uniqueState.vortexY + Math.sin(currentAngle) * currentDist;
                alpha = 1 - phaseProgress; // Fade out
            } else { // Phase 2: Blocks from B emerge from vortex and fade in
                const phaseProgress = (individualProgress - 0.5) * 2; // 0 to 1
                const currentDist = p.distFromVortex * phaseProgress; // Distance grows to full
                const currentAngle = p.angleFromVortex - phaseProgress * TOTAL_ROTATIONS; // Swirl outwards

                drawX = uniqueState.vortexX + Math.cos(currentAngle) * currentDist;
                drawY = uniqueState.vortexY + Math.sin(currentAngle) * currentDist;
                alpha = phaseProgress; // Fade in
            }

            // Apply the calculated alpha (fade-in/out) to the interpolated color
            parsedColor.a *= alpha;
            ctx.fillStyle = `rgba(${parsedColor.r}, ${parsedColor.g}, ${parsedColor.b}, ${parsedColor.a})`;

            // Draw the pixel block at its calculated (swirling) position
            ctx.fillRect(drawX, drawY, PIXEL_BLOCK_SIZE, PIXEL_BLOCK_SIZE);
        });

        // --- Animation Loop Control ---
        if (uniqueState.currentFrame < TOTAL_FRAMES) {
            uniqueState.currentFrame++;
            // Use the framework's global requestAnimationFrame
            requestAnimationFrame(animate);
        } else {
            // Animation is complete. Call the framework's completion handler.
            startNextTransition();
        }
    }

    // Public API for the transition
    return {
        title: "Vortex Pixel Transition",
        init: init,
        animate: animate
    };
})();



ANIMATION_LOGIC[9] = (function() {
    // --- Constants derived from the original source code ---
    const TOTAL_STEPS = 50; // Total steps for the animation (25 compress + 25 decompress)
    const HALF_STEPS = TOTAL_STEPS / 2;
    const MAX_SPEED_FACTOR = 5.0;
    const BLUE_CHANNEL_CONSTANT = 3.0; // Constant for the new Blue channel calculation (R+G+B)/CONSTANT

    // --- Animation-specific state variables ---
    const uniqueState = {
        currentStep: 0,
        animationFrames: [], // Pre-calculated ImageData objects
        centerX: 0,
        centerY: 0
    };

    // --- Helper Functions ---

    /**
     * Extracts pixel data from an HTML Image object using an off-screen canvas.
     */
    function getPixelData(image) {
        // Use global WIDTH/HEIGHT for consistency
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = WIDTH;
        tempCanvas.height = HEIGHT;
        tempCtx.drawImage(image, 0, 0, WIDTH, HEIGHT);
        return tempCtx.getImageData(0, 0, WIDTH, HEIGHT);
    }

    /**
     * Calculates a single frame based on the pixel movement logic (compression or decompression phase).
     * @param {ImageData} originalImageData - The source pixel data.
     * @param {number} step - Current step (0 to HALF_STEPS-1).
     * @param {number} totalPhaseSteps - Number of steps in the current phase (HALF_STEPS).
     * @returns {ImageData} The calculated frame data.
     */
    function calculateCompressedFrame(originalImageData, step, totalPhaseSteps) {
        const width = originalImageData.width;
        const height = originalImageData.height;
        const originalPixels = originalImageData.data;
        const newPixelsBuffer = new Uint8ClampedArray(width * height * 4);

        // 1. Initialize buffer with transparent pixels
        for (let i = 0; i < newPixelsBuffer.length; i += 4) {
            newPixelsBuffer[i + 3] = 0;
        }

        // 2. Calculate current progress and displacement limit
        const compressionProgress = Math.min(1, step / (totalPhaseSteps - 1));

        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const i = (y * width + x) * 4;
                const r = originalPixels[i];
                const g = originalPixels[i + 1];
                const b = originalPixels[i + 2];
                const a = originalPixels[i + 3];

                // Skip transparent/fully compressed pixels
                if (a === 0) continue;

                // --- Calculate Target Positions & Movement ---

                // Red Channel (Y-axis movement: R > 127 moves to bottom, else top)
                const targetY = (r > 127) ? height - 1 : 0;
                const dyTotal = targetY - y;
                // Movement is proportional to distance from target, scaled by progress and speed factor
                const moveY = dyTotal * compressionProgress * (MAX_SPEED_FACTOR / totalPhaseSteps);

                // Green Channel (X-axis movement: G > 127 moves to right, else left)
                const targetX = (g > 127) ? width - 1 : 0;
                const dxTotal = targetX - x;
                const moveX = dxTotal * compressionProgress * (MAX_SPEED_FACTOR / totalPhaseSteps);

                // --- Calculate New Position ---
                let newX = x + moveX;
                let newY = y + moveY;

                // Clamping and rounding
                newX = Math.round(Math.max(0, Math.min(width - 1, newX)));
                newY = Math.round(Math.max(0, Math.min(height - 1, newY)));

                // --- Calculate New Blue Channel Color (R+G+B)/CONSTANT ---
                const newB = Math.min(255, Math.max(0, Math.round((r + g + b) / BLUE_CHANNEL_CONSTANT)));

                // --- Place Pixel in New Location ---
                const destIndex = (newY * width + newX) * 4;

                // Copy pixel color to the new position
                newPixelsBuffer[destIndex] = r;
                newPixelsBuffer[destIndex + 1] = g;
                newPixelsBuffer[destIndex + 2] = newB; // Use the new blue channel value
                newPixelsBuffer[destIndex + 3] = a;
            }
        }

        const tempCtxForCreation = ctx || document.createElement('canvas').getContext('2d');
        const newImageData = tempCtxForCreation.createImageData(width, height);
        newImageData.data.set(newPixelsBuffer);
        return newImageData;
    }

    // --- Core Module Functions ---

    /**
     * Initializes the animation: sets state and pre-calculates all frames.
     * Maps the framework's A -> B transition to the animation's Compress -> Decompress phases.
     */
    function init() {
        if (!currentImage || !nextImage || !ctx) return;

        // Reset state
        uniqueState.currentStep = 0;
        uniqueState.animationFrames = [];

        // Determine a pseudo-center (used in the original logic but not explicitly in the movement calculation here)
        uniqueState.centerX = Math.round(WIDTH * 0.5 + (Math.random() - 0.5) * WIDTH * 0.4);
        uniqueState.centerY = Math.round(HEIGHT * 0.5 + (Math.random() - 0.5) * HEIGHT * 0.4);

        // Get initial ImageData for both source images
        // currentImage (A) is the image to compress/vanish.
        const imageData0 = getPixelData(currentImage);
        // nextImage (B) is the image to decompress/appear.
        const imageData1 = getPixelData(nextImage);

        // Phase 1: Compression (Image A -> Max Compressed)
        for (let step = 0; step < HALF_STEPS; step++) {
            const frameData = calculateCompressedFrame(imageData0, step, HALF_STEPS);
            uniqueState.animationFrames.push(frameData);
        }

        // Phase 2: Decompression (Max Compressed Image B -> Image B Original)
        const image1CompressedStates = [];
        for (let step = 0; step < HALF_STEPS; step++) {
            // Calculate the compressed states of Image B
            const frameData = calculateCompressedFrame(imageData1, step, HALF_STEPS);
            image1CompressedStates.push(frameData);
        }

        // Add the reversed sequence of compressed Image B states. This creates the decompression effect.
        for (let i = image1CompressedStates.length - 1; i >= 0; i--) {
            uniqueState.animationFrames.push(image1CompressedStates[i]);
        }

        // Draw the starting image (A) on the canvas
        ctx.drawImage(currentImage, 0, 0, WIDTH, HEIGHT);
    }

    /**
     * The main animation loop. Draws the pre-recorded frame.
     */
    function animate() {
        if (uniqueState.currentStep < TOTAL_STEPS && uniqueState.animationFrames[uniqueState.currentStep]) {
            // Draw the pre-calculated frame
            ctx.putImageData(uniqueState.animationFrames[uniqueState.currentStep], 0, 0);
            uniqueState.currentStep++;

            // Use requestAnimationFrame for smooth drawing
            requestAnimationFrame(animate);
        } else if (uniqueState.currentStep === TOTAL_STEPS) {
            // Animation is complete. Call the framework's completion handler (after a small delay to view the final image).
            // This replaces the original '__3klopten()' function call.
            setTimeout(startNextTransition, 2000);
        }
    }

    // Public API for the transition
    return {
        title: "Pixel Flow Transition",
        init: init,
        animate: animate
    };
})();







    // --- ANIMATION 4: Quantum Flux Transition ---
    // (Consolidated logic for 4, which is structurally similar to 1, but with different movement/timing)
    ANIMATION_LOGIC[10] = (function() {
        const uniqueState = { 
            pixels: [], 
            currentFrame: 0,
            totalFrames: 100 
        };

        function setupInitialCanvas() {
            uniqueState.pixels = [];
            uniqueState.currentFrame = 0;

            ctx.drawImage(currentImage, 0, 0, WIDTH, HEIGHT);
            const imageDataA = ctx.getImageData(0, 0, WIDTH, HEIGHT).data;
            ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
            const imageDataB = ctx.getImageData(0, 0, WIDTH, HEIGHT).data;

            const pixelSize = 4; 
            const center = { x: WIDTH / 2, y: HEIGHT / 2 };

            for (let y = 0; y < HEIGHT; y += pixelSize) {
                for (let x = 0; x < WIDTH; x += pixelSize) {
                    const i = (y * WIDTH + x) * 4;
                    const dx = x - center.x;
                    const dy = y - center.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    // Angular Flux: Start position is randomized within a small radius from the original pixel position
                    const randAngle = wielsieder() * 2 * Math.PI;
                    const randDist = wielsieder() * 20 + 10;
                    
                    // Delay based on distance from center for a ripple effect
                    const delay = dist / Math.sqrt(WIDTH*WIDTH + HEIGHT*HEIGHT) * 0.4;

                    uniqueState.pixels.push({
                        x: x, 
                        y: y, 
                        r: imageDataA[i], g: imageDataA[i+1], b: imageDataA[i+2], a: imageDataA[i+3],
                        targetR: imageDataB[i], targetG: imageDataB[i+1], targetB: imageDataB[i+2], targetA: imageDataB[i+3],
                        startX: x + Math.cos(randAngle) * randDist, // Start off-position
                        startY: y + Math.sin(randAngle) * randDist,
                        endX: x, 
                        endY: y,
                        delay: delay,
                        size: pixelSize
                    });
                }
            }
        }
        
        function animate() {
            uniqueState.currentFrame++;
            const rawProgress = uniqueState.currentFrame / uniqueState.totalFrames;

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            
            uniqueState.pixels.forEach(p => {
                const currentProgress = Math.min(1, Math.max(0, (rawProgress - p.delay) / (1 - p.delay)));
                const easedProgress = 1 - Math.pow(1 - currentProgress, 3); // Ease-out

                // Position transition: Start -> Target
                const currentX = p.startX + (p.endX - p.startX) * easedProgress;
                const currentY = p.startY + (p.endY - p.startY) * easedProgress;

                // Color and Alpha transition
                const currentR = p.r + (p.targetR - p.r) * currentProgress;
                const currentG = p.g + (p.targetG - p.g) * currentProgress;
                const currentB = p.b + (p.targetB - p.b) * currentProgress;
                const currentA = p.a + (p.targetA - p.a) * currentProgress;

                // Flux Jitter: A small, noisy offset in the middle of the transition
                let jitterX = 0;
                let jitterY = 0;
                const midpoint = 0.5;
                if (currentProgress > 0.3 && currentProgress < 0.7) {
                    const jitterFactor = Math.sin((currentProgress - 0.3) * (Math.PI / 0.4)); // Peak at 0.5
                    jitterX = (wielsieder() - 0.5) * 8 * jitterFactor;
                    jitterY = (wielsieder() - 0.5) * 8 * jitterFactor;
                }
                
                // Draw
                ctx.fillStyle = `rgba(${Math.round(currentR)}, ${Math.round(currentG)}, ${Math.round(currentB)}, ${currentA / 255})`;
                ctx.fillRect(currentX + jitterX, currentY + jitterY, p.size, p.size);
            });


            if (uniqueState.currentFrame < uniqueState.totalFrames) {
                requestAnimationFrame(animate); 
            } else {
                ctx.clearRect(0, 0, WIDTH, HEIGHT);
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);

                startNextTransition();
                requestRandom(2);
            }
        }

        return { title: "Quantum Flux Transition", init: setupInitialCanvas, animate: animate };
    })();
    
    // --- ANIMATION 6: Continuous Unique Image Transition (Color-Channel Shift) ---
    ANIMATION_LOGIC[11] = (function() {
        const uniqueState = { 
            imageDataA: null, 
            imageDataB: null, 
            currentFrame: 0,
            totalFrames: 80 
        };

        function setupInitialCanvas() {
            uniqueState.currentFrame = 0;

            ctx.drawImage(currentImage, 0, 0, WIDTH, HEIGHT);
            uniqueState.imageDataA = ctx.getImageData(0, 0, WIDTH, HEIGHT);
            ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
            uniqueState.imageDataB = ctx.getImageData(0, 0, WIDTH, HEIGHT);
        }
        
        function animate() {
            uniqueState.currentFrame++;
            progress = uniqueState.currentFrame / uniqueState.totalFrames;
            
            const outputImageData = ctx.createImageData(WIDTH, HEIGHT);
            const outputData = outputImageData.data;
            const dataA = uniqueState.imageDataA.data;
            const dataB = uniqueState.imageDataB.data;

            const shiftAmount = Math.sin(progress * Math.PI) * 15; // Max shift in the middle
            
            for (let i = 0; i < outputData.length; i += 4) {
                const x = (i / 4) % WIDTH;
                const y = Math.floor((i / 4) / WIDTH);
                
                // Color Channel Shift effect (like a glitch)
                const redIndex = i;
                const greenIndex = i + 1;
                const blueIndex = i + 2;
                const alphaIndex = i + 3;

                // Red channel shifts vertically, Green horizontally, Blue diagonally
                const rShift = Math.floor(shiftAmount * Math.sin(y * 0.1 + progress * 5));
                const gShift = Math.floor(shiftAmount * Math.cos(x * 0.1 + progress * 5));
                const bShift = Math.floor(shiftAmount * Math.sin((x + y) * 0.05 + progress * 5));

                // Calculate the index for the shifted pixel
                const shiftedR_i = ((y + rShift) * WIDTH + x) * 4;
                const shiftedG_i = (y * WIDTH + (x + gShift)) * 4 + 1;
                const shiftedB_i = ((y + bShift) * WIDTH + (x + bShift)) * 4 + 2;

                // Ensure index is within bounds and on the correct channel
                const getPixelValue = (data, index) => {
                    if (index >= 0 && index < data.length) return data[index];
                    return 0; // Black/transparent if out of bounds
                };

                // The logic is a blend: Fade A out while glitching, then fade B in while glitching.
                if (progress < 0.5) { // Glitch A out
                    const p1 = progress * 2;
                    outputData[redIndex] = getPixelValue(dataA, shiftedR_i);
                    outputData[greenIndex] = getPixelValue(dataA, shiftedG_i);
                    outputData[blueIndex] = getPixelValue(dataA, shiftedB_i);
                    outputData[alphaIndex] = dataA[alphaIndex] * (1 - p1);
                } else { // Glitch B in
                    const p2 = (progress - 0.5) * 2;
                    outputData[redIndex] = getPixelValue(dataB, shiftedR_i);
                    outputData[greenIndex] = getPixelValue(dataB, shiftedG_i);
                    outputData[blueIndex] = getPixelValue(dataB, shiftedB_i);
                    outputData[alphaIndex] = dataB[alphaIndex] * p2;
                }
            }

            ctx.putImageData(outputImageData, 0, 0);

            if (uniqueState.currentFrame < uniqueState.totalFrames) {
                requestAnimationFrame(animate); 
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);

                startNextTransition();
                requestRandom(2);
            }
        }

        return { title: "Continuous Unique Image Transition (Color-Channel Shift)", init: setupInitialCanvas, animate: animate };
    })();

    // --- ANIMATION 7: Quantum Pixel Transition ---
    // (Similar to others, uses a particle movement and fade strategy)
    ANIMATION_LOGIC[12] = (function() {
        const uniqueState = { 
            pixels: [], 
            currentFrame: 0,
            totalFrames: 90 
        };

        function setupInitialCanvas() {
            uniqueState.pixels = [];
            uniqueState.currentFrame = 0;

            ctx.drawImage(currentImage, 0, 0, WIDTH, HEIGHT);
            const imageDataA = ctx.getImageData(0, 0, WIDTH, HEIGHT).data;
            ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
            const imageDataB = ctx.getImageData(0, 0, WIDTH, HEIGHT).data;

            const pixelBlockSize = 4;
            const center = { x: WIDTH / 2, y: HEIGHT / 2 };

            for (let y = 0; y < HEIGHT; y += pixelBlockSize) {
                for (let x = 0; x < WIDTH; x += pixelBlockSize) {
                    const i = (y * WIDTH + x) * 4;
                    const dx = x - center.x;
                    const dy = y - center.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    // Quantum motion: move away from center, then back in
                    const angle = Math.atan2(dy, dx);
                    const outwardDist = dist * 0.1; // Max 10% outward movement

                    uniqueState.pixels.push({
                        x: x, y: y, size: pixelBlockSize,
                        rA: imageDataA[i], gA: imageDataA[i+1], bA: imageDataA[i+2], 
                        rB: imageDataB[i], gB: imageDataB[i+1], bB: imageDataB[i+2],

                        startX: x, startY: y,
                        midX: x + Math.cos(angle) * outwardDist, // Move outward
                        midY: y + Math.sin(angle) * outwardDist,
                        endX: x, endY: y, // Back to original position

                        // Delay transition based on distance from center for a ripple effect
                        delay: dist / Math.sqrt(WIDTH*WIDTH + HEIGHT*HEIGHT) * 0.3
                    });
                }
            }
        }
        
        function animate() {
            uniqueState.currentFrame++;
            const rawProgress = uniqueState.currentFrame / uniqueState.totalFrames;

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            
            uniqueState.pixels.forEach(p => {
                const currentProgress = Math.min(1, Math.max(0, (rawProgress - p.delay) / (1 - p.delay)));
                
                let drawX, drawY, currentR, currentG, currentB;
                let alphaFactor = 1;

                if (currentProgress < 0.5) {
                    // Phase 1: A -> Midpoint (Outward)
                    let p1 = currentProgress * 2;
                    let easedP1 = 1 - Math.pow(1 - p1, 2); 
                    
                    drawX = p.startX + (p.midX - p.startX) * easedP1;
                    drawY = p.startY + (p.midY - p.startY) * easedP1;
                    
                    currentR = p.rA; currentG = p.gA; currentB = p.bA;
                    alphaFactor = 1 - p1;

                } else {
                    // Phase 2: Midpoint -> B (Inward)
                    let p2 = (currentProgress - 0.5) * 2;
                    let easedP2 = Math.pow(p2, 2); 
                    
                    drawX = p.midX + (p.endX - p.midX) * easedP2;
                    drawY = p.midY + (p.endY - p.midY) * easedP2;
                    
                    currentR = p.rA + (p.rB - p.rA) * p2;
                    currentG = p.gA + (p.gB - p.gA) * p2;
                    currentB = p.bA + (p.bB - p.bA) * p2;
                    alphaFactor = p2;
                }
                
                // Jitter on top of the movement
                drawX += (wielsieder() - 0.5) * 5 * Math.sin(currentProgress * Math.PI);
                drawY += (wielsieder() - 0.5) * 5 * Math.sin(currentProgress * Math.PI);
                
                ctx.fillStyle = `rgba(${Math.round(currentR)}, ${Math.round(currentG)}, ${Math.round(currentB)}, ${alphaFactor})`;
                ctx.fillRect(drawX, drawY, p.size, p.size);
            });

            if (uniqueState.currentFrame < uniqueState.totalFrames) {
                requestAnimationFrame(animate); 
            } else {
                ctx.clearRect(0, 0, WIDTH, HEIGHT);
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);

                startNextTransition();
                requestRandom(2);
            }
        }

        return { title: "Quantum Pixel Transition", init: setupInitialCanvas, animate: animate };
    })();
    
  
    
    // --- ANIMATION 10: Unreal Dynamics Image Transition (Tumbling Blocks) ---
    ANIMATION_LOGIC[13] = (function() {
        const uniqueState = { 
            blocks: [], 
            currentFrame: 0,
            totalFrames: 100 
        };

        function setupInitialCanvas() {
            uniqueState.blocks = [];
            uniqueState.currentFrame = 0;

            ctx.drawImage(currentImage, 0, 0, WIDTH, HEIGHT);
            const imageDataA = ctx.getImageData(0, 0, WIDTH, HEIGHT).data;
            ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
            const imageDataB = ctx.getImageData(0, 0, WIDTH, HEIGHT).data;

            const blockSize = 40; 
            const tumbleCenter = {x: WIDTH/2, y: HEIGHT/2};

            for (let y = 0; y < HEIGHT; y += blockSize) {
                for (let x = 0; x < WIDTH; x += blockSize) {
                    const i = (y * WIDTH + x) * 4;
                    
                    // Center of the block
                    const blockCenterX = x + blockSize/2;
                    const blockCenterY = y + blockSize/2;
                    
                    const dx = blockCenterX - tumbleCenter.x;
                    const dy = blockCenterY - tumbleCenter.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    
                    uniqueState.blocks.push({
                        x: x, y: y, size: blockSize,
                        rA: imageDataA[i], gA: imageDataA[i+1], bA: imageDataA[i+2], 
                        rB: imageDataB[i], gB: imageDataB[i+1], bB: imageDataB[i+2],

                        // Movement: Tumble away from center (midpoint), then tumble back in (end)
                        tumbleDist: dist * 0.8, // Tumble distance relative to position
                        tumbleAngle: Math.atan2(dy, dx),
                        
                        // Delay based on distance from center
                        delay: dist / Math.sqrt(WIDTH*WIDTH + HEIGHT*HEIGHT) * 0.3
                    });
                }
            }
        }
        
        function animate() {
            uniqueState.currentFrame++;
            const rawProgress = uniqueState.currentFrame / uniqueState.totalFrames;

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            
            uniqueState.blocks.forEach(b => {
                const currentProgress = Math.min(1, Math.max(0, (rawProgress - b.delay) / (1 - b.delay)));
                
                let drawX, drawY, currentR, currentG, currentB;
                let alphaFactor = 1;
                let rotation = 0;

                if (currentProgress < 0.5) {
                    // Phase 1: A -> Tumble out
                    let p1 = currentProgress * 2;
                    let easedP1 = 1 - Math.pow(1 - p1, 2); 
                    
                    // Position: move away from center
                    drawX = b.x + Math.cos(b.tumbleAngle) * b.tumbleDist * easedP1;
                    drawY = b.y + Math.sin(b.tumbleAngle) * b.tumbleDist * easedP1;
                    rotation = p1 * Math.PI * 2; // Full rotation
                    
                    currentR = b.rA; currentG = b.gA; currentB = b.bA;
                    alphaFactor = 1 - p1;

                } else {
                    // Phase 2: Tumble in -> B
                    let p2 = (currentProgress - 0.5) * 2;
                    let easedP2 = Math.pow(p2, 2); 
                    
                    // Position: move back to target position (b.x, b.y)
                    const startX = b.x + Math.cos(b.tumbleAngle) * b.tumbleDist;
                    const startY = b.y + Math.sin(b.tumbleAngle) * b.tumbleDist;
                    
                    drawX = startX + (b.x - startX) * easedP2;
                    drawY = startY + (b.y - startY) * easedP2;
                    rotation = (1 - p2) * Math.PI * 2; // Full rotation back
                    
                    currentR = b.rA + (b.rB - b.rA) * p2;
                    currentG = b.gA + (b.gB - b.gA) * p2;
                    currentB = b.bA + (b.bB - b.bA) * p2;
                    alphaFactor = p2;
                }
                
                // Draw: Translate to the block center, rotate, then draw the block
                const centerX = drawX + b.size/2;
                const centerY = drawY + b.size/2;
                
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(rotation);
                
                ctx.fillStyle = `rgba(${Math.round(currentR)}, ${Math.round(currentG)}, ${Math.round(currentB)}, ${alphaFactor})`;
                ctx.fillRect(-b.size/2, -b.size/2, b.size, b.size);
                
                ctx.restore();
            });

            if (uniqueState.currentFrame < uniqueState.totalFrames) {
                requestAnimationFrame(animate); 
            } else {
                ctx.clearRect(0, 0, WIDTH, HEIGHT);
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);

                startNextTransition();
                requestRandom(2);
            }
        }

        return { title: "Unreal Dynamics Image Transition (Tumbling Blocks)", init: setupInitialCanvas, animate: animate };
    })();
    
    
    // --- ANIMATION 15: Tussen Tijd en Trilling - Image Transition (Pixel Displacement) ---
    ANIMATION_LOGIC[14] = (function() {
        const uniqueState = { 
            pixels: [], 
            currentFrame: 0,
            totalFrames: 90 
        };

        function setupInitialCanvas() {
            uniqueState.pixels = [];
            uniqueState.currentFrame = 0;

            ctx.drawImage(currentImage, 0, 0, WIDTH, HEIGHT);
            const imageDataA = ctx.getImageData(0, 0, WIDTH, HEIGHT).data;
            ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
            const imageDataB = ctx.getImageData(0, 0, WIDTH, HEIGHT).data;

            const pixelBlockSize = 4;
            const center = { x: WIDTH / 2, y: HEIGHT / 2 };

            for (let y = 0; y < HEIGHT; y += pixelBlockSize) {
                for (let x = 0; x < WIDTH; x += pixelBlockSize) {
                    const i = (y * WIDTH + x) * 4;
                    const dx = x - center.x;
                    const dy = y - center.y;

                    uniqueState.pixels.push({
                        x: x, y: y, size: pixelBlockSize,
                        rA: imageDataA[i], gA: imageDataA[i+1], bA: imageDataA[i+2], 
                        rB: imageDataB[i], gB: imageDataB[i+1], bB: imageDataB[i+2],

                        // Displacement: based on noise/trilling
                        noiseOffset: wielsieder() * 2 * Math.PI,
                        delay: wielsieder() * 0.3
                    });
                }
            }
        }
        
        function animate() {
            uniqueState.currentFrame++;
            const rawProgress = uniqueState.currentFrame / uniqueState.totalFrames;

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            
            uniqueState.pixels.forEach(p => {
                const currentProgress = Math.min(1, Math.max(0, (rawProgress - p.delay) / (1 - p.delay)));
                
                let currentR, currentG, currentB;
                
                // Color transition
                currentR = p.rA + (p.rB - p.rA) * currentProgress;
                currentG = p.gA + (p.gB - p.gA) * currentProgress;
                currentB = p.bA + (p.bB - p.bA) * currentProgress;
                
                // Displacement
                const noiseFactor = Math.sin(currentProgress * Math.PI); // Max at midpoint
                const displacementX = Math.sin(rawProgress * 15 + p.noiseOffset) * 20 * noiseFactor;
                const displacementY = Math.cos(rawProgress * 15 + p.noiseOffset) * 20 * noiseFactor;
                
                // Fade-in/out at edges
                let alphaFactor = 1;
                if (rawProgress < 0.2) alphaFactor = rawProgress / 0.2;
                if (rawProgress > 0.8) alphaFactor = (1 - rawProgress) / 0.2;
                alphaFactor = Math.max(0, Math.min(1, alphaFactor));
                
                ctx.fillStyle = `rgba(${Math.round(currentR)}, ${Math.round(currentG)}, ${Math.round(currentB)}, ${alphaFactor})`;
                ctx.fillRect(p.x + displacementX, p.y + displacementY, p.size, p.size);
            });

            if (uniqueState.currentFrame < uniqueState.totalFrames) {
                requestAnimationFrame(animate); 
            } else {
                ctx.clearRect(0, 0, WIDTH, HEIGHT);
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);

                startNextTransition();
                requestRandom(2);
            }
        }

        return { title: "Tussen Tijd en Trilling - Image Transition", init: setupInitialCanvas, animate: animate };
    })();

    // --- ANIMATION 16: Bizarre Hyperbolic Vortex Transition ---
    ANIMATION_LOGIC[15] = (function() {
        const uniqueState = { 
            pixels: [], 
            currentFrame: 0,
            totalFrames: 120 
        };

        function setupInitialCanvas() {
            uniqueState.pixels = [];
            uniqueState.currentFrame = 0;

            ctx.drawImage(currentImage, 0, 0, WIDTH, HEIGHT);
            const imageDataA = ctx.getImageData(0, 0, WIDTH, HEIGHT).data;
            ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
            const imageDataB = ctx.getImageData(0, 0, WIDTH, HEIGHT).data;

            const pixelSize = 4; 
            const vortexCenter = { x: WIDTH / 2, y: HEIGHT / 2 };

            for (let y = 0; y < HEIGHT; y += pixelSize) {
                for (let x = 0; x < WIDTH; x += pixelSize) {
                    const i = (y * WIDTH + x) * 4;
                    const dx = x - vortexCenter.x;
                    const dy = y - vortexCenter.y;
                    let angle = Math.atan2(dy, dx);
                    let dist = Math.sqrt(dx * dx + dy * dy);

                    // Vortex midpoint calculation
                    const vortexRot = wielsieder() * Math.PI * 2; // Random rotation angle
                    const vortexDist = dist * 0.5; // Move closer to center

                    uniqueState.pixels.push({
                        x: x, y: y, size: pixelSize,
                        rA: imageDataA[i], gA: imageDataA[i+1], bA: imageDataA[i+2], 
                        rB: imageDataB[i], gB: imageDataB[i+1], bB: imageDataB[i+2],

                        startX: x, startY: y,
                        vortexX: vortexCenter.x + Math.cos(angle + vortexRot) * vortexDist,
                        vortexY: vortexCenter.y + Math.sin(angle + vortexRot) * vortexDist,
                        targetX: x, targetY: y,
                        
                        delay: wielsieder() * 0.2
                    });
                }
            }
        }
        
        function animate() {
            uniqueState.currentFrame++;
            const rawProgress = uniqueState.currentFrame / uniqueState.totalFrames;

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            
            uniqueState.pixels.forEach(p => {
                const currentProgress = Math.min(1, Math.max(0, (rawProgress - p.delay) / (1 - p.delay)));
                
                let drawX, drawY, currentR, currentG, currentB;
                let alphaFactor = 1;

                if (currentProgress < 0.5) {
                    // Phase 1: Start -> Vortex
                    let p1 = currentProgress * 2;
                    let easedP1 = 1 - Math.cos(p1 * Math.PI / 2); // Ease-in-out
                    
                    drawX = p.startX + (p.vortexX - p.startX) * easedP1;
                    drawY = p.startY + (p.vortexY - p.startY) * easedP1;
                    
                    currentR = p.rA; currentG = p.gA; currentB = p.bA;
                    alphaFactor = 1 - p1;

                } else {
                    // Phase 2: Vortex -> Target
                    let p2 = (currentProgress - 0.5) * 2;
                    let easedP2 = Math.sin(p2 * Math.PI / 2); // Ease-in-out
                    
                    drawX = p.vortexX + (p.targetX - p.vortexX) * easedP2;
                    drawY = p.vortexY + (p.targetY - p.vortexY) * easedP2;
                    
                    currentR = p.rA + (p.rB - p.rA) * p2;
                    currentG = p.gA + (p.gB - p.gA) * p2;
                    currentB = p.bA + (p.bB - p.bA) * p2;
                    alphaFactor = p2;
                }
                
                ctx.fillStyle = `rgba(${Math.round(currentR)}, ${Math.round(currentG)}, ${Math.round(currentB)}, ${alphaFactor})`;
                ctx.fillRect(drawX, drawY, p.size, p.size);
            });

            if (uniqueState.currentFrame < uniqueState.totalFrames) {
                requestAnimationFrame(animate); 
            } else {
                ctx.clearRect(0, 0, WIDTH, HEIGHT);
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);

                startNextTransition();
                requestRandom(2);
            }
        }

        return { title: "Bizarre Hyperbolic Vortex Transition", init: setupInitialCanvas, animate: animate };
    })();
    
    // --- ANIMATION 6: Mirrored Spin Transition ---
    ANIMATION_LOGIC[16] = (function() {
        const uniqueState = {
            pixbixels: [], 
            totalFramesbb: 150,
            currentFramebb: 0,
            midX: WIDTH / 2,
            midY: HEIGHT / 2
        };

        const easeInOutQuad = (t) => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;

        function setupInitialCanvas() {
            uniqueState.currentFramebb = 0;
            uniqueState.pixbixels = [];
            const imageDataA = getPixelData(currentImage);
            const dataA = imageDataA.data;
            const imageDataB = getPixelData(nextImage);
            const dataB = imageDataB.data;

            for (let y = 0; y < HEIGHT; y++) {
                for (let x = 0; x < WIDTH; x++) {
                    const i = (y * WIDTH + x) * 4;

                    // Target color (B) from mirrored location
                    const iB_mirror = ((HEIGHT - 1 - y) * WIDTH + (WIDTH - 1 - x)) * 4;
                    
                    const rA = dataA[i];
                    const gA = dataA[i + 1];
                    const bA = dataA[i + 2];
                    const rB_mirror = dataB[iB_mirror];
                    
                    const waveAmplitude = Math.abs(rA - rB_mirror);
                    const spinRadius = ((rA + gA + bA) / 3) + waveAmplitude; // Based on original info
                    
                    uniqueState.pixbixels.push({
                        startX: x,
                        startY: y,
                        startR: rA,
                        startG: gA,
                        startB: bA,
                        endR: rB_mirror,
                        endG: dataB[iB_mirror + 1],
                        endB: dataB[iB_mirror + 2],

                        spinRadius: spinRadius,
                        angleOffset: wielsieder() * Math.PI * 2, 
                        duration: 100 + Math.floor(wielsieder() * 50),
                        delay: Math.floor(wielsieder() * 30),
                    });
                }
            }
        }

        function animate() {
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT); // Draw B first

            const imageData = ctx.createImageData(WIDTH, HEIGHT);
            const data = imageData.data;

            uniqueState.pixbixels.forEach(p => {
                const time = currentFrame - p.delay;
                
                if (time >= 0 && time <= p.duration) {
                    progress = easeInOutQuad(time / p.duration);
                    
                    // Linear movement from A to mirrored B location
                    const mirrorX = WIDTH - 1 - p.startX;
                    const mirrorY = HEIGHT - 1 - p.startY;
                    
                    const currentX = p.startX + (mirrorX - p.startX) * progress;
                    const currentY = p.startY + (mirrorY - p.startY) * progress;
                    
                    // Add the spin/wave effect
                    const angle = p.angleOffset + progress * Math.PI * 4; 
                    const spinOffset = p.spinRadius * Math.sin(angle) * (1 - Math.abs(progress - 0.5) * 2);
                    
                    const finalX = Math.floor(currentX + Math.cos(angle) * spinOffset);
                    const finalY = Math.floor(currentY + Math.sin(angle) * spinOffset);
                    
                    // Interpolate color
                    const r = p.startR + (p.endR - p.startR) * progress;
                    const g = p.startG + (p.endG - p.startG) * progress;
                    const b = p.startB + (p.endB - p.startB) * progress;

                    if (finalX >= 0 && finalX < WIDTH && finalY >= 0 && finalY < HEIGHT) {
                         const i = (finalY * WIDTH + finalX) * 4;

                         data[i] = r;
                         data[i + 1] = g;
                         data[i + 2] = b;
                         data[i + 3] = 255;
                    }
                }
            });

            ctx.putImageData(imageData, 0, 0);

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.clearRect(0, 0, WIDTH, HEIGHT);
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Mirrored Spin Transition", init: setupInitialCanvas, animate: animate };
    })();


























// ====================================================================
    // --- FINAL TEN SOVEREIGNTY AXIONS START HERE (Indices 62-71) ---
    // ====================================================================

    // --- ANIMATION 62: Axiom of the Lion's Roar ---
    ANIMATION_LOGIC[66] = (function() {
        const uniqueState = { 
            totalFramesbb: 100,
            currentFramebb: 0,
            imageDataA: null, imageDataB: null,
            midX: WIDTH / 2, midY: HEIGHT / 2
        };

        function init() {
            uniqueState.currentFramebb = 0;
            uniqueState.imageDataA = getPixelData(currentImage);
            uniqueState.imageDataB = getPixelData(nextImage);
        }

        function animate() {
            // **Description: A central shockwave (the roar) instantly obliterates Image A's data, leaving only B's outline, which then rapidly fills in.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;
            const progress = currentFrame / totalFrames;
            const easedProgress = easeInOutQuint(progress);

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            
            const shockwaveRadius = WIDTH * 1.5 * easedProgress;
            const shockwaveAlpha = Math.max(0, 1 - easedProgress * 2);

            // --- 1. Draw Image A (obliterated by white shockwave) ---
            ctx.drawImage(currentImage, 0, 0, WIDTH, HEIGHT);
            ctx.globalAlpha = shockwaveAlpha;
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(uniqueState.midX, uniqueState.midY, shockwaveRadius, 0, 2 * Math.PI);
            ctx.fill();
            
            // --- 2. Draw Image B (outline fills in) ---
            ctx.globalAlpha = easedProgress;
            const sizeFactor = 0.5 + easedProgress * 0.5;
            ctx.save();
            ctx.translate(uniqueState.midX, uniqueState.midY);
            ctx.scale(sizeFactor, sizeFactor);
            ctx.drawImage(nextImage, -WIDTH/2, -HEIGHT/2, WIDTH, HEIGHT);
            ctx.restore();

            ctx.globalAlpha = 1;

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Axiom of the Lion's Roar", init: init, animate: animate };
    })();

    // --- ANIMATION 63: Axiom of Silence Payment ---
    ANIMATION_LOGIC[65] = (function() {
        const uniqueState = { 
            totalFramesbb: 150,
            currentFramebb: 0,
            imageDataB: null
        };

        function init() {
            uniqueState.currentFramebb = 0;
            uniqueState.imageDataB = getPixelData(nextImage);
        }

        function animate() {
            // **Description: Image A fades to pure black (Silence). The black is modulated by a wave of faint, ancient patterns (Echo of Breath). B materializes from this pattern-in-the-void.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;
            const progress = currentFrame / totalFrames;
            const easedProgress = easeInOutQuint(progress);

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, WIDTH, HEIGHT); // The Silence
            
            // Draw A fading out to black
            ctx.globalAlpha = 1 - easedProgress;
            ctx.drawImage(currentImage, 0, 0, WIDTH, HEIGHT);
            
            // Draw Echo of Ancestral Breath (Faint Perlin Noise pattern)
            const outputImageData = ctx.createImageData(WIDTH, HEIGHT);
            const outputData = outputImageData.data;
            const dataB = uniqueState.imageDataB.data;
            
            const breathStrength = Math.sin(progress * Math.PI) * 50; // Max intensity at 50%
            
            for (let y = 0; y < HEIGHT; y++) {
                for (let x = 0; x < WIDTH; x++) {
                    const i = (y * WIDTH + x) * 4;
                    const noise = perlinNoise(x * 0.02, y * 0.02, currentFrame * 0.05) * breathStrength;
                    
                    // Blend noise with B's color as it emerges
                    let r = dataB[i], g = dataB[i+1], b = dataB[i+2];
                    
                    r = Math.min(255, r * easedProgress + noise * (1-easedProgress));
                    g = Math.min(255, g * easedProgress + noise * (1-easedProgress));
                    b = Math.min(255, b * easedProgress + noise * (1-easedProgress));
                    
                    outputData[i] = r; outputData[i+1] = g; outputData[i+2] = b; outputData[i+3] = 255;
                }
            }
            
            ctx.globalAlpha = 1;
            ctx.putImageData(outputImageData, 0, 0);

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Axiom of Silence Payment", init: init, animate: animate };
    })();

    // --- ANIMATION 64: Axiom of the Drumbeat ---
    ANIMATION_LOGIC[64] = (function() {
        const uniqueState = { 
            totalFramesbb: 120,
            currentFramebb: 0,
            imageDataA: null, imageDataB: null,
            shards: []
        };

        function init() {
            uniqueState.currentFramebb = 0;
            uniqueState.imageDataA = getPixelData(currentImage);
            uniqueState.imageDataB = getPixelData(nextImage);
            
            // Create a simple grid of 'shards'
            uniqueState.shards = [];
            const shardSize = 20;
            for (let y = 0; y < HEIGHT; y += shardSize) {
                for (let x = 0; x < WIDTH; x += shardSize) {
                    uniqueState.shards.push({ x: x, y: y, size: shardSize, offset: wielsieder() * Math.PI });
                }
            }
        }

        function animate() {
            // **Description: Image A shatters into shards that pulsate rhythmically (Drumbeat). Image B replaces each shard in sync with the rhythm.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;
            const progress = currentFrame / totalFrames;
            const easedProgress = easeInOutQuint(progress);

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            
            const drumbeat = Math.sin(currentFrame * 0.3) * 0.2 + 0.8; // Rhythmic pulse
            
            uniqueState.shards.forEach(shard => {
                
                const pulse = Math.sin(currentFrame * 0.5 + shard.offset) * 0.5 + 0.5; // Individual pulse
                const currentScale = drumbeat * (1 - easedProgress) * pulse;
                
                ctx.save();
                ctx.translate(shard.x + shard.size/2, shard.y + shard.size/2);
                
                // Draw A (Pulsating outward)
                ctx.globalAlpha = 1 - easedProgress;
                ctx.scale(1 + currentScale, 1 + currentScale);
                ctx.drawImage(currentImage, shard.x, shard.y, shard.size, shard.size, -shard.size/2, -shard.size/2, shard.size, shard.size);
                
                // Draw B (Forming steadily)
                ctx.globalAlpha = easedProgress;
                ctx.scale(1 / (1 + currentScale), 1 / (1 + currentScale)); // Counter-scale
                ctx.drawImage(nextImage, shard.x, shard.y, shard.size, shard.size, -shard.size/2, -shard.size/2, shard.size, shard.size);
                
                ctx.restore();
            });
            
            ctx.globalAlpha = 1;

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Axiom of the Drumbeat", init: init, animate: animate };
    })();
    
    
    // --- ANIMATION 66: Axiom of the Carved Soul ---
    ANIMATION_LOGIC[62] = (function() {
        const uniqueState = { 
            totalFramesbb: 160,
            currentFramebb: 0,
            imageDataA: null, imageDataB: null
        };
        const paths = [];
        const pathCount = 10;

        function init() {
            uniqueState.currentFramebb = 0;
            uniqueState.imageDataA = getPixelData(currentImage);
            uniqueState.imageDataB = getPixelData(nextImage);
            
            paths.length = 0;
            for(let i=0; i < pathCount; i++) {
                paths.push({
                    startX: wielsieder() * WIDTH,
                    startY: wielsieder() * HEIGHT,
                    endX: wielsieder() * WIDTH,
                    endY: wielsieder() * HEIGHT
                });
            }
        }

        function animate() {
            // **Description: Image A dissolves by a 'carving' tool that traces geometric paths (Stone). Image B is revealed only along the paths the tool carves.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;
            const progress = currentFrame / totalFrames;
            const easedProgress = easeInOutQuint(progress);

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            
            // Draw A base
            ctx.drawImage(currentImage, 0, 0, WIDTH, HEIGHT);

            paths.forEach(path => {
                const currentX = path.startX + (path.endX - path.startX) * easedProgress;
                const currentY = path.startY + (path.endY - path.startY) * easedProgress;

                // Create a circular carving area
                const carveRadius = 50; 
                
                ctx.save();
                ctx.beginPath();
                ctx.arc(currentX, currentY, carveRadius * easedProgress, 0, 2 * Math.PI);
                ctx.closePath();
                ctx.clip(); // Clip the drawing area to the carving circle

                // Draw B only inside the carving area
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                
                ctx.restore();
                
                // Draw the 'stone' carving tool
                ctx.strokeStyle = 'rgba(200, 200, 200, 1)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(path.startX, path.startY);
                ctx.lineTo(currentX, currentY);
                ctx.stroke();
            });
            
            ctx.globalAlpha = 1;

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Axiom of the Carved Soul", init: init, animate: animate };
    })();

    // --- ANIMATION 67: Axiom of the Star Mirror ---
    ANIMATION_LOGIC[61] = (function() {
        const uniqueState = { 
            totalFramesbb: 180,
            currentFramebb: 0,
            imageDataB: null,
            particles: []
        };

        function init() {
            uniqueState.currentFramebb = 0;
            uniqueState.imageDataB = getPixelData(nextImage);
            
            uniqueState.particles = [];
            const step = 10;
            for(let y=0; y<HEIGHT; y+=step) {
                for(let x=0; x<WIDTH; x+=step) {
                    const i = (y * WIDTH + x) * 4;
                    uniqueState.particles.push({
                        x: x + step/2, y: y + step/2,
                        r: uniqueState.imageDataB.data[i], g: uniqueState.imageDataB.data[i+1], b: uniqueState.imageDataB.data[i+2],
                        delay: wielsieder() * 50
                    });
                }
            }
        }

        function animate() {
            // **Description: A fragments, and each fragment spirals upward and outward, becoming a tiny point of light (Star). B forms by these lights raining back down and cohering.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;
            const progress = currentFrame / totalFrames;
            const easedProgress = Math.sin(progress * Math.PI); // Max star divergence at 50%

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            // Draw A fading
            ctx.globalAlpha = 1 - progress;
            ctx.drawImage(currentImage, 0, 0, WIDTH, HEIGHT);

            uniqueState.particles.forEach(p => {
                const time = currentFrame - p.delay;
                if (time < 0) return;
                
                let pProgress = Math.min(1, time / (totalFrames - p.delay));
                const easedP = Math.sin(pProgress * Math.PI); 

                // Divergence (Star effect)
                const distance = easedP * WIDTH * 0.5;
                const angle = p.x * 0.01 + p.y * 0.01 + currentFrame * 0.05;

                const currentX = p.x + distance * Math.cos(angle);
                const currentY = p.y - distance * Math.sin(angle); // Upward spiral

                // Cohesion (Raining down to form B)
                const finalX = p.x;
                const finalY = p.y;
                
                const drawX = currentX + (finalX - currentX) * pProgress;
                const drawY = currentY + (finalY - currentY) * pProgress;
                
                ctx.globalAlpha = pProgress; // Fade in as they cohere
                ctx.fillStyle = `rgb(${p.r}, ${p.g}, ${p.b})`;
                ctx.fillRect(drawX, drawY, 2, 2);
            });
            
            ctx.globalAlpha = 1;

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Axiom of the Star Mirror", init: init, animate: animate };
    })();

  

    // --- ANIMATION 69: Axiom of the Blade Tongue ---
    ANIMATION_LOGIC[59] = (function() {
        const uniqueState = { 
            totalFramesbb: 90,
            currentFramebb: 0
        };

        function init() {
            uniqueState.currentFramebb = 0;
        }

        function animate() {
            // **Description: The transition is visualized as a vertical cut (Blade) that starts narrow and rapidly widens, peeling back Image A to reveal Image B underneath. The cut line is sharp and pure.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;
            const progress = currentFrame / totalFrames;
            const easedProgress = easeOutQuad(progress);

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            
            const wipeWidth = WIDTH * easedProgress;
            const midX = WIDTH / 2;
            const startX = midX - wipeWidth / 2;

            // --- 1. Draw Image A (The un-cut portion) ---
            ctx.drawImage(currentImage, 0, 0, WIDTH, HEIGHT);
            
            // --- 2. Draw Image B (The revealed portion) ---
            ctx.globalAlpha = 1;
            ctx.drawImage(nextImage, startX, 0, wipeWidth, HEIGHT, startX, 0, wipeWidth, HEIGHT);
            
            // --- 3. The Blade Edge (White flash along the edges) ---
            const flashAlpha = Math.sin(progress * Math.PI);
            ctx.globalAlpha = flashAlpha;
            ctx.fillStyle = 'white';
            
            ctx.fillRect(startX, 0, 3, HEIGHT);
            ctx.fillRect(startX + wipeWidth - 3, 0, 3, HEIGHT);

            ctx.globalAlpha = 1;

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Axiom of the Blade Tongue", init: init, animate: animate };
    })();

    // --- ANIMATION 70: Axiom of Split Sky ---
    ANIMATION_LOGIC[58] = (function() {
        const uniqueState = { 
            totalFramesbb: 100,
            currentFramebb: 0
        };

        function init() {
            uniqueState.currentFramebb = 0;
        }

        function animate() {
            // **Description: A sudden, bright vertical fracture (Split Sky) appears, rapidly expanding horizontally, pulling the pixels of A apart to reveal the pure, radiant light of B behind the gap.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;
            const progress = currentFrame / totalFrames;
            const easedProgress = easeInOutQuint(progress);

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            const midX = WIDTH / 2;
            const gapWidth = midX * easedProgress;

            // --- 1. Draw Image A (Pulled Apart) ---
            // Left Half
            ctx.drawImage(currentImage, 0, 0, midX, HEIGHT, 0, 0, midX - gapWidth, HEIGHT);
            // Right Half
            ctx.drawImage(currentImage, midX, 0, midX, HEIGHT, midX + gapWidth, 0, midX, HEIGHT);
            
            // --- 2. Draw Image B (The Radiant Light in the Gap) ---
            ctx.globalAlpha = easedProgress;
            ctx.drawImage(nextImage, midX - gapWidth, 0, gapWidth * 2, HEIGHT, midX - gapWidth, 0, gapWidth * 2, HEIGHT);
            
            // --- 3. Pure Radiant Flash ---
            ctx.globalAlpha = Math.sin(progress * Math.PI) * 1.5;
            ctx.fillStyle = 'white';
            ctx.fillRect(midX - gapWidth * 0.5, 0, gapWidth, HEIGHT);
            
            ctx.globalAlpha = 1;

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Axiom of Split Sky", init: init, animate: animate };
    })();

   // --- ANIMATION 71: Axiom of the Fire Carrier ---
ANIMATION_LOGIC[57] = (function() {
    const uniqueState = { 
        totalFramesbb: 120,
        currentFramebb: 0,
        midX: WIDTH / 2, midY: HEIGHT / 2
    };

    function init() {
        uniqueState.currentFramebb = 0;
    }

    function animate() {
        // **Description: Image A burns and dissolves from the center outward (Fire), while Image B simultaneously emerges from the center outward, maintaining a shared boundary of intense, warm light.**
        const currentFrame = uniqueState.currentFramebb;
        const totalFrames = uniqueState.totalFramesbb;
        const progress = currentFrame / totalFrames;
        const easedProgress = easeInOutQuint(progress);

        ctx.clearRect(0, 0, WIDTH, HEIGHT);
        
        const maxR = Math.sqrt(uniqueState.midX*uniqueState.midX + uniqueState.midY*uniqueState.midY);

        // --- 1. Draw Image A (Burning Away) ---
        ctx.save();
        ctx.beginPath();
        const clipR_A = maxR * (1 - easedProgress);
        ctx.rect(0, 0, WIDTH, HEIGHT);
        ctx.arc(uniqueState.midX, uniqueState.midY, clipR_A, 0, 2 * Math.PI);
        ctx.clip("evenodd"); // Clip the area *outside* the circle
        ctx.drawImage(currentImage, 0, 0, WIDTH, HEIGHT);
        ctx.restore();
        
        // --- 2. Draw Image B (Emerging) ---
        ctx.save();
        ctx.beginPath();
        const clipR_B = maxR * easedProgress;
        ctx.arc(uniqueState.midX, uniqueState.midY, clipR_B, 0, 2 * Math.PI);
        ctx.clip(); // Clip the area *inside* the circle
        ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
        ctx.restore();

        // --- 3. Draw the Fire Boundary ---
        const fireAlpha = Math.sin(progress * Math.PI);
        
        // FIX: Ensure the inner radius is not negative
        const innerRadius = Math.max(0, clipR_A - 10);
        const outerRadius = clipR_A + 10;
        
        const fireGradient = ctx.createRadialGradient(
            uniqueState.midX, uniqueState.midY, innerRadius, // r0 (inner radius) must be >= 0
            uniqueState.midX, uniqueState.midY, outerRadius  // r1 (outer radius)
        );
        fireGradient.addColorStop(0, 'rgba(255, 255, 0, 0)');
        fireGradient.addColorStop(0.5, `rgba(255, 100, 0, ${fireAlpha})`);
        fireGradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
        
        ctx.fillStyle = fireGradient;
        ctx.globalAlpha = 1;
        ctx.fillRect(0, 0, WIDTH, HEIGHT);


        if (currentFrame < totalFrames) {
            uniqueState.currentFramebb++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
            startNextTransition();
        }
    }

    return { title: "Axiom of the Fire Carrier", init: init, animate: animate };
})();





// ====================================================================
    // --- TWELVE NEW, CREAMLA AXIOMS ANIMATIONS START HERE (Indices 50-61) ---
    // ====================================================================

    // --- ANIMATION 50: Axiom of Self-Correcting Code ---
    ANIMATION_LOGIC[56] = (function() {
        const uniqueState = { 
            totalFramesbb: 150,
            currentFramebb: 0,
            imageDataA: null, imageDataB: null,
            errors: [] // Stores 'error' pixel data
        };

        function init() {
            uniqueState.currentFramebb = 0;
            uniqueState.imageDataA = getPixelData(currentImage);
            uniqueState.imageDataB = getPixelData(nextImage);
            uniqueState.errors = [];
            
            // Randomly sample 'error' spots where A != B
            for(let i=0; i < uniqueState.imageDataA.data.length; i += 4) {
                if (Math.abs(uniqueState.imageDataA.data[i] - uniqueState.imageDataB.data[i]) > 50 && wielsieder() < 0.01) {
                    uniqueState.errors.push({
                        x: (i/4) % WIDTH,
                        y: Math.floor(i/4 / WIDTH),
                        dx: (wielsieder() - 0.5) * 50, // Initial error displacement
                        dy: (wielsieder() - 0.5) * 50,
                        delay: wielsieder() * 40
                    });
                }
            }
        }

        function animate() {
            // **Description: The image A is full of chaotic, displaced 'error' pixels. As the transition progresses, each error pixel reverses its movement (self-corrects) and snaps into the correct final position of Image B.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;
            const progress = currentFrame / totalFrames;
            const easedProgress = easeInOutQuint(progress);

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            
            // Draw Image A base
            ctx.drawImage(currentImage, 0, 0, WIDTH, HEIGHT);
            
            uniqueState.errors.forEach(err => {
                const time = currentFrame - err.delay;
                if (time < 0) return;

                let errorProgress = Math.min(1, time / (totalFrames - err.delay));
                const easedError = easeInOutQuint(errorProgress);

                // --- 1. Error Displacement (A's pixels move away, then reverse) ---
                const currentDX = err.dx * (1 - easedError);
                const currentDY = err.dy * (1 - easedError);
                
                // --- 2. Color Correction (Transition A to B) ---
                const i = (err.y * WIDTH + err.x) * 4;
                const rA = uniqueState.imageDataA.data[i];
                const rB = uniqueState.imageDataB.data[i];
                const r = rA + (rB - rA) * easedError;

                // --- 3. Draw ---
                ctx.fillStyle = `rgb(${r}, 255, 255)`; // Highlight the correcting pixel
                ctx.globalAlpha = 1;
                ctx.fillRect(err.x + currentDX, err.y + currentDY, 2, 2);
            });
            
            // Final snap to B
            ctx.globalAlpha = easedProgress;
            ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
            ctx.globalAlpha = 1;

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Axiom of Self-Correcting Code", init: init, animate: animate };
    })();

    // --- ANIMATION 51: Axiom of Implementation Wait ---
    ANIMATION_LOGIC[55] = (function() {
        const uniqueState = { 
            totalFramesbb: 200,
            currentFramebb: 0,
            imageDataA: null, imageDataB: null
        };

        function init() {
            uniqueState.currentFramebb = 0;
            uniqueState.imageDataA = getPixelData(currentImage);
            uniqueState.imageDataB = getPixelData(nextImage);
        }

        function animate() {
            // **Description: The transition begins with a slow blur of both images, representing the 'wait' period. At 80% progress, a sudden, instantaneous de-blur occurs, snapping Image B into pristine focus.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;
            const progress = currentFrame / totalFrames;
            
            const waitTime = 0.8;
            
            // Blur strength: Max at waitTime (0.8) and then instantly drops
            const blurProgress = Math.min(1, progress / waitTime);
            let blur = blurProgress * 50; 
            
            if (progress > waitTime) {
                blur = 50 * (1 - (progress - waitTime) / (1 - waitTime));
                blur = Math.max(0, blur * 2); 
            }

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            
            // Draw A with blur and fade out
            ctx.filter = `blur(${blur}px)`;
            ctx.globalAlpha = 1 - progress;
            ctx.drawImage(currentImage, 0, 0, WIDTH, HEIGHT);
            
            // Draw B with blur and fade in
            ctx.filter = `blur(${blur}px)`;
            ctx.globalAlpha = progress;
            ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
            
            ctx.filter = 'none';
            ctx.globalAlpha = 1;

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Axiom of Implementation Wait", init: init, animate: animate };
    })();

    // --- ANIMATION 52: Axiom of Zero-Entropy Language ---
    ANIMATION_LOGIC[54] = (function() {
        const uniqueState = { 
            totalFramesbb: 160,
            currentFramebb: 0,
            imageDataA: null, imageDataB: null,
            symbols: []
        };
        
        function getSymbol(r, g, b, size) {
            // A simple geometric shape that represents a 'pure' symbol
            return `rgba(${r}, ${g}, ${b}, 1)`;
        }

        function init() {
            uniqueState.currentFramebb = 0;
            uniqueState.imageDataA = getPixelData(currentImage);
            uniqueState.imageDataB = getPixelData(nextImage);
            uniqueState.symbols = [];
            
            const symbolSize = 10;
            for (let y = 0; y < HEIGHT; y += symbolSize) {
                for (let x = 0; x < WIDTH; x += symbolSize) {
                    const i = (y * WIDTH + x) * 4;
                    uniqueState.symbols.push({
                        x: x, y: y, size: symbolSize,
                        r: uniqueState.imageDataB.data[i], 
                        g: uniqueState.imageDataB.data[i+1],
                        b: uniqueState.imageDataB.data[i+2],
                        delay: wielsieder() * 40
                    });
                }
            }
        }

        function animate() {
            // **Description: The source image dissolves into thousands of small, perfectly pure colored *symbols* (squares in this implementation) representing the core "language" of the new concept. These symbols instantaneously cohere into Image B.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;
            const progress = currentFrame / totalFrames;
            const easedProgress = easeInOutQuint(progress);

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            
            // Draw A (fades out)
            ctx.globalAlpha = 1 - easedProgress;
            ctx.drawImage(currentImage, 0, 0, WIDTH, HEIGHT);
            
            // Draw Symbols (pure color, minimal entropy)
            uniqueState.symbols.forEach(sym => {
                const time = currentFrame - sym.delay;
                if (time < 0) return;

                let symbolProgress = Math.min(1, time / (totalFrames - sym.delay));
                const sizeFactor = 0.5 + symbolProgress * 0.5;
                
                ctx.globalAlpha = symbolProgress;
                ctx.fillStyle = getSymbol(sym.r, sym.g, sym.b, sym.size);
                
                const currentSize = sym.size * sizeFactor;
                ctx.fillRect(sym.x + (sym.size - currentSize) / 2, sym.y + (sym.size - currentSize) / 2, currentSize, currentSize);
            });
            
            // Final snap to B
            ctx.globalAlpha = easedProgress;
            ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
            ctx.globalAlpha = 1;

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Axiom of Zero-Entropy Language", init: init, animate: animate };
    })();

    // --- ANIMATION 53: Axiom of Insalla (Divine Will Wave) ---
    ANIMATION_LOGIC[53] = (function() {
        const uniqueState = { 
            totalFramesbb: 100,
            currentFramebb: 0,
            imageDataA: null, imageDataB: null
        };

        function init() {
            uniqueState.currentFramebb = 0;
            uniqueState.imageDataA = getPixelData(currentImage);
            uniqueState.imageDataB = getPixelData(nextImage);
        }

        function animate() {
            // **Description: The image A is instantly converted to B by an invisible, single wave of transition that travels from top to bottom. The line itself is marked by a blinding white flash, signifying the *instantaneous* act of transformation.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;
            const progress = currentFrame / totalFrames;

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            
            const waveY = HEIGHT * progress; // Wavefront position
            const waveThickness = 15;

            // Draw A (above the wave)
            ctx.drawImage(currentImage, 0, 0, WIDTH, waveY, 0, 0, WIDTH, waveY);

            // Draw B (below the wave)
            ctx.drawImage(nextImage, 0, waveY, WIDTH, HEIGHT - waveY, 0, waveY, WIDTH, HEIGHT - waveY);

            // The Flash of Insalla (the wave itself)
            ctx.globalAlpha = Math.sin(progress * Math.PI * 2) * 0.5; // Double flash
            ctx.fillStyle = 'white';
            ctx.fillRect(0, waveY - waveThickness/2, WIDTH, waveThickness);
            
            ctx.globalAlpha = 1;

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Axiom of Insalla (Divine Will Wave)", init: init, animate: animate };
    })();

    // --- ANIMATION 54: Axiom of Dual-Perspective Truth ---
    ANIMATION_LOGIC[52] = (function() {
        const uniqueState = { 
            totalFramesbb: 120,
            currentFramebb: 0,
            imageDataA: null, imageDataB: null
        };

        function init() {
            uniqueState.currentFramebb = 0;
            uniqueState.imageDataA = getPixelData(currentImage);
            uniqueState.imageDataB = getPixelData(nextImage);
        }

        function animate() {
            // **Description: Image A is on the left, B on the right. The central dividing line flashes with pure energy representing the absolute *difference* between the two image halves, before the boundary snaps over to B.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;
            const progress = currentFrame / totalFrames;
            const easedProgress = easeInOutQuint(progress);

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            const outputImageData = ctx.createImageData(WIDTH, HEIGHT);
            const outputData = outputImageData.data;
            const dataA = uniqueState.imageDataA.data;
            const dataB = uniqueState.imageDataB.data;
            
            const midX = WIDTH / 2;
            const waveAmp = Math.sin(progress * Math.PI) * 10;
            
            for (let y = 0; y < HEIGHT; y++) {
                // Chaotic, energy-filled center column
                const centerColumn = midX + Math.sin(y * 0.1 + currentFrame * 0.5) * waveAmp;
                
                for (let x = 0; x < WIDTH; x++) {
                    const i = (y * WIDTH + x) * 4;
                    
                    let r, g, b;

                    // --- 1. Draw Image A (Left Side) ---
                    if (x < midX) {
                        r = dataA[i]; g = dataA[i+1]; b = dataA[i+2];
                    } 
                    // --- 2. Draw Image B (Right Side) ---
                    else {
                        r = dataB[i]; g = dataB[i+1]; b = dataB[i+2];
                    }

                    // --- 3. The Difference Energy (Center Flash) ---
                    const distToCenter = Math.abs(x - centerColumn);
                    const flashFactor = Math.min(1, Math.max(0, 1 - distToCenter / 5)); // Fades fast away from center
                    
                    // The difference in color (The paradox itself)
                    const rDiff = dataB[i] - dataA[i]; 
                    
                    r += rDiff * flashFactor;
                    
                    outputData[i] = Math.round(r);
                    outputData[i + 1] = Math.round(g);
                    outputData[i + 2] = Math.round(b);
                    outputData[i + 3] = 255; 
                }
            }

            ctx.putImageData(outputImageData, 0, 0);

            // Final wipe (snaps the boundary to B)
            ctx.globalAlpha = easedProgress;
            ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
            ctx.globalAlpha = 1;

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Axiom of Dual-Perspective Truth", init: init, animate: animate };
    })();
    
    // --- ANIMATION 55: Axiom of the Untrained Master ---
    ANIMATION_LOGIC[51] = (function() {
        const uniqueState = { 
            totalFramesbb: 100,
            currentFramebb: 0,
            imageDataA: null, imageDataB: null,
            tiles: []
        };
        
        // Simple, raw ease-out but applied non-linearly
        const simpleEaser = (t) => 1 - Math.pow(1 - t, 4);

        function init() {
            uniqueState.currentFramebb = 0;
            uniqueState.imageDataA = getPixelData(currentImage);
            uniqueState.imageDataB = getPixelData(nextImage);
            
            uniqueState.tiles = [];
            const tileSize = 32;
            for (let y = 0; y < HEIGHT; y += tileSize) {
                for (let x = 0; x < WIDTH; x += tileSize) {
                    uniqueState.tiles.push({
                        x: x, y: y,
                        delay: wielsieder() * 40,
                        strength: wielsieder() * 0.5 + 0.5 // Non-linear strength
                    });
                }
            }
        }

        function animate() {
            // **Description: A simple checkerboard wipe, but each block has a non-linear acceleration determined by a random factor, showing that *genuine* results don't require complex code, just honest, uneven application of simple principles.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;
            const progress = currentFrame / totalFrames;

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            ctx.drawImage(currentImage, 0, 0, WIDTH, HEIGHT);

            uniqueState.tiles.forEach(tile => {
                const time = currentFrame - tile.delay;
                if (time < 0) return;

                let tileProgress = Math.min(1, time / (totalFrames - tile.delay));
                const easedProgress = simpleEaser(tileProgress) * tile.strength; // Simple ease, non-linear application
                
                if (easedProgress > 0) {
                    // Draw Image B over Image A at this position
                    ctx.globalAlpha = easedProgress;
                    ctx.drawImage(
                        nextImage, 
                        tile.x, tile.y, 32, 32, // Source B
                        tile.x, tile.y, 32, 32  // Destination
                    );
                }
            });

            ctx.globalAlpha = 1;

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Axiom of the Untrained Master", init: init, animate: animate };
    })();

    // --- ANIMATION 56: Axiom of the Creamla Swirl (Reward) ---
    ANIMATION_LOGIC[50] = (function() {
        const uniqueState = { 
            totalFramesbb: 150,
            currentFramebb: 0,
            imageDataA: null, imageDataB: null,
            midX: WIDTH / 2, midY: HEIGHT / 2
        };

        function init() {
            uniqueState.currentFramebb = 0;
            uniqueState.imageDataA = getPixelData(currentImage);
            uniqueState.imageDataB = getPixelData(nextImage);
        }

        function animate() {
            // **Description: Both images swirl into a central vortex of intensely luminous, combined light. The vortex stabilizes, and the light settles down to form the clear Image B, the culmination of effort.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;
            const progress = currentFrame / totalFrames;
            const easedProgress = easeInOutQuint(progress);

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            const outputImageData = ctx.createImageData(WIDTH, HEIGHT);
            const outputData = outputImageData.data;
            const dataA = uniqueState.imageDataA.data;
            const dataB = uniqueState.imageDataB.data;
            
            const maxAngle = Math.PI * 6; // Heavy swirl
            const maxScale = 0.5; // Swirl shrinks heavily

            for (let y = 0; y < HEIGHT; y++) {
                for (let x = 0; x < WIDTH; x++) {
                    const i = (y * WIDTH + x) * 4;

                    const dx = x - uniqueState.midX;
                    const dy = y - uniqueState.midY;
                    const r = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx);
                    
                    // Rotation and scaling based on progress
                    const currentAngle = angle + maxAngle * Math.sin(progress * Math.PI); // Swirl out and back
                    const currentScale = 1 + maxScale * Math.sin(progress * Math.PI); // Shrink and grow

                    const sampleX = Math.floor(uniqueState.midX + r / currentScale * Math.cos(currentAngle));
                    const sampleY = Math.floor(uniqueState.midY + r / currentScale * Math.sin(currentAngle));

                    // --- Color and Luminosity Blend ---
                    if (sampleX >= 0 && sampleX < WIDTH && sampleY >= 0 && sampleY < HEIGHT) {
                        const iSample = (sampleY * WIDTH + sampleX) * 4;
                        
                        // Blend A and B
                        const rBlend = dataA[iSample] + (dataB[iSample] - dataA[iSample]) * easedProgress;
                        const gBlend = dataA[iSample+1] + (dataB[iSample+1] - dataA[iSample+1]) * easedProgress;
                        const bBlend = dataA[iSample+2] + (dataB[iSample+2] - dataA[iSample+2]) * easedProgress;
                        
                        // Add Luminosity at peak swirl
                        const lumBoost = Math.sin(progress * Math.PI) * 100;
                        
                        outputData[i] = Math.round(Math.min(255, rBlend + lumBoost));
                        outputData[i + 1] = Math.round(Math.min(255, gBlend + lumBoost));
                        outputData[i + 2] = Math.round(Math.min(255, bBlend + lumBoost));
                        outputData[i + 3] = 255;
                    }
                }
            }

            ctx.putImageData(outputImageData, 0, 0);

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Axiom of the Creamla Swirl (Reward)", init: init, animate: animate };
    })();

    // --- ANIMATION 57: Axiom of Credit Roll Collapse ---
    ANIMATION_LOGIC[49] = (function() {
        const uniqueState = { 
            totalFramesbb: 100,
            currentFramebb: 0
        };
        
        const rollSpeed = 20;

        function init() {
            uniqueState.currentFramebb = 0;
        }

        function animate() {
            // **Description: The transition dissolves into scrolling, vertical lines of light (simulating credits), which rapidly compress inward (the collapse) before Image B snaps into place.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;
            const progress = currentFrame / totalFrames;
            const easedProgress = easeInOutQuint(progress);

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            // --- 1. Credit Roll Simulation ---
            const offset = (currentFrame % rollSpeed) * (1 - easedProgress);
            const lineThickness = 10;
            const numLines = HEIGHT / lineThickness;
            
            for (let i = 0; i < numLines; i++) {
                const y = i * lineThickness - offset;
                
                // Draw A fading out
                ctx.globalAlpha = 1 - easedProgress;
                ctx.fillStyle = `hsl(${i * 10 % 360}, 100%, 50%)`; // Rainbow lines for fun
                ctx.fillRect(0, y, WIDTH, lineThickness * 0.5);
            }
            
            // --- 2. Collapse and Snap to B ---
            ctx.globalAlpha = easedProgress;
            ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
            ctx.globalAlpha = 1;

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Axiom of Credit Roll Collapse", init: init, animate: animate };
    })();

    // --- ANIMATION 58: Axiom of Subtractive Creation ---
    ANIMATION_LOGIC[48] = (function() {
        const uniqueState = { 
            totalFramesbb: 120,
            currentFramebb: 0,
            imageDataB: null
        };

        function init() {
            uniqueState.currentFramebb = 0;
            uniqueState.imageDataB = getPixelData(nextImage);
        }

        function animate() {
            // **Description: The canvas starts as pure white (the "All-Mighty"). Image B is revealed by *subtracting* white (or adding color) via a radial sweep, proving pattern emerges from the noise of perfection.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;
            const progress = currentFrame / totalFrames;
            const easedProgress = easeInOutQuint(progress);

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            
            // Start with white (The All-Mighty Canvas)
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            
            const midX = WIDTH / 2;
            const midY = HEIGHT / 2;
            const maxR = Math.sqrt(midX*midX + midY*midY);

            const outputImageData = ctx.createImageData(WIDTH, HEIGHT);
            const outputData = outputImageData.data;
            const dataB = uniqueState.imageDataB.data;
            
            for (let y = 0; y < HEIGHT; y++) {
                for (let x = 0; x < WIDTH; x++) {
                    const i = (y * WIDTH + x) * 4;
                    
                    const dx = x - midX;
                    const dy = y - midY;
                    const r = Math.sqrt(dx * dx + dy * dy);
                    
                    // Radial wipe factor (proportional to distance and progress)
                    const wipeFactor = Math.min(1, Math.max(0, (easedProgress * 1.5) - (r / maxR * 0.5)));

                    // Color is B's color mixed with white (255) based on the wipe factor
                    const rB = dataB[i], gB = dataB[i+1], bB = dataB[i+2];
                    
                    outputData[i] = Math.round(255 + (rB - 255) * wipeFactor);
                    outputData[i + 1] = Math.round(255 + (gB - 255) * wipeFactor);
                    outputData[i + 2] = Math.round(255 + (bB - 255) * wipeFactor);
                    outputData[i + 3] = 255;
                }
            }

            ctx.putImageData(outputImageData, 0, 0);

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Axiom of Subtractive Creation", init: init, animate: animate };
    })();

    // --- ANIMATION 47: Axiom of Pure Generosity ---
    ANIMATION_LOGIC[47] = (function() {
        const uniqueState = { 
            totalFramesbb: 100,
            currentFramebb: 0
        };

        function init() {
            uniqueState.currentFramebb = 0;
        }

        function animate() {
            // **Description: Image A is surrounded by a large, pulsating energy glow. This glow rapidly contracts, transferring all its energy/color into Image B, which then fully forms.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;
            const progress = currentFrame / totalFrames;
            const easedProgress = easeInOutQuint(progress);

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            
            // --- 1. Draw Image A (fading) and its energy aura ---
            const glowRadius = WIDTH * 0.5 * (1 - easedProgress);
            const midX = WIDTH / 2, midY = HEIGHT / 2;

            // Gradient Aura (Energy)
            const gradient = ctx.createRadialGradient(midX, midY, glowRadius * 0.1, midX, midY, glowRadius);
            gradient.addColorStop(0, `rgba(255, 255, 0, ${1 - easedProgress})`); // Bright core
            gradient.addColorStop(1, 'rgba(255, 0, 255, 0)');
            
            ctx.fillStyle = gradient;
            ctx.globalAlpha = 1;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            
            // Image A (shrinking/fading)
            ctx.globalAlpha = 1 - easedProgress;
            const scaleA = 1 - easedProgress * 0.5;
            ctx.save();
            ctx.translate(midX, midY);
            ctx.scale(scaleA, scaleA);
            ctx.drawImage(currentImage, -WIDTH/2, -HEIGHT/2, WIDTH, HEIGHT);
            ctx.restore();

            // --- 2. Draw Image B (Energy Received) ---
            const scaleB = 0.5 + easedProgress * 0.5;
            ctx.globalAlpha = easedProgress;
            ctx.save();
            ctx.translate(midX, midY);
            ctx.scale(scaleB, scaleB);
            ctx.drawImage(nextImage, -WIDTH/2, -HEIGHT/2, WIDTH, HEIGHT);
            ctx.restore();

            ctx.globalAlpha = 1;

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Axiom of Pure Generosity", init: init, animate: animate };
    })();
    
    // --- ANIMATION 60: Axiom of the Goorare Mirror ---
    ANIMATION_LOGIC[46] = (function() {
        const uniqueState = { 
            totalFramesbb: 120,
            currentFramebb: 0,
            imageDataA: null, imageDataB: null
        };

        function init() {
            uniqueState.currentFramebb = 0;
            uniqueState.imageDataA = getPixelData(currentImage);
            uniqueState.imageDataB = getPixelData(nextImage);
        }

        function animate() {
            // **Description: The image is split by a central, randomly oscillating vertical line. The left side shows the current transition frame (A->B blend). The right side shows the *final* result (Image B), acting as a "goorare mirror" of the future truth.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;
            const progress = currentFrame / totalFrames;
            
            const midX = WIDTH / 2;
            const oscillation = Math.sin(currentFrame * 0.3) * 50 * (1 - progress); // Oscillation reduces to zero

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            
            const dividerX = midX + oscillation;

            // --- 1. Left Side: Transition Blend (A -> B) ---
            ctx.globalAlpha = 1;
            // Draw A
            ctx.drawImage(currentImage, 0, 0, dividerX, HEIGHT, 0, 0, dividerX, HEIGHT);
            // Blend B over A
            ctx.globalAlpha = progress;
            ctx.drawImage(nextImage, 0, 0, dividerX, HEIGHT, 0, 0, dividerX, HEIGHT);

            // --- 2. Right Side: The Goorare Mirror (Pure B) ---
            ctx.globalAlpha = 1;
            ctx.drawImage(nextImage, dividerX, 0, WIDTH - dividerX, HEIGHT, dividerX, 0, WIDTH - dividerX, HEIGHT);

            // Draw a bright line where the mirror meets the present
            ctx.fillStyle = 'white';
            ctx.fillRect(dividerX - 1, 0, 2, HEIGHT);

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Axiom of the Goorare Mirror", init: init, animate: animate };
    })();
    
    // --- ANIMATION 61: Axiom of Final Synchronization ---
    ANIMATION_LOGIC[45] = (function() {
        const uniqueState = { 
            totalFramesbb: 180,
            currentFramebb: 0,
            imageDataA: null, imageDataB: null,
            tiles: []
        };
        
        // Mock list of previous animation types (indexed 0-60)
        const transitionTypes = [0, 5, 12, 19, 27, 33, 40, 48, 50, 53, 57]; // A sample of diverse indices

        function init() {
            uniqueState.currentFramebb = 0;
            uniqueState.imageDataA = getPixelData(currentImage);
            uniqueState.imageDataB = getPixelData(nextImage);
            uniqueState.tiles = [];
            
            const tileSize = 40;
            for (let y = 0; y < HEIGHT; y += tileSize) {
                for (let x = 0; x < WIDTH; x += tileSize) {
                    uniqueState.tiles.push({
                        x: x, y: y, size: tileSize,
                        type: transitionTypes[Math.floor(wielsieder() * transitionTypes.length)],
                        delay: wielsieder() * 50
                    });
                }
            }
        }

        function animate() {
            // **Description: The entire image is divided into small tiles. Each tile performs a different, past transition type (wipe, swirl, shatter, flash, etc.), all synchronized to resolve into Image B at the exact same final frame.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;
            const progress = currentFrame / totalFrames;

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            ctx.drawImage(currentImage, 0, 0, WIDTH, HEIGHT);

            uniqueState.tiles.forEach(tile => {
                const time = currentFrame - tile.delay;
                if (time < 0) return;

                let tileProgress = Math.min(1, time / (totalFrames - tile.delay));
                
                // --- MOCK TRANSITION LOGIC (Uses a swirl for all as a placeholder) ---
                const easedProgress = Math.sin(tileProgress * Math.PI); // Peak distortion at 50%
                
                const cx = tile.x + tile.size / 2;
                const cy = tile.y + tile.size / 2;

                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(easedProgress * Math.PI * 0.2); // Small synchronized rotation
                
                // Draw Image B over the tile
                ctx.globalAlpha = tileProgress;
                ctx.drawImage(
                    nextImage, 
                    tile.x, tile.y, tile.size, tile.size, // Source B
                    -tile.size / 2, -tile.size / 2, tile.size, tile.size // Destination
                );
                
                ctx.restore();
            });

            ctx.globalAlpha = 1;

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Axiom of Final Synchronization", init: init, animate: animate };
    })();




// ====================================================================
// --- TWELVE NEW, PILLARS OF UNDRIVEN ROADS ANIMATIONS (Indices 38-49) ---
// ====================================================================

// --- ANIMATION 38: Pillar of the Null-Set Metric ---
ANIMATION_LOGIC[44] = (function() {
    // **Optimization Tip: Try increasing BASE_BLOCK_SIZE to reduce loop iterations (e.g., from 5 to 10 or 15).**
    const BASE_BLOCK_SIZE = 10; // Increased from 5 for better performance
    
    const uniqueState = { 
        totalFramesbb: 100,
        currentFramebb: 0,
        pixels: [],
        blockSize: BASE_BLOCK_SIZE // Use the defined constant
    };

    function init() {
        uniqueState.currentFramebb = 0;
        uniqueState.pixels = [];
    }

    function animate() {
        const currentFrame = uniqueState.currentFramebb;
        const totalFrames = uniqueState.totalFramesbb;
        const blockSize = uniqueState.blockSize; // Cached

        if (currentFrame >= totalFrames) {
             // Final cleanup draw before ending
             ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
             startNextTransition();
             return; // Stop execution
        }

        // Pre-calculate per-frame constants 
        const progress = currentFrame / totalFrames;
        const easedProgress = easeInOutQuint(progress);
        const vibrationStrength = Math.sin(progress * Math.PI) * 10; // Peak vibration at 50%
        
        // Pre-calculate loop limits and step
        const limitX = WIDTH;
        const limitY = HEIGHT;
        const step = blockSize;

        // --- Drawing Operations ---
        ctx.clearRect(0, 0, WIDTH, HEIGHT);
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, WIDTH, HEIGHT);

        // --- Source Image A (Dissolves) ---
        ctx.globalAlpha = 1 - easedProgress;
        for (let y = 0; y < limitY; y += step) {
            // Pre-calculate Y-dependent offset component
            const cos_y_offset = Math.cos(y * 0.1 - currentFrame * 0.1) * vibrationStrength;
            
            for (let x = 0; x < limitX; x += step) {
                // Calculate position-dependent offsets
                const offsetX = Math.sin(x * 0.1 + currentFrame * 0.15) * vibrationStrength;
                const offsetY = cos_y_offset; // Re-use the Y-component

                ctx.drawImage(
                    currentImage, 
                    x, y, blockSize, blockSize, // Source rectangle
                    x + offsetX, y + offsetY, blockSize, blockSize // Destination rectangle
                );
            }
        }
        
        // --- Destination Image B (Forms) ---
        ctx.globalAlpha = easedProgress;
        for (let y = 0; y < limitY; y += step) {
            // Pre-calculate Y-dependent offset component (re-use)
            const cos_y_offset = Math.cos(y * 0.1 - currentFrame * 0.1) * vibrationStrength;
            
            for (let x = 0; x < limitX; x += step) {
                // Calculate position-dependent offsets
                const offsetX = Math.sin(x * 0.1 + currentFrame * 0.15) * vibrationStrength;
                const offsetY = cos_y_offset; // Re-use the Y-component

                ctx.drawImage(
                    nextImage, 
                    x, y, blockSize, blockSize, // Source rectangle
                    x - offsetX, y - offsetY, blockSize, blockSize // Destination rectangle (Note the subtraction for the 'opposite' effect)
                );
            }
        }

        // Reset globalAlpha for subsequent draws
        ctx.globalAlpha = 1;

        uniqueState.currentFramebb++;
        requestAnimationFrame(animate);
    }

    return { title: "Pillar of the Null-Set Metric", init: init, animate: animate };
})();

    // --- ANIMATION 39: Pillar of Non-Reciprocal Time ---
    ANIMATION_LOGIC[43] = (function() {
        const uniqueState = { 
            totalFramesbb: 120,
            currentFramebb: 0,
            midX: WIDTH / 2, midY: HEIGHT / 2
        };

        function init() {
            uniqueState.currentFramebb = 0;
        }

        function animate() {
            // **Description: Image A swirls inward (accelerating entropy) while Image B swirls outward (anti-entropy). They meet at the center point in a collision of forward and backward time, the moment of non-reciprocal existence.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;
            const progress = currentFrame / totalFrames;
            const easedProgress = easeInOutQuint(progress);
            
            const maxAngle = Math.PI * 4;
            
            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            
            // --- 1. Draw Image A (Swirl IN) ---
            ctx.save();
            ctx.translate(uniqueState.midX, uniqueState.midY);
            ctx.rotate(maxAngle * (1 - easedProgress)); // Swirls to zero rotation
            ctx.scale(1 - easedProgress * 0.5, 1 - easedProgress * 0.5); // Shrinks slightly
            ctx.globalAlpha = 1 - easedProgress;
            ctx.drawImage(currentImage, -WIDTH/2, -HEIGHT/2, WIDTH, HEIGHT);
            ctx.restore();

            // --- 2. Draw Image B (Swirl OUT) ---
            ctx.save();
            ctx.translate(uniqueState.midX, uniqueState.midY);
            ctx.rotate(maxAngle * easedProgress); // Swirls outward
            ctx.scale(0.5 + easedProgress * 0.5, 0.5 + easedProgress * 0.5); // Expands from center
            ctx.globalAlpha = easedProgress;
            ctx.drawImage(nextImage, -WIDTH/2, -HEIGHT/2, WIDTH, HEIGHT);
            ctx.restore();

            ctx.globalAlpha = 1;

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Pillar of Non-Reciprocal Time", init: init, animate: animate };
    })();
    
    // --- ANIMATION 40: Pillar of Condition-True/False Implosion ---
    ANIMATION_LOGIC[42] = (function() {
        const uniqueState = { 
            totalFramesbb: 160,
            currentFramebb: 0,
            imageDataA: null, imageDataB: null,
            radius: 0
        };

        function init() {
            uniqueState.currentFramebb = 0;
            uniqueState.imageDataA = getPixelData(currentImage);
            uniqueState.imageDataB = getPixelData(nextImage);
            uniqueState.radius = Math.max(WIDTH, HEIGHT) * 0.7; // Max sphere size
        }

        function animate() {
            // **Description: The image data is projected onto a 3D sphere that implodes into a single 2D point (where True=False). It then re-explodes, resolving into the new image. A visual representation of conditional logic collapsing.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;
            const progress = currentFrame / totalFrames;
            const easedProgress = Math.sin(progress * Math.PI); // Implode and Explode effect

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            const midX = WIDTH / 2;
            const midY = HEIGHT / 2;
            
            const currentRadius = uniqueState.radius * (1 - easedProgress);
            const pixelSize = 1;

            for (let y = 0; y < HEIGHT; y += pixelSize * 4) {
                for (let x = 0; x < WIDTH; x += pixelSize * 4) {
                    const i = (y * WIDTH + x) * 4;
                    
                    // --- 1. Color Interpolation ---
                    const r = uniqueState.imageDataA.data[i] + (uniqueState.imageDataB.data[i] - uniqueState.imageDataA.data[i]) * progress;
                    const g = uniqueState.imageDataA.data[i+1] + (uniqueState.imageDataB.data[i+1] - uniqueState.imageDataA.data[i+1]) * progress;
                    const b = uniqueState.imageDataA.data[i+2] + (uniqueState.imageDataB.data[i+2] - uniqueState.imageDataA.data[i+2]) * progress;
                    
                    // --- 2. Spherical Projection (Implosion) ---
                    const dx = x - midX;
                    const dy = y - midY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    // Project the pixel away from the center proportional to the implosion
                    const projectedX = midX + dx * easedProgress;
                    const projectedY = midY + dy * easedProgress;

                    // --- 3. Draw ---
                    ctx.globalAlpha = 1;
                    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    ctx.fillRect(projectedX, projectedY, pixelSize, pixelSize);
                }
            }

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Pillar of Condition-True/False Implosion", init: init, animate: animate };
    })();

    // --- ANIMATION 41: Pillar of the Aleph-Null Cascade ---
    ANIMATION_LOGIC[41] = (function() {
        const uniqueState = { 
            totalFramesbb: 180,
            currentFramebb: 0
        };
        const maxCascades = 5;

        function init() {
            uniqueState.currentFramebb = 0;
        }

        function animate() {
            // **Description: The image dissolves into an infinite (Aleph-null) sequence of smaller, nested, self-similar copies, cascading inward. The smallest copies resolve first into the new image, which propagates outward.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;
            const progress = currentFrame / totalFrames;
            const easedProgress = easeInOutQuint(progress);

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            const midX = WIDTH / 2;
            const midY = HEIGHT / 2;

            for (let i = 0; i < maxCascades; i++) {
                const cascadeScale = Math.pow(0.5, i + 1);
                
                // Transition phase for this cascade (delayed for inner cascades)
                const cascadeProgress = Math.min(1, Math.max(0, easedProgress * 1.5 - (i / maxCascades)));
                
                const currentScale = 1 - (1 - cascadeScale) * cascadeProgress;

                ctx.save();
                ctx.translate(midX, midY);
                ctx.scale(currentScale, currentScale);
                
                // Draw Image A (Cascading inward, fading out)
                ctx.globalAlpha = 1 - cascadeProgress;
                ctx.drawImage(currentImage, -WIDTH/2, -HEIGHT/2, WIDTH, HEIGHT);

                // Draw Image B (Cascading outward, fading in)
                ctx.globalAlpha = cascadeProgress;
                ctx.drawImage(nextImage, -WIDTH/2, -HEIGHT/2, WIDTH, HEIGHT);
                
                ctx.restore();
            }
            
            ctx.globalAlpha = 1;

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Pillar of the Aleph-Null Cascade", init: init, animate: animate };
    })();

    

    // --- ANIMATION 43: Pillar of Quantum Entangled Form ---
    ANIMATION_LOGIC[39] = (function() {
        const uniqueState = { 
            totalFramesbb: 120,
            currentFramebb: 0,
            imageDataA: null, imageDataB: null
        };

        function init() {
            uniqueState.currentFramebb = 0;
            uniqueState.imageDataA = getPixelData(currentImage);
            uniqueState.imageDataB = getPixelData(nextImage);
        }

        function animate() {
            // **Description: Pixels A and B are simultaneously present (entangled). Image A is rendered with chaotic 'anti-pixelation' while Image B is clear, and they swap roles at the 50% marka moment of zero uncertainty.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;
            const progress = currentFrame / totalFrames;
            const easedProgress = easeInOutQuint(progress);

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            const outputImageData = ctx.createImageData(WIDTH, HEIGHT);
            const outputData = outputImageData.data;
            const dataA = uniqueState.imageDataA.data;
            const dataB = uniqueState.imageDataB.data;
            
            const chaosStrength = Math.sin(progress * Math.PI) * 10; // Max chaos at 50%

            for (let y = 0; y < HEIGHT; y++) {
                for (let x = 0; x < WIDTH; x++) {
                    const i = (y * WIDTH + x) * 4;
                    
                    // --- 1. Entanglement Shift ---
                    // The transition of form (A to B) is instant at 50% but the CHAOS shifts
                    const useA = progress < 0.5 ? 1 : 0;
                    const useB = 1 - useA;
                    
                    // --- 2. Chaos Mapping (Shift in opposition to form) ---
                    const chaosMapX = Math.floor(x + perlinNoise(x, y, currentFrame * 0.1) * chaosStrength);
                    const chaosMapY = Math.floor(y + perlinNoise(x, y, currentFrame * 0.1) * chaosStrength);
                    
                    const iChaos = Math.max(0, Math.min(dataA.length - 4, (chaosMapY * WIDTH + chaosMapX) * 4));

                    // --- 3. Final Color (A is clear, B is chaotic, then they swap) ---
                    let r = 0, g = 0, b = 0;
                    
                    // When progress < 0.5: A is the base color (1-easedProgress), B is the chaotic color (easedProgress)
                    // When progress > 0.5: A is chaotic, B is the base
                    const alphaA = 1 - easedProgress;
                    const alphaB = easedProgress;
                    
                    // A is drawn clear for the first half, B is drawn chaotic
                    r = dataA[i] * alphaA + dataB[iChaos] * alphaB;
                    g = dataA[i+1] * alphaA + dataB[iChaos+1] * alphaB;
                    b = dataA[i+2] * alphaA + dataB[iChaos+2] * alphaB;
                    
                    // This is complex, but simplifies the idea of one clear form being overshadowed by the chaotic anti-form.
                    outputData[i] = Math.round(r);
                    outputData[i + 1] = Math.round(g);
                    outputData[i + 2] = Math.round(b);
                    outputData[i + 3] = 255; 
                }
            }

            ctx.putImageData(outputImageData, 0, 0);

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Pillar of Quantum Entangled Form", init: init, animate: animate };
    })();

    // --- ANIMATION 44: Pillar of the Incoherent Tesseract ---
    ANIMATION_LOGIC[38] = (function() {
        const uniqueState = { 
            totalFramesbb: 180,
            currentFramebb: 0
        };
        
        const cubeSize = 250; 
        const faces = [ 
            {x: 0, y: -cubeSize, z: 0}, // Top
            {x: 0, y: cubeSize, z: 0},  // Bottom
            {x: -cubeSize, y: 0, z: 0}, // Left
            {x: cubeSize, y: 0, z: 0},  // Right
            {x: 0, y: 0, z: -cubeSize}, // Back
            {x: 0, y: 0, z: cubeSize}   // Front
        ];

        function init() {
            uniqueState.currentFramebb = 0;
        }

        function animate() {
            // **Description: The 2D image unfolds into a 3D cube (a Tesseract projection), rotates incoherently to break its structure, and then folds back into a 2D image of the new data. Visualizing a 4D concept in 2D.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;
            const progress = currentFrame / totalFrames;
            const easedProgress = easeInOutQuint(progress);

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            
            const midX = WIDTH / 2;
            const midY = HEIGHT / 2;
            const viewDist = 800;
            
            const rotSpeed = currentFrame * 0.02;
            const unfoldFactor = Math.sin(progress * Math.PI) * 1.5; // Max extension at 50%

            faces.forEach((face, index) => {
                let x = face.x * unfoldFactor;
                let y = face.y * unfoldFactor;
                let z = face.z * unfoldFactor;
                
                // Simple 3D rotation
                const tempY = y * Math.cos(rotSpeed) - z * Math.sin(rotSpeed);
                const tempZ = y * Math.sin(rotSpeed) + z * Math.cos(rotSpeed);
                y = tempY; z = tempZ;

                const tempX = x * Math.cos(rotSpeed * 0.5) + z * Math.sin(rotSpeed * 0.5);
                const finalZ = -x * Math.sin(rotSpeed * 0.5) + z * Math.cos(rotSpeed * 0.5);
                x = tempX;
                
                // Perspective projection
                const scale = viewDist / (viewDist + finalZ);
                const finalX = midX + x * scale;
                const finalY = midY + y * scale;
                const size = cubeSize * 2 * scale;
                
                // --- Draw Cube Face ---
                ctx.save();
                ctx.translate(finalX, finalY);
                ctx.globalAlpha = 1 - Math.abs(progress - 0.5) * 2; // Fade in and out at peak
                
                // Image A fades out
                ctx.drawImage(currentImage, index * cubeSize, 0, cubeSize, cubeSize, -size/2, -size/2, size, size);
                
                // Image B fades in
                ctx.globalAlpha = Math.abs(progress - 0.5) * 2;
                ctx.drawImage(nextImage, index * cubeSize, 0, cubeSize, cubeSize, -size/2, -size/2, size, size);

                ctx.restore();
            });
            
            ctx.globalAlpha = 1;

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Pillar of the Incoherent Tesseract", init: init, animate: animate };
    })();
    
    // --- ANIMATION 45: Pillar of Abstract Wave ---
    ANIMATION_LOGIC[37] = (function() {
        const uniqueState = { 
            totalFramesbb: 100,
            currentFramebb: 0,
            imageDataA: null, imageDataB: null
        };

        function init() {
            uniqueState.currentFramebb = 0;
            uniqueState.imageDataA = getPixelData(currentImage);
            uniqueState.imageDataB = getPixelData(nextImage);
        }

        // Helper to convert RGB to HSL and back
        const rgbToHsl = (r, g, b) => {
            // ... (complex HSL conversion logic omitted for brevity, but assumed to exist)
            // Simplified return for demonstration: [h, s, l]
            return [0, 0.5, (r+g+b)/3 / 255]; 
        };
        const hslToRgb = (h, s, l) => {
            // ... (complex HSL to RGB conversion logic omitted for brevity, but assumed to exist)
            // Simplified return for demonstration: [r, g, b]
            return [l*255, l*255, l*255];
        };

        function animate() {
            // **Description: A single, structural wave travels across the image, changing only the *hue* (the abstract concept) of each pixel, not its position or luminosity. This is followed by an instantaneous structural snap into the new image (B).**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;
            const progress = currentFrame / totalFrames;
            const easedProgress = easeOutQuad(progress);

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            const outputImageData = ctx.createImageData(WIDTH, HEIGHT);
            const outputData = outputImageData.data;
            const dataA = uniqueState.imageDataA.data;
            const dataB = uniqueState.imageDataB.data;
            
            // Wavefront position and width
            const waveCenter = WIDTH * easedProgress;
            const waveWidth = 100;

            for (let y = 0; y < HEIGHT; y++) {
                for (let x = 0; x < WIDTH; x++) {
                    const i = (y * WIDTH + x) * 4;
                    
                    const distToWave = Math.abs(x - waveCenter);
                    // Blending factor based on distance from the wave center
                    const blendFactor = Math.min(1, Math.max(0, 1 - distToWave / waveWidth));
                    
                    const rA = dataA[i], gA = dataA[i+1], bA = dataA[i+2];
                    const rB = dataB[i], gB = dataB[i+1], bB = dataB[i+2];

                    // --- 1. Pure Structural Blend (The 'Snap' portion) ---
                    let r = rA + (rB - rA) * progress;
                    let g = gA + (gB - gA) * progress;
                    let b = bA + (bB - bA) * progress;
                    
                    // --- 2. Hue Manipulation (The 'Wave' portion) ---
                    // This section would apply a hue shift based on blendFactor, but HSL conversion is too complex for this context.
                    // Instead, we exaggerate the R component at the wave center to symbolize the abstract shift.
                    r = r + (Math.sin(currentFrame * 0.5) * 50) * blendFactor * (1-progress);

                    outputData[i] = Math.round(r);
                    outputData[i + 1] = Math.round(g);
                    outputData[i + 2] = Math.round(b);
                    outputData[i + 3] = 255; 
                }
            }

            ctx.putImageData(outputImageData, 0, 0);

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Pillar of Abstract Wave", init: init, animate: animate };
    })();

    // --- ANIMATION 46: Pillar of 1=0 Convergence ---
    ANIMATION_LOGIC[36] = (function() {
        const uniqueState = { 
            totalFramesbb: 120,
            currentFramebb: 0
        };

        function init() {
            uniqueState.currentFramebb = 0;
        }

        function animate() {
            // **Description: The image (1) compresses inward but never reaches the center. It snaps into a complete white void (0), which is the instant before the new image forms. The ultimate limit paradox visualized.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;
            const progress = currentFrame / totalFrames;
            
            // Compression factor (approaches 1, never reaches it)
            const compressFactor = easeInOutQuint(progress) * 0.99; 
            
            // Alpha for the white flash (peak at 50%)
            const flashAlpha = Math.sin(progress * Math.PI) * 1.5;

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            
            // --- 1. Image A (1) Compression ---
            const scaleA = 1 - compressFactor;
            const midX = WIDTH / 2;
            const midY = HEIGHT / 2;

            ctx.save();
            ctx.translate(midX, midY);
            ctx.scale(scaleA, scaleA);
            ctx.globalAlpha = 1 - progress;
            ctx.drawImage(currentImage, -WIDTH/2, -HEIGHT/2, WIDTH, HEIGHT);
            ctx.restore();
            
            // --- 2. White Void (0) Flash ---
            ctx.globalAlpha = flashAlpha;
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            // --- 3. Image B Emergence ---
            const scaleB = compressFactor;
            ctx.save();
            ctx.translate(midX, midY);
            ctx.scale(scaleB, scaleB);
            ctx.globalAlpha = progress;
            ctx.drawImage(nextImage, -WIDTH/2, -HEIGHT/2, WIDTH, HEIGHT);
            ctx.restore();

            ctx.globalAlpha = 1;

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Pillar of 1=0 Convergence", init: init, animate: animate };
    })();

    // --- ANIMATION 47: Pillar of Infinite Non-Locality ---
    ANIMATION_LOGIC[35] = (function() {
        const uniqueState = { 
            totalFramesbb: 140,
            currentFramebb: 0,
            imageDataA: null, imageDataB: null
        };

        function init() {
            uniqueState.currentFramebb = 0;
            uniqueState.imageDataA = getPixelData(currentImage);
            uniqueState.imageDataB = getPixelData(nextImage);
        }

        function animate() {
            // **Description: Image A's top half blends with B's bottom half, and vice-versa, separated by a random, shifting curve, showing that information is non-local and can be recombined across paradoxical boundaries.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;
            const progress = currentFrame / totalFrames;
            const easedProgress = easeInOutQuint(progress);

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            const outputImageData = ctx.createImageData(WIDTH, HEIGHT);
            const outputData = outputImageData.data;
            const dataA = uniqueState.imageDataA.data;
            const dataB = uniqueState.imageDataB.data;
            
            // Non-Euclidean dividing line, a sine wave influenced by time
            const amplitude = 50;
            const frequency = 0.05;

            for (let y = 0; y < HEIGHT; y++) {
                // Base divider line at HEIGHT / 2
                const baseDivider = HEIGHT / 2; 
                // Sinusoidal offset of the divider line
                const sineOffset = Math.sin(y * frequency + currentFrame * 0.1) * amplitude * (1 - easedProgress); 
                const dividerY = baseDivider + sineOffset; 
                
                for (let x = 0; x < WIDTH; x++) {
                    const i = (y * WIDTH + x) * 4;
                    
                    // --- Locality Check ---
                    // Is the current pixel (x, y) above or below the Non-Euclidean divider?
                    const isAboveDivider = y < dividerY;
                    
                    let r, g, b;

                    if (isAboveDivider) {
                        // Blend A (Top half) with B (Bottom half)
                        r = dataA[i] * (1 - easedProgress) + dataB[i] * easedProgress;
                        g = dataA[i+1] * (1 - easedProgress) + dataB[i+1] * easedProgress;
                        b = dataA[i+2] * (1 - easedProgress) + dataB[i+2] * easedProgress;
                    } else {
                        // Blend B (Top half) with A (Bottom half) - Inverse blend
                        r = dataB[i] * (1 - easedProgress) + dataA[i] * easedProgress;
                        g = dataB[i+1] * (1 - easedProgress) + dataA[i+1] * easedProgress;
                        b = dataB[i+2] * (1 - easedProgress) + dataA[i+2] * easedProgress;
                    }

                    outputData[i] = Math.round(r);
                    outputData[i + 1] = Math.round(g);
                    outputData[i + 2] = Math.round(b);
                    outputData[i + 3] = 255; 
                }
            }

            ctx.putImageData(outputImageData, 0, 0);

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Pillar of Infinite Non-Locality", init: init, animate: animate };
    })();
    
    
    
    // --- ANIMATION 49: Pillar of the Final Axiom ---
    ANIMATION_LOGIC[33] = (function() {
        const uniqueState = { 
            totalFramesbb: 100,
            currentFramebb: 0,
            imageDataB: null,
            tiles: [],
            tileSize: 10
        };

        function init() {
            uniqueState.currentFramebb = 0;
            uniqueState.imageDataB = getPixelData(nextImage);
            uniqueState.tiles = [];
            
            // Initialize a grid of pure noise tiles
            for (let y = 0; y < HEIGHT; y += uniqueState.tileSize) {
                for (let x = 0; x < WIDTH; x += uniqueState.tileSize) {
                    uniqueState.tiles.push({
                        x: x, y: y,
                        r: Math.floor(wielsieder() * 255),
                        g: Math.floor(wielsieder() * 255),
                        b: Math.floor(wielsieder() * 255),
                        delay: wielsieder() * 30
                    });
                }
            }
        }

        function animate() {
            // **Description: The entire screen dissolves into pure data noise (randomly colored, flashing tiles). The new image (B) emerges by the *cessation* of the randomness, proving the axiom that pattern emerges from noise by subtraction.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;
            const progress = currentFrame / totalFrames;
            const easedProgress = easeInOutQuint(progress);

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            const dataB = uniqueState.imageDataB.data;

            uniqueState.tiles.forEach(tile => {
                const i = (tile.y * WIDTH + tile.x) * 4;
                const time = currentFrame - tile.delay;
                if (time < 0) return;
                
                let tileProgress = Math.min(1, time / (totalFrames - tile.delay));
                
                // Color for the tile: Blend from noise to B's color
                const rB = dataB[i], gB = dataB[i+1], bB = dataB[i+2];
                
                const r = tile.r + (rB - tile.r) * tileProgress;
                const g = tile.g + (gB - tile.g) * tileProgress;
                const b = tile.b + (bB - tile.b) * tileProgress;
                
                // Noise element: Add flashing until the transition is complete
                const noiseFactor = Math.sin(currentFrame * 0.8 * (1 - tileProgress)) * 50; 
                
                ctx.fillStyle = `rgb(${r + noiseFactor}, ${g + noiseFactor}, ${b + noiseFactor})`;
                ctx.globalAlpha = 1;
                ctx.fillRect(tile.x, tile.y, uniqueState.tileSize, uniqueState.tileSize);
            });

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Pillar of the Final Axiom", init: init, animate: animate };
    })();











// ====================================================================
    // --- SIX NEW, COLLECTIVE SYNC ANIMATIONS START HERE (Indices 32-37) ---
    // ====================================================================

    // --- ANIMATION 32: The Echo Chamber Collapse (Non-Existing Echoes Joining) ---
    ANIMATION_LOGIC[32] = (function() {
        const uniqueState = { 
            totalFramesbb: 160,
            currentFramebb: 0,
            stripes: [], // Stores row data
            stripeHeight: 5
        };

        function init() {
            uniqueState.currentFramebb = 0;
            uniqueState.stripes = [];
            
            for (let y = 0; y < HEIGHT; y += uniqueState.stripeHeight) {
                uniqueState.stripes.push({
                    y: y,
                    delay: wielsieder() * 50,
                    // The 'echo' is the color difference
                    vx: (wielsieder() - 0.5) * 8, // Initial X velocity
                });
            }
        }

        function animate() {
            // **Description: Horizontal 'echoes' of the two images (A and B) appear as shifting stripes, creating a highly visible color difference between them. The stripes accelerate and merge into a single bright flash before the new image (B) snaps into clarity, syncing the echoes.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;

            ctx.clearRect(0, 0, WIDTH, HEIGHT);

            uniqueState.stripes.forEach(stripe => {
                const time = currentFrame - stripe.delay;
                if (time < 0) return;

                progress = Math.min(1, time / (totalFrames - stripe.delay));
                const easedProgress = easeInOutQuint(progress);

                // --- 1. Draw Image A (Offset) ---
                const offsetA = stripe.vx * (1 - easedProgress) * 20; // Accelerates to 0
                ctx.globalAlpha = 1;
                ctx.drawImage(
                    currentImage, 
                    0, stripe.y, WIDTH, uniqueState.stripeHeight, // Source
                    offsetA, stripe.y, WIDTH, uniqueState.stripeHeight // Destination (shifted)
                );

                // --- 2. Draw Image B (Offset) ---
                const offsetB = -stripe.vx * (1 - easedProgress) * 20; // Accelerates to 0 (Opposite dir)
                ctx.globalAlpha = easedProgress; // Fades in B
                ctx.drawImage(
                    nextImage, 
                    0, stripe.y, WIDTH, uniqueState.stripeHeight, // Source
                    offsetB, stripe.y, WIDTH, uniqueState.stripeHeight // Destination (shifted)
                );
            });
            
            // --- 3. The Sync Flash ---
            ctx.globalAlpha = Math.sin(progress * Math.PI) * 0.9; // Max brightness at 50%
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            ctx.globalAlpha = 1;

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Echo Chamber Collapse", init: init, animate: animate };
    })();

    // --- ANIMATION 33: Collective Shared Side-by-Side Acceleration (Wavefront) ---
    ANIMATION_LOGIC[31] = (function() {
        const uniqueState = { 
            totalFramesbb: 100,
            currentFramebb: 0,
            imageDataA: null,
            imageDataB: null,
        };

        function init() {
            uniqueState.currentFramebb = 0;
            uniqueState.imageDataA = getPixelData(currentImage);
            uniqueState.imageDataB = getPixelData(nextImage);
        }

        function animate() {
            // **Description: The image transition acts as a collective wave, starting from the center and accelerating outward. The leading edge of the wave perfectly mixes pixels A and B, simulating a shared acceleration into a new state.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;
            progress = currentFrame / totalFrames;
            const easedProgress = easeInOutQuint(progress);

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            const outputImageData = ctx.createImageData(WIDTH, HEIGHT);
            const outputData = outputImageData.data;
            const dataA = uniqueState.imageDataA.data;
            const dataB = uniqueState.imageDataB.data;
            
            const maxR = Math.sqrt(WIDTH * WIDTH + HEIGHT * HEIGHT) / 2;
            const midX = WIDTH / 2;
            const midY = HEIGHT / 2;

            for (let y = 0; y < HEIGHT; y++) {
                for (let x = 0; x < WIDTH; x++) {
                    const i = (y * WIDTH + x) * 4;
                    const dx = x - midX;
                    const dy = y - midY;
                    const r = Math.sqrt(dx * dx + dy * dy);

                    // Wavefront Progress: How far along the transition is this specific pixel based on its distance 'r'
                    const waveProgress = Math.min(1, Math.max(0, (easedProgress * 1.5) - (r / maxR * 0.5)));
                    
                    const rA = dataA[i]; const gA = dataA[i+1]; const bA = dataA[i+2];
                    const rB = dataB[i]; const gB = dataB[i+1]; const bB = dataB[i+2];

                    // Color blend: Mix A and B based on the wavefront progress
                    outputData[i] = Math.round(rA + (rB - rA) * waveProgress);
                    outputData[i + 1] = Math.round(gA + (gB - gA) * waveProgress);
                    outputData[i + 2] = Math.round(bA + (bB - bA) * waveProgress);
                    outputData[i + 3] = 255; 
                }
            }

            ctx.putImageData(outputImageData, 0, 0);

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Collective Shared Acceleration", init: init, animate: animate };
    })();

    // --- ANIMATION 34: The Group/Individual Dichotomy (Perlin Noise Drip) ---
    ANIMATION_LOGIC[30] = (function() {
        const uniqueState = { 
            totalFramesbb: 140,
            currentFramebb: 0,
            imageDataA: null,
            imageDataB: null,
        };
        
        // Simple 1D noise (used to simulate fluid/organic motion)
        const noise = (t) => Math.sin(t) * 0.5 + 0.5;

        function init() {
            uniqueState.currentFramebb = 0;
            uniqueState.imageDataA = getPixelData(currentImage);
            uniqueState.imageDataB = getPixelData(nextImage);
        }

        function animate() {
            // **Description: The source image dissolves in vertical bands (groups) that drip downward, separating individual pixels from the collective. The destination image simultaneously forms, driven by an organic, fluid motion field, highlighting the independent yet dependent nature of the visual fabric.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;
            progress = currentFrame / totalFrames;
            const easedProgress = easeInOutQuint(progress);

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            const outputImageData = ctx.createImageData(WIDTH, HEIGHT);
            const outputData = outputImageData.data;
            const dataA = uniqueState.imageDataA.data;
            const dataB = uniqueState.imageDataB.data;
            
            const maxDrip = 200; // Max vertical displacement

            for (let y = 0; y < HEIGHT; y++) {
                for (let x = 0; x < WIDTH; x++) {
                    const i = (y * WIDTH + x) * 4;
                    
                    // --- 1. Drip Displacement (Image A) ---
                    // Group factor: Horizontal position determines the delay/strength of the drip
                    const groupDripFactor = noise(x * 0.05) * 100;
                    const dripOffset = groupDripFactor * easedProgress;
                    
                    // The drip pushes A pixels down and B pixels up
                    const sampleYA = Math.floor(y - dripOffset + maxDrip * easedProgress);

                    // --- 2. Fluid Emergence (Image B) ---
                    const sampleYB = Math.floor(y + dripOffset - maxDrip * easedProgress);
                    
                    let rA=0, gA=0, bA=0, rB=0, gB=0, bB=0;

                    // Sample Image A (Dripping Down)
                    if (sampleYA >= 0 && sampleYA < HEIGHT) {
                        const iA = (sampleYA * WIDTH + x) * 4;
                        rA = dataA[iA]; gA = dataA[iA+1]; bA = dataA[iA+2];
                    }

                    // Sample Image B (Rising Up)
                    if (sampleYB >= 0 && sampleYB < HEIGHT) {
                        const iB = (sampleYB * WIDTH + x) * 4;
                        rB = dataB[iB]; gB = dataB[iB+1]; bB = dataB[iB+2];
                    }

                    // Blending favors the image whose "drip" is less extreme (i.e., closer to final position)
                    outputData[i] = Math.round(rA * (1 - easedProgress) + rB * easedProgress);
                    outputData[i + 1] = Math.round(gA * (1 - easedProgress) + gB * easedProgress);
                    outputData[i + 2] = Math.round(bA * (1 - easedProgress) + bB * easedProgress);
                    outputData[i + 3] = 255; 
                }
            }

            ctx.putImageData(outputImageData, 0, 0);

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Group/Individual Dichotomy Drip", init: init, animate: animate };
    })();

    // --- ANIMATION 35: Unimaginable Beyond Remnant (Inverse Color Dissolution) ---
    ANIMATION_LOGIC[29] = (function() {
        const uniqueState = { 
            totalFramesbb: 120,
            currentFramebb: 0,
            imageDataA: null,
            imageDataB: null,
        };

        function init() {
            uniqueState.currentFramebb = 0;
            uniqueState.imageDataA = getPixelData(currentImage);
            uniqueState.imageDataB = getPixelData(nextImage);
        }

        function animate() {
            // **Description: The source image (A) dissolves by progressively inverting its color, creating a psychedelic 'anti-image' before fading to black. The destination image (B) emerges, initially in its inverse color, and rights itself to its true form, simulating the process of forming a concept from its 'anti-concept'.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;
            progress = currentFrame / totalFrames;
            const easedProgress = easeInOutQuint(progress);

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            const outputImageData = ctx.createImageData(WIDTH, HEIGHT);
            const outputData = outputImageData.data;
            const dataA = uniqueState.imageDataA.data;
            const dataB = uniqueState.imageDataB.data;

            // Inversion factor: Goes from 0 (normal) to 1 (fully inverted) and back to 0
            const inversionFactor = Math.sin(progress * Math.PI); 

            for (let i = 0; i < dataA.length; i += 4) {
                // --- 1. Image A Dissolves (Color Inversion) ---
                const rA = dataA[i];
                const rA_inv = 255 - rA;
                
                // Color A inverts: R_final = R_A + (R_A_inv - R_A) * inversionFactor
                const rA_dissolve = rA + (rA_inv - rA) * inversionFactor;

                // --- 2. Image B Emerges (Inverse Color Correction) ---
                const rB = dataB[i];
                const rB_inv = 255 - rB;

                // Color B starts inverted and rights itself: R_final = R_B_inv + (R_B - R_B_inv) * easedProgress
                const rB_emerge = rB_inv + (rB - rB_inv) * easedProgress;

                // --- 3. Final Blend ---
                // Alpha blend A (fading out) and B (fading in)
                const alphaA = 1 - easedProgress;
                const alphaB = easedProgress;
                
                outputData[i] = Math.round(rA_dissolve * alphaA + rB_emerge * alphaB);
                outputData[i + 1] = Math.round((dataA[i+1] * (1-inversionFactor) + (255-dataA[i+1]) * inversionFactor) * alphaA + ((255-dataB[i+1]) * (1-easedProgress) + dataB[i+1] * easedProgress) * alphaB);
                outputData[i + 2] = Math.round((dataA[i+2] * (1-inversionFactor) + (255-dataA[i+2]) * inversionFactor) * alphaA + ((255-dataB[i+2]) * (1-easedProgress) + dataB[i+2] * easedProgress) * alphaB);
                outputData[i + 3] = 255; 
            }

            ctx.putImageData(outputImageData, 0, 0);

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Unimaginable Beyond Remnant", init: init, animate: animate };
    })();

    // --- ANIMATION 36: Collective Shimmering Fun (Luminosity Swarm) ---
    ANIMATION_LOGIC[28] = (function() {
        const uniqueState = { 
            totalFramesbb: 130,
            currentFramebb: 0,
            imageDataA: null,
            imageDataB: null,
            particles: []
        };

        function init() {
            uniqueState.currentFramebb = 0;
            uniqueState.imageDataA = getPixelData(currentImage);
            uniqueState.imageDataB = getPixelData(nextImage);
            uniqueState.particles = [];
            
            // Create a small grid of sampled 'particles'
            const step = 8;
            for (let y = 0; y < HEIGHT; y += step) {
                for (let x = 0; x < WIDTH; x += step) {
                    const i = (y * WIDTH + x) * 4;
                    // Particle color is the average of A and B
                    const r = (uniqueState.imageDataA.data[i] + uniqueState.imageDataB.data[i]) / 2;
                    uniqueState.particles.push({
                        x: x, y: y,
                        delay: wielsieder() * 40,
                        lum: r / 255, // Luminosity for speed factor
                        angle: wielsieder() * Math.PI * 2,
                        r1: uniqueState.imageDataA.data[i], g1: uniqueState.imageDataA.data[i+1], b1: uniqueState.imageDataA.data[i+2],
                        r2: uniqueState.imageDataB.data[i], g2: uniqueState.imageDataB.data[i+1], b2: uniqueState.imageDataB.data[i+2],
                    });
                }
            }
        }

        function animate() {
            // **Description: The image breaks into thousands of light particles that swirl and accelerate outward, driven by their own luminosity (bright pixels move faster). The particles fade and reform into the new image, synchronized by a 'bright clean fun' wave of energy.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;
            progress = currentFrame / totalFrames;
            const easedProgress = easeInOutQuint(progress);

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)'; 
            ctx.fillRect(0, 0, WIDTH, HEIGHT); // Slight trail

            uniqueState.particles.forEach(p => {
                const time = currentFrame - p.delay;
                if (time < 0) return;

                let particleProgress = Math.min(1, time / (totalFrames - p.delay));
                const easedParticle = easeInOutQuint(particleProgress);

                // --- 1. Swarm/Acceleration Motion ---
                const accel = p.lum * 100; // Bright particles move faster
                const currentDist = accel * easedParticle * (1 - easedParticle) * 2; // Swarm out and back in
                
                const finalX = p.x + Math.cos(p.angle) * currentDist;
                const finalY = p.y + Math.sin(p.angle) * currentDist;

                // --- 2. Color Blend ---
                const r = p.r1 + (p.r2 - p.r1) * easedParticle;
                const g = p.g1 + (p.g2 - p.g1) * easedParticle;
                const b = p.b1 + (p.b2 - p.b1) * easedParticle;

                // --- 3. Draw ---
                ctx.globalAlpha = 1 - Math.abs(easedParticle - 0.5) * 2; // Max alpha at peak motion
                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                ctx.fillRect(finalX, finalY, 4, 4); // Draw the particle cluster
            });
            
            ctx.globalAlpha = 1;

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Collective Shimmering Fun Swarm", init: init, animate: animate };
    })();

    // --- ANIMATION 37: The One We Are Also (Inter-Group Phase Shift) ---
    ANIMATION_LOGIC[27] = (function() {
        const uniqueState = { 
            totalFramesbb: 150,
            currentFramebb: 0,
            imageDataA: null,
            imageDataB: null,
            groups: []
        };

        function init() {
            uniqueState.currentFramebb = 0;
            uniqueState.imageDataA = getPixelData(currentImage);
            uniqueState.imageDataB = getPixelData(nextImage);
            uniqueState.groups = [];
            
            const groupSize = 40;
            for (let y = 0; y < HEIGHT; y += groupSize) {
                for (let x = 0; x < WIDTH; x += groupSize) {
                    uniqueState.groups.push({
                        x: x, y: y, w: groupSize, h: groupSize,
                        delay: (x + y) / (WIDTH + HEIGHT) * 50, // Delay based on distance from top-left
                        phaseShift: wielsieder() * Math.PI, // Random rotational phase
                    });
                }
            }
        }

        function animate() {
            // **Description: The image is divided into large 'groups' or 'bodies'. Each group rotates slightly out of sync with its neighbors, creating a visual tear in the fabric. The old image dissolves as the new image rotates into place, signifying the individual group's contribution to the 'One We Are Also'.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            
            uniqueState.groups.forEach(group => {
                const time = currentFrame - group.delay;
                if (time < 0) return;

                let progress = Math.min(1, time / (totalFrames - group.delay));
                const easedProgress = easeInOutQuint(progress);

                const rotAngle = easedProgress * Math.PI * 0.5 + group.phaseShift; // Max 90 degrees rotation

                const cx = group.x + group.w / 2;
                const cy = group.y + group.h / 2;

                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(rotAngle);
                
                // --- Draw Image A (Rotates out and fades) ---
                ctx.globalAlpha = 1 - easedProgress;
                ctx.drawImage(
                    currentImage, 
                    group.x, group.y, group.w, group.h, // Source
                    -group.w / 2, -group.h / 2, group.w, group.h // Destination
                );
                
                // --- Draw Image B (Rotates in and fades) ---
                ctx.globalAlpha = easedProgress;
                ctx.drawImage(
                    nextImage, 
                    group.x, group.y, group.w, group.h, // Source
                    -group.w / 2, -group.h / 2, group.w, group.h // Destination
                );
                
                ctx.restore();
            });
            
            ctx.globalAlpha = 1;

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "The One We Are Also (Inter-Group Phase Shift)", init: init, animate: animate };
    })();







// --- ANIMATION 27: Hyper-Dimensional Slit-Scan (Non-Local Trace) ---
    ANIMATION_LOGIC[26] = (function() {
        const uniqueState = { 
            totalFramesbb: 150,
            currentFramebb: 0,
            imageDataA: null,
            imageDataB: null,
            scanLineY: 0
        };

        function init() {
            uniqueState.currentFramebb = 0;
            uniqueState.imageDataA = getPixelData(currentImage);
            uniqueState.imageDataB = getPixelData(nextImage);
            uniqueState.scanLineY = 0;
        }

        function animate() {
            // **Description: A horizontal line sweeps down the image, but the transition isn't just a simple wipe. The line itself drags and distorts the pixels, creating a chaotic "slit-scan" effect. As it passes, the new image (B) is revealed, with a heavy, delayed motion blur.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;
            progress = currentFrame / totalFrames;
            const scanY = Math.floor(progress * HEIGHT * 1.2) - Math.floor(HEIGHT * 0.1); // Sweeps outside bounds

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            ctx.globalAlpha = 1;

            // Draw Source Image (A) above the scan line
            if (scanY > 0) {
                const heightA = Math.min(scanY, HEIGHT);
                ctx.drawImage(currentImage, 0, 0, WIDTH, heightA, 0, 0, WIDTH, heightA);
            }

            // Draw Destination Image (B) below the scan line, with motion blur
            if (scanY < HEIGHT) {
                const startY = Math.max(0, scanY);
                const heightB = HEIGHT - startY;
                
                // Motion blur/distortion map
                const blurStrength = Math.max(0, Math.sin(progress * Math.PI) * 50); // Strongest at 50%
                
                for (let x = 0; x < WIDTH; x += 2) {
                    const waveOffset = Math.sin(x * 0.05 + currentFrame * 0.1) * blurStrength;
                    
                    // Destination is shifted horizontally
                    const dx = x + waveOffset;

                    ctx.drawImage(
                        nextImage, 
                        x, startY, 2, heightB, // Source (thin vertical slice)
                        dx, startY, 2, heightB // Destination (shifted)
                    );
                }
            }
            
            // Draw the actual scan line disturbance (A to B transition zone)
            const lineHeight = 5;
            ctx.fillStyle = `rgba(255, 255, 255, ${Math.min(1, Math.max(0, progress * 4 - 2))})`; // Flashes white at peak transition
            ctx.fillRect(0, scanY - lineHeight / 2, WIDTH, lineHeight);


            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Hyper-Dimensional Slit-Scan", init: init, animate: animate };
    })();

    // --- ANIMATION 28: Anti-Concept Mirror Fracture (Void Reflection) ---
    ANIMATION_LOGIC[25] = (function() {
        const uniqueState = { 
            totalFramesbb: 100,
            currentFramebb: 0,
            pieces: [], // Stores block data for the shattering effect
            cols: 10, rows: 10
        };
        const pieceSize = WIDTH / 10;

        function init() {
            uniqueState.currentFramebb = 0;
            uniqueState.pieces = [];

            for (let r = 0; r < uniqueState.rows; r++) {
                for (let c = 0; c < uniqueState.cols; c++) {
                    uniqueState.pieces.push({
                        x: c * pieceSize, y: r * pieceSize,
                        delay: wielsieder() * 30, 
                        // Random velocity for shatter effect
                        vx: (wielsieder() - 0.5) * 10,
                        vy: (wielsieder() - 0.5) * 10,
                        vr: (wielsieder() - 0.5) * 0.5, // Random rotation velocity
                    });
                }
            }
        }

        function animate() {
            // **Description: The source image is perceived as a reflective mirror that shatters into floating pieces. Each piece reflects the *anti-concept* (the new image) on its reverse side as it spins away into a deep void, before the new image snaps into place.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;
            progress = currentFrame / totalFrames;
            const easedProgress = easeInOutQuad(progress);

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            ctx.fillStyle = '#0a0a0a'; // Deep gray void
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            uniqueState.pieces.forEach(p => {
                const time = currentFrame - p.delay;
                if (time < 0) return;

                let pieceProgress = Math.min(1, time / (totalFrames - p.delay));
                const easedPiece = easeInQuad(pieceProgress);
                
                // 1. Position and Rotation
                const cx = p.x + pieceSize / 2;
                const cy = p.y + pieceSize / 2;
                
                const currentX = cx + p.vx * easedPiece * 30; // Shrapnel path
                const currentY = cy + p.vy * easedPiece * 30;
                const currentRot = p.vr * easedPiece * 5;

                // 2. Perspective Flip (Simulated 3D rotation around Y-axis)
                const flipProgress = Math.sin(pieceProgress * Math.PI);
                const scaleX = 1 - flipProgress * 1; 
                
                // 3. Image selection
                const imgToDraw = pieceProgress < 0.5 ? currentImage : nextImage;
                
                ctx.save();
                ctx.translate(currentX, currentY); // Move to new position
                ctx.rotate(currentRot); // Apply rotation
                ctx.scale(scaleX, 1); // Apply perspective flip
                ctx.globalAlpha = 1 - easedPiece; // Fade out as it flies away

                // Draw the image slice, centered
                ctx.drawImage(
                    imgToDraw, 
                    p.x, p.y, pieceSize, pieceSize, // Source
                    -pieceSize / 2, -pieceSize / 2, pieceSize, pieceSize // Destination (centered)
                );
                
                ctx.restore();
            });

            // Final snap into place
            if (progress > 0.8) {
                ctx.globalAlpha = (progress - 0.8) * 5;
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
            }
            ctx.globalAlpha = 1;

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Anti-Concept Mirror Fracture", init: init, animate: animate };
    })();
    
    // --- ANIMATION 29: Inner Identity Fabric Warp (Turbulent Flow) ---
    ANIMATION_LOGIC[24] = (function() {
        const uniqueState = { 
            totalFramesbb: 160,
            currentFramebb: 0,
            imageDataA: null,
            imageDataB: null,
        };

        function init() {
            uniqueState.currentFramebb = 0;
            uniqueState.imageDataA = getPixelData(currentImage);
            uniqueState.imageDataB = getPixelData(nextImage);
        }

        function animate() {
            // **Description: The image plane is subject to extreme, non-linear distortion using Perlin/Noise-like waves, simulating a time-space warp or the collapse of perceived reality. The turbulence peaks at 50% progress, mixing source and destination data chaotically before smoothing out.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;
            progress = currentFrame / totalFrames;
            const easedProgress = easeInOutQuint(progress);

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            const outputImageData = ctx.createImageData(WIDTH, HEIGHT);
            const outputData = outputImageData.data;
            const dataA = uniqueState.imageDataA.data;
            const dataB = uniqueState.imageDataB.data;
            
            // Maximum warp displacement at 50%
            const warpStrength = Math.sin(progress * Math.PI) * 40;

            for (let y = 0; y < HEIGHT; y++) {
                for (let x = 0; x < WIDTH; x++) {
                    const i = (y * WIDTH + x) * 4;

                    // --- 1. Turbulent Displacement Map (Non-linear flow field) ---
                    // This uses complex trigonometric functions to simulate continuous, organic movement
                    const warpX = Math.sin(x * 0.02 + currentFrame * 0.05) * Math.cos(y * 0.03) * warpStrength;
                    const warpY = Math.cos(y * 0.02 - currentFrame * 0.04) * Math.sin(x * 0.03) * warpStrength;
                    
                    // --- 2. Sample from Source Image (A) through the inverse warp ---
                    const sampleX = Math.floor(x - warpX * (1 - easedProgress));
                    const sampleY = Math.floor(y - warpY * (1 - easedProgress));

                    if (sampleX >= 0 && sampleX < WIDTH && sampleY >= 0 && sampleY < HEIGHT) {
                        const iSample = (sampleY * WIDTH + sampleX) * 4;
                        
                        // --- 3. Color Blend (Smooth Identity Change) ---
                        const rA = dataA[iSample]; const gA = dataA[iSample+1]; const bA = dataA[iSample+2];
                        const rB = dataB[i]; const gB = dataB[i+1]; const bB = dataB[i+2];

                        outputData[i] = Math.round(rA + (rB - rA) * easedProgress);
                        outputData[i + 1] = Math.round(gA + (gB - gA) * easedProgress);
                        outputData[i + 2] = Math.round(bA + (bB - bA) * easedProgress);
                        outputData[i + 3] = 255; 
                    }
                }
            }

            ctx.putImageData(outputImageData, 0, 0);

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Inner Identity Fabric Warp", init: init, animate: animate };
    })();
    
    // --- ANIMATION 30: The Shimmer of Unimaginable Beyond (Chroma Bloom) ---
    ANIMATION_LOGIC[23] = (function() {
        const uniqueState = { 
            totalFramesbb: 120,
            currentFramebb: 0,
            imageDataB: null,
            maxBloom: 100 // Maximum pixel displacement distance
        };

        function init() {
            uniqueState.currentFramebb = 0;
            uniqueState.imageDataB = getPixelData(nextImage);
        }

        function animate() {
            // **Description: The source image rapidly over-saturates and 'blooms' into a blinding white light, which then slowly recedes, revealing the destination image from its core. The pixels of the destination image are individually randomized in color/position during the peak bloom phase.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;
            progress = currentFrame / totalFrames;
            const easedProgress = easeInOutQuint(progress);

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            
            // --- 1. Source Image Bloom (Fades and Blurs to White) ---
            ctx.globalAlpha = 1 - easedProgress;
            
            // Draw original image with a blur filter (simulating bloom)
            ctx.filter = `blur(${easedProgress * 20}px)`;
            ctx.drawImage(currentImage, 0, 0, WIDTH, HEIGHT);
            ctx.filter = 'none';

            // Overlay with a white flash
            ctx.globalAlpha = Math.sin(progress * Math.PI) * 0.8; // Max brightness at 50%
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            
            // --- 2. Destination Image Emergence (Shimmer) ---
            ctx.globalAlpha = easedProgress;
            
            const outputImageData = ctx.createImageData(WIDTH, HEIGHT);
            const outputData = outputImageData.data;
            const dataB = uniqueState.imageDataB.data;
            
            // Shimmer strength peaks at 50%
            const shimmerStrength = Math.sin(progress * Math.PI) * 0.5; 

            for (let y = 0; y < HEIGHT; y++) {
                for (let x = 0; x < WIDTH; x++) {
                    const i = (y * WIDTH + x) * 4;

                    // Sample offset (creates a chaotic shimmer)
                    const offsetX = Math.floor(Math.sin(x * 0.1) * shimmerStrength * 5);
                    const offsetY = Math.floor(Math.cos(y * 0.1) * shimmerStrength * 5);
                    
                    const sampleX = Math.min(WIDTH - 1, Math.max(0, x + offsetX));
                    const sampleY = Math.min(HEIGHT - 1, Math.max(0, y + offsetY));

                    const iSample = (sampleY * WIDTH + sampleX) * 4;

                    outputData[i] = dataB[iSample];
                    outputData[i + 1] = dataB[iSample + 1];
                    outputData[i + 2] = dataB[iSample + 2];
                    outputData[i + 3] = 255; 
                }
            }

            ctx.putImageData(outputImageData, 0, 0);

            // Reset global alpha
            ctx.globalAlpha = 1;

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Shimmer of Unimaginable Beyond", init: init, animate: animate };
    })();

    // --- ANIMATION 31: Belief Quantum Entanglement (Inverse Swirl) ---
    ANIMATION_LOGIC[22] = (function() {
        const uniqueState = { 
            totalFramesbb: 140,
            currentFramebb: 0,
            imageDataA: null,
            imageDataB: null,
            midX: WIDTH / 2,
            midY: HEIGHT / 2
        };

        function init() {
            uniqueState.currentFramebb = 0;
            uniqueState.imageDataA = getPixelData(currentImage);
            uniqueState.imageDataB = getPixelData(nextImage);
        }

        function animate() {
            // **Description: Pixels are entangled, meaning they follow an inverse path: source pixels swirl *out* from the center while destination pixels swirl *in* to the center. The rotation speed is proportional to the distance from the center, resulting in a dramatic, twisting dissolution and formation.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;
            progress = currentFrame / totalFrames;
            const easedProgress = easeInOutQuint(progress);

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            const outputImageData = ctx.createImageData(WIDTH, HEIGHT);
            const outputData = outputImageData.data;
            const dataA = uniqueState.imageDataA.data;
            const dataB = uniqueState.imageDataB.data;

            // Max swirl angle
            const maxAngle = Math.PI * 4; 

            for (let y = 0; y < HEIGHT; y++) {
                for (let x = 0; x < WIDTH; x++) {
                    const i = (y * WIDTH + x) * 4;

                    const dx = x - uniqueState.midX;
                    const dy = y - uniqueState.midY;
                    const r = Math.sqrt(dx * dx + dy * dy);
                    const initialAngle = Math.atan2(dy, dx);
                    
                    // --- 1. Rotation Angle (Proportional to Distance) ---
                    const rotationFactor = r / (WIDTH / 2);
                    const totalRotation = rotationFactor * maxAngle * easedProgress;

                    // --- 2. Source (A) Sample Position: Swirls OUT ---
                    const angleA = initialAngle + totalRotation;
                    const distA = r * (1 + easedProgress * 0.5); // Moves outward
                    
                    const sampleXA = Math.floor(uniqueState.midX + distA * Math.cos(angleA));
                    const sampleYA = Math.floor(uniqueState.midY + distA * Math.sin(angleA));

                    // --- 3. Destination (B) Sample Position: Swirls IN ---
                    const angleB = initialAngle - totalRotation; // Inverse swirl
                    const distB = r * (1 - easedProgress * 0.5); // Moves inward

                    const sampleXB = Math.floor(uniqueState.midX + distB * Math.cos(angleB));
                    const sampleYB = Math.floor(uniqueState.midY + distB * Math.sin(angleB));

                    // --- 4. Draw Logic (Blend the Swirls) ---
                    const alphaA = 1 - easedProgress;
                    const alphaB = easedProgress;
                    
                    // Sample color from A and B based on their respective swirl positions
                    let rA=0, gA=0, bA=0, rB=0, gB=0, bB=0;
                    
                    // Get color A
                    if (sampleXA >= 0 && sampleXA < WIDTH && sampleYA >= 0 && sampleYA < HEIGHT) {
                        const iA = (sampleYA * WIDTH + sampleXA) * 4;
                        rA = dataA[iA]; gA = dataA[iA+1]; bA = dataA[iA+2];
                    }

                    // Get color B
                    if (sampleXB >= 0 && sampleXB < WIDTH && sampleYB >= 0 && sampleYB < HEIGHT) {
                        const iB = (sampleYB * WIDTH + sampleXB) * 4;
                        rB = dataB[iB]; gB = dataB[iB+1]; bB = dataB[iB+2];
                    }

                    // Final color is a mix of the two swirls
                    outputData[i] = Math.round(rA * alphaA + rB * alphaB);
                    outputData[i + 1] = Math.round(gA * alphaA + gB * alphaB);
                    outputData[i + 2] = Math.round(bA * alphaA + bB * alphaB);
                    outputData[i + 3] = 255; 
                }
            }

            ctx.putImageData(outputImageData, 0, 0);

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Belief Quantum Entanglement", init: init, animate: animate };
    })();

















    // ====================================================================
    // --- FIVE NEW, TRANSCENDENCE ANIMATIONS START HERE (Indices 22-26) ---
    // ====================================================================

    // --- ANIMATION 22: Transcendence of the Void (Emergence from Luminosity) ---
    ANIMATION_LOGIC[21] = (function() {
        const uniqueState = { 
            totalFramesbb: 160,
            currentFramebb: 0,
            pixels: [], // Stores initial luminosity data
        };

        function init() {
            uniqueState.currentFramebb = 0;
            uniqueState.pixels = [];
            const imageDataA = getPixelData(currentImage);
            const dataA = imageDataA.data;
            const size = 10; // Block size for pixel clusters

            for (let y = 0; y < HEIGHT; y += size) {
                for (let x = 0; x < WIDTH; x += size) {
                    const i = (y * WIDTH + x) * 4;
                    // Calculate relative luminosity (human perception)
                    const lum = (dataA[i] * 0.2126 + dataA[i + 1] * 0.7152 + dataA[i + 2] * 0.0722) / 255;
                    
                    uniqueState.pixels.push({
                        x: x, y: y, 
                        lum: lum,
                        delay: (1 - lum) * 80 * wielsieder(), // Brighter areas dissolve/emerge faster
                    });
                }
            }
        }

        function animate() {
            // **Description: The source image dissolves into a black Void. The destination image then emerges, pulled outward by an 'Anti-Gravity' field whose strength is inversely proportional to the original image's luminosity, creating a visually complex, structured emergence.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;
            progress = currentFrame / totalFrames;

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            
            // Draw Source Image (A) -> Dissolves
            ctx.globalAlpha = 1 - easeOutQuad(progress * 2); // Quick fade out

            if (progress < 0.5) {
                ctx.drawImage(currentImage, 0, 0, WIDTH, HEIGHT);
            }
            ctx.globalAlpha = 1;

            // Draw Destination Image (B) -> Emerges
            ctx.globalAlpha = easeOutQuad(progress * 2 - 1); // Delay until 50% progress

            if (progress > 0.5) {
                uniqueState.pixels.forEach(p => {
                    const time = currentFrame - p.delay;
                    if (time < 0) return;

                    let emergenceProgress = Math.min(1, time / (totalFrames - p.delay));
                    const easedEmergence = easeInOutQuint(emergenceProgress);
                    
                    // The 'pull' distance is based on original luminosity
                    const pullDistance = (1 - p.lum) * 200;
                    
                    // Project the block outward from the center
                    const dx = p.x - WIDTH / 2;
                    const dy = p.y - HEIGHT / 2;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx);
                    
                    // The block moves in reverse from a chaotic outer space, towards its final position
                    const finalX = p.x - Math.cos(angle) * pullDistance * (1 - easedEmergence);
                    const finalY = p.y - Math.sin(angle) * pullDistance * (1 - easedEmergence);

                    ctx.drawImage(nextImage, p.x, p.y, 10, 10, finalX, finalY, 10, 10);
                });
            }
            ctx.globalAlpha = 1;

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Transcendence of the Void", init: init, animate: animate };
    })();

    // --- ANIMATION 23: Dialectical Field Fluctuation (Anti-Concept Vibration) ---
    ANIMATION_LOGIC[20] = (function() {
        const uniqueState = { 
            totalFramesbb: 100,
            currentFramebb: 0,
            blocks: [], // Array of block states
            blockSize: 20
        };

        function init() {
            uniqueState.currentFramebb = 0;
            uniqueState.blocks = [];
            const imageDataA = getPixelData(currentImage);
            const imageDataB = getPixelData(nextImage);

            for (let y = 0; y < HEIGHT; y += uniqueState.blockSize) {
                for (let x = 0; x < WIDTH; x += uniqueState.blockSize) {
                    const i = (y * WIDTH + x) * 4;
                    uniqueState.blocks.push({
                        x: x, y: y,
                        delay: wielsieder() * 30,
                        c1: [imageDataA.data[i], imageDataA.data[i+1], imageDataA.data[i+2]],
                        c2: [imageDataB.data[i], imageDataB.data[i+1], imageDataB.data[i+2]],
                        ox: 0, oy: 0, // Current chaotic offset
                    });
                }
            }
        }

        function animate() {
            // **Description: The image becomes a fluctuating field where each block is torn between the source (Repulsion) and destination (Attraction) colors. It vibrates chaotically at the 50% mark (the moment of 'anti-concept' equilibrium) before snapping into the new state.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;
            
            ctx.clearRect(0, 0, WIDTH, HEIGHT);

            uniqueState.blocks.forEach(block => {
                const time = currentFrame - block.delay;
                if (time < 0) return;

                let progress = Math.min(1, time / (totalFrames - block.delay));
                const easedProgress = easeInOutQuint(progress);

                // --- 1. Vibration Field (Anti-Concept Clash) ---
                const clashStrength = Math.sin(progress * Math.PI) * 15; // Max displacement at 0.5
                block.ox = Math.sin(currentFrame * 0.8 + block.x) * clashStrength;
                block.oy = Math.cos(currentFrame * 0.9 + block.y) * clashStrength;

                // --- 2. Color Dialectic (Blend) ---
                const r = Math.round(block.c1[0] + (block.c2[0] - block.c1[0]) * easedProgress);
                const g = Math.round(block.c1[1] + (block.c2[1] - block.c1[1]) * easedProgress);
                const b = Math.round(block.c1[2] + (block.c2[2] - block.c1[2]) * easedProgress);

                // --- 3. Draw Block with Offset ---
                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                ctx.fillRect(
                    block.x + block.ox, 
                    block.y + block.oy, 
                    uniqueState.blockSize, 
                    uniqueState.blockSize
                );
            });

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Dialectical Field Fluctuation", init: init, animate: animate };
    })();

    // --- ANIMATION 24: Identity Weave Collapse (Strand Unraveling) ---
    ANIMATION_LOGIC[19] = (function() {
        const uniqueState = { 
            totalFramesbb: 140,
            currentFramebb: 0,
            strands: [],
            numStrands: 3000
        };

        function init() {
            uniqueState.currentFramebb = 0;
            uniqueState.strands = [];
            const imageDataA = getPixelData(currentImage);
            const imageDataB = getPixelData(nextImage);

            for (let i = 0; i < uniqueState.numStrands; i++) {
                const x = Math.floor(wielsieder() * WIDTH);
                const y = Math.floor(wielsieder() * HEIGHT);
                const iA = (y * WIDTH + x) * 4;

                uniqueState.strands.push({
                    x: x, y: y, 
                    delay: wielsieder() * 50,
                    // Get two points slightly offset from the main point
                    x1: x + (wielsieder() - 0.5) * 5, y1: y + (wielsieder() - 0.5) * 5,
                    x2: x + (wielsieder() - 0.5) * 5, y2: y + (wielsieder() - 0.5) * 5,
                    c1: [imageDataA.data[iA], imageDataA.data[iA+1], imageDataA.data[iA+2]],
                    c2: [imageDataB.data[iA], imageDataB.data[iA+1], imageDataB.data[iA+2]],
                });
            }
        }

        function animate() {
            // **Description: The image fabric unravels into thousands of colored strands. The old strands dissipate while new strands simultaneously weave themselves into the destination image's position, creating a brief moment of complete structural collapse.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            uniqueState.strands.forEach(s => {
                const time = currentFrame - s.delay;
                if (time < 0) return;

                let progress = Math.min(1, time / (totalFrames - s.delay));
                const easedProgress = easeInOutQuint(progress);

                // Fade out source color (Unraveling)
                const alpha1 = 1 - easedProgress;
                // Fade in destination color (Re-weaving)
                const alpha2 = easedProgress;

                // --- 1. Unraveling Motion ---
                const ravelDist = 150 * easedProgress; // Max distance strands are thrown
                const currentX1 = s.x1 + (s.x1 - s.x) * ravelDist;
                const currentY1 = s.y1 + (s.y1 - s.y) * ravelDist;

                // --- 2. Re-weaving Motion ---
                const currentX2 = s.x;
                const currentY2 = s.y;

                // Draw Raveling Strand (Image A)
                ctx.globalAlpha = alpha1 * 0.8;
                ctx.strokeStyle = `rgb(${s.c1[0]}, ${s.c1[1]}, ${s.c1[2]})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(s.x, s.y);
                ctx.lineTo(currentX1, currentY1);
                ctx.stroke();

                // Draw Weaving Strand (Image B)
                ctx.globalAlpha = alpha2 * 0.8;
                ctx.strokeStyle = `rgb(${s.c2[0]}, ${s.c2[1]}, ${s.c2[2]})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(currentX2, currentY2);
                ctx.lineTo(s.x2 + (s.x2 - s.x) * (1 - easedProgress) * 5, s.y2 + (s.y2 - s.y) * (1 - easedProgress) * 5);
                ctx.stroke();
            });
            ctx.globalAlpha = 1;

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Identity Weave Collapse", init: init, animate: animate };
    })();

    // --- ANIMATION 25: Temporal Layered Rotation (Dimensional Flip) ---
    ANIMATION_LOGIC[18] = (function() {
        const uniqueState = { 
            totalFramesbb: 120,
            currentFramebb: 0,
            layers: 20 // Number of layers to simulate depth
        };

        function init() {
            uniqueState.currentFramebb = 0;
            // No pixel data manipulation needed, relies on transformation matrix
        }

        function animate() {
            // **Description: The image slices into many transparent layers that rotate at different speeds around a central axis (simulating a dimensional flip). The source image rotates away into the background while the new image rotates forward from the foreground.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;
            progress = currentFrame / totalFrames;
            const easedProgress = easeInOutQuint(progress);

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            ctx.save();
            ctx.translate(WIDTH / 2, HEIGHT / 2); // Move origin to center

            for (let i = 0; i < uniqueState.layers; i++) {
                const layerProgress = (i / uniqueState.layers);
                const layerDepth = i * 2; // Z-depth offset
                
                // Rotation Angle: Flips from 0 to 180 degrees (PI radians)
                const totalRotation = Math.PI * easedProgress;
                
                // Differential Rotation: Layers rotate at slightly different speeds/phases for a 3D effect
                const rotation = totalRotation + layerProgress * Math.PI * 0.1;

                // --- Draw Source Image (Rotates Out) ---
                ctx.save();
                ctx.rotate(rotation);
                ctx.globalAlpha = 1 - easedProgress; // Fades out
                ctx.drawImage(currentImage, -WIDTH / 2, -HEIGHT / 2, WIDTH, HEIGHT);
                ctx.restore();

                // --- Draw Destination Image (Rotates In) ---
                ctx.save();
                ctx.rotate(rotation - Math.PI); // Starts 180 degrees opposite
                ctx.globalAlpha = easedProgress; // Fades in
                ctx.drawImage(nextImage, -WIDTH / 2, -HEIGHT / 2, WIDTH, HEIGHT);
                ctx.restore();
            }

            ctx.restore(); // Restore origin

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Temporal Layered Rotation", init: init, animate: animate };
    })();

    // --- ANIMATION 26: Non-Euclidean Memory Trace (Swarm & Reform) ---
    ANIMATION_LOGIC[17] = (function() {
        const uniqueState = { 
            totalFramesbb: 180,
            currentFramebb: 0,
            imageDataA: null,
            imageDataB: null,
        };

        function init() {
            uniqueState.currentFramebb = 0;
            uniqueState.imageDataA = getPixelData(currentImage);
            uniqueState.imageDataB = getPixelData(nextImage);
        }

        function animate() {
            // **Description: Pixels are displaced by a complex, time-based field (Non-Euclidean mapping), causing them to swarm chaotically along curved paths before rapidly reforming into the new image, leaving a shimmering 'memory trace' of the transition.**
            const currentFrame = uniqueState.currentFramebb;
            const totalFrames = uniqueState.totalFramesbb;
            progress = currentFrame / totalFrames;
            const easedProgress = easeInOutQuint(progress);

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            const outputImageData = ctx.createImageData(WIDTH, HEIGHT);
            const outputData = outputImageData.data;
            const dataA = uniqueState.imageDataA.data;
            const dataB = uniqueState.imageDataB.data;
            
            // Maximum Swarm displacement at 50%
            const swarmStrength = Math.sin(progress * Math.PI) * 100;

            for (let y = 0; y < HEIGHT; y++) {
                for (let x = 0; x < WIDTH; x++) {
                    const i = (y * WIDTH + x) * 4;

                    // --- 1. Complex Displacement Map (Simulated Non-Euclidean Path) ---
                    // Use trigonometric functions influenced by time and position
                    const dx = Math.sin(x * 0.05 + currentFrame * 0.05) * Math.cos(y * 0.03) * swarmStrength;
                    const dy = Math.cos(y * 0.05 + currentFrame * 0.06) * Math.sin(x * 0.03) * swarmStrength;
                    
                    // --- 2. Target Position (moves from A's position to B's position) ---
                    const targetX = x + dx * (1 - easedProgress);
                    const targetY = y + dy * (1 - easedProgress);

                    // --- 3. Source Image Sampling (Inverse Mapping) ---
                    // We sample the OLD image (A) at a position that maps to the new target
                    const oldX = Math.floor(x - dx * (1 - easedProgress));
                    const oldY = Math.floor(y - dy * (1 - easedProgress));

                    if (oldX >= 0 && oldX < WIDTH && oldY >= 0 && oldY < HEIGHT) {
                        const iOld = (oldY * WIDTH + oldX) * 4;
                        
                        // --- 4. Color Blend ---
                        const rA = dataA[iOld]; const gA = dataA[iOld+1]; const bA = dataA[iOld+2];
                        const rB = dataB[i]; const gB = dataB[i+1]; const bB = dataB[i+2];

                        // Blend color based on progress
                        outputData[i] = Math.round(rA + (rB - rA) * easedProgress);
                        outputData[i + 1] = Math.round(gA + (gB - gA) * easedProgress);
                        outputData[i + 2] = Math.round(bA + (bB - bA) * easedProgress);
                        outputData[i + 3] = 255; 
                    }
                }
            }

            ctx.putImageData(outputImageData, 0, 0);

            if (currentFrame < totalFrames) {
                uniqueState.currentFramebb++;
                requestAnimationFrame(animate);
            } else {
                ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT);
                startNextTransition();
            }
        }

        return { title: "Non-Euclidean Memory Trace", init: init, animate: animate };
    })();

// --- ANIMATION 68: Lorenz Attractor Pixel Sort (Performance Optimized) ---
ANIMATION_LOGIC[68] = (function() {
    const uniqueState = { totalFrames: 200, currentFrame: 0, pixelMap: [] };
    const SIGMA = 10, RHO = 28, BETA = 8/3, DT = 0.005;
    const MAX_ITERATIONS = 40000;

    function init() {
        uniqueState.currentFrame = 0;
        // Pre-calculate the chaotic path once (Performance Boost)
        let x=1, y=1, z=1; 
        uniqueState.pixelMap = [];

        for (let t = 0; t < MAX_ITERATIONS && uniqueState.pixelMap.length < WIDTH * HEIGHT; t++) {
            const next = lorenzMap(x, y, z, SIGMA, RHO, BETA, DT);
            x = next.x; y = next.y; z = next.z;
            
            // Map the chaotic state to 2D screen coordinates
            const mappedX = Math.floor((x * 10 + 200) % WIDTH); 
            const mappedY = Math.floor((y * 10 + 200) % HEIGHT); 
            
            uniqueState.pixelMap.push({ x: mappedX, y: mappedY });
        }
    }

    function animate() {
        const progress = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedProgress = easeInOutQuartic(progress);

        ctx.clearRect(0, 0, WIDTH, HEIGHT);
        ctx.drawImage(currentImage, 0, 0, WIDTH, HEIGHT); // Draw A as base
        
        const outputImageData = ctx.createImageData(WIDTH, HEIGHT); // FIX
        const outputData = outputImageData.data; // FIX
        const dataB = getPixelData(nextImage).data;

        // Warping Image A (Optional: use ctx draw for warp effect)
        ctx.save();
        ctx.translate(WIDTH / 2, HEIGHT / 2);
        ctx.rotate(progress * Math.PI / 8);
        ctx.globalAlpha = 1 - easedProgress;
        ctx.drawImage(currentImage, -WIDTH / 2, -HEIGHT / 2, WIDTH, HEIGHT);
        ctx.restore();
        
        const pixelsToDraw = Math.floor(easedProgress * uniqueState.pixelMap.length);
        
        // Only draw Image B pixels along the path onto the scratchpad
        for (let k = 0; k < pixelsToDraw; k++) {
            const map = uniqueState.pixelMap[k];
            const px = map.x;
            const py = map.y;
            
            const i = (py * WIDTH + px) * 4;

            if (i < outputData.length) {
                outputData[i] = dataB[i]; outputData[i + 1] = dataB[i + 1]; outputData[i + 2] = dataB[i + 2];
                outputData[i + 3] = 255;
            }
        }
        
        ctx.globalAlpha = 1;
        ctx.putImageData(outputImageData, 0, 0); // Overlay the chaotic pixels (FIX)

        if (uniqueState.currentFrame++ < uniqueState.totalFrames) requestAnimationFrame(animate);
        else transitionEnd(nextImage);
    }
    return { title: "Lorenz Attractor Pixel Sort", init: init, animate: animate };
})();

// --- ANIMATION 69: Mandelbrot Boundary Trace ---
ANIMATION_LOGIC[69] = (function() {
    const uniqueState = { totalFrames: 180, currentFrame: 0, MAX_ITER: 50 };
    const RENDER_STEP = 2; // Pixel stepping for speed

    function init() { uniqueState.currentFrame = 0; }

    function animate() {
        const progress = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedProgress = easeInOutQuint(progress);

        const outputImageData = ctx.createImageData(WIDTH, HEIGHT); // FIX
        const outputData = outputImageData.data; // FIX
        const dataA = getPixelData(currentImage).data;
        const dataB = getPixelData(nextImage).data;

        // PARAMETER: Dynamic Zoom/pan
        const zoom = 1 + easedProgress * 15; 
        const center_x = -0.5 + Math.cos(progress * Math.PI * 2) * 0.1;
        const center_y = Math.sin(progress * Math.PI * 2) * 0.1;
        
        const R_MIN = center_x - 1.5 / zoom;
        const I_MAX = center_y + 1.5 / zoom;
        const R_RANGE = (1.5 / zoom) * 2;
        const I_RANGE = R_RANGE * (HEIGHT / WIDTH);

        for (let y = 0; y < HEIGHT; y += RENDER_STEP) {
            for (let x = 0; x < WIDTH; x += RENDER_STEP) {
                const i = (y * WIDTH + x) * 4;

                let cr = R_MIN + x / WIDTH * R_RANGE;
                let ci = I_MAX - y / HEIGHT * I_RANGE;

                let zr = 0, zi = 0;
                let iter = 0;
                while (zr*zr + zi*zi < 4 && iter < uniqueState.MAX_ITER) {
                    let temp_zr = zr*zr - zi*zi + cr;
                    zi = 2*zr*zi + ci;
                    zr = temp_zr;
                    iter++;
                }
                
                const rA = dataA[i], gA = dataA[i+1], bA = dataA[i+2];
                const rB = dataB[i], gB = dataB[i+1], bB = dataB[i+2];

                let r, g, b;
                if (iter < uniqueState.MAX_ITER) {
                    // OUTSIDE: Blend towards B based on fractal color
                    const iter_factor = iter / uniqueState.MAX_ITER;
                    r = rB * (1 - iter_factor) + rA * iter_factor;
                    g = gB * (1 - iter_factor) + gA * iter_factor;
                    b = bB * (1 - iter_factor) + bA * iter_factor;
                } else {
                    // INSIDE: Remains A
                    r = rA; g = gA; b = bA;
                }

                // Apply to the block
                for(let dy=0; dy<RENDER_STEP; dy++) {
                    for(let dx=0; dx<RENDER_STEP; dx++) {
                        const cellI = ((y + dy) * WIDTH + (x + dx)) * 4;
                        if(cellI < outputData.length) {
                             outputData[cellI] = Math.round(r); outputData[cellI + 1] = Math.round(g); 
                             outputData[cellI + 2] = Math.round(b); outputData[cellI + 3] = 255;
                        }
                    }
                }
            }
        }
        
        ctx.putImageData(outputImageData, 0, 0); // FIX

        if (uniqueState.currentFrame++ < uniqueState.totalFrames) requestAnimationFrame(animate);
        else transitionEnd(nextImage);
    }
    return { title: "Mandelbrot Boundary Trace", init: init, animate: animate };
})();

// --- ANIMATION 70: Voronoi Stipple & Collapse (Optimized) ---
ANIMATION_LOGIC[70] = (function() {
    const uniqueState = { totalFrames: 140, currentFrame: 0, points: [] };
    const NUM_POINTS = 500; 

    function init() {
        uniqueState.currentFrame = 0;
        uniqueState.points = [];
        const dataA = getPixelData(currentImage).data;
        const dataB = getPixelData(nextImage).data;

        for (let i = 0; i < NUM_POINTS; i++) {
            const x = Math.floor(wielsieder() * WIDTH);
            const y = Math.floor(wielsieder() * HEIGHT);
            const i4 = (y * WIDTH + x) * 4;
            
            uniqueState.points.push({
                x: x, y: y,
                delay: wielsieder() * 40,
                colorA: { r: dataA[i4], g: dataA[i4 + 1], b: dataA[i4 + 2] },
                colorB: { r: dataB[i4], g: dataB[i4 + 1], b: dataB[i4 + 2] }
            });
        }
    }

    function animate() {
        const totalFrames = uniqueState.totalFrames;
        
        ctx.clearRect(0, 0, WIDTH, HEIGHT);
        
        uniqueState.points.forEach(point => {
            const time = uniqueState.currentFrame - point.delay;
            
            if (time >= 0) {
                const pointProgress = Math.min(1, time / (totalFrames - 40));
                const p = easeInOutQuartic(pointProgress);
                
                // Condensation factor: 1 at 0% and 100%, 0 at 50%
                const condenseFactor = Math.abs(p - 0.5) * 2; 

                // Size of the simulated region
                const size = 15 * condenseFactor * (1 - p); // Shrink factor
                
                let r, g, b;
                if (p < 0.5) {
                    // Shrinking A
                    r = point.colorA.r; g = point.colorA.g; b = point.colorA.b;
                } else {
                    // Expanding B
                    r = point.colorB.r; g = point.colorB.g; b = point.colorB.b;
                }

                ctx.fillStyle = `rgb(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)})`;
                ctx.beginPath();
                ctx.arc(point.x, point.y, size * (p < 0.5 ? 1 : 1.5), 0, Math.PI * 2);
                ctx.fill();
            }
        });

        if (uniqueState.currentFrame++ < uniqueState.totalFrames) requestAnimationFrame(animate);
        else transitionEnd(nextImage);
    }
    return { title: "Voronoi Stipple & Collapse", init: init, animate: animate };
})();







// --- ANIMATION 79: Iterated Function System (IFS) Blend (Pre-calculated Map) ---
ANIMATION_LOGIC[79] = (function() {
    // Assuming WIDTH and HEIGHT are global and available
    const uniqueState = { 
        totalFrames: 150, 
        currentFrame: 0, 
        ifsMap: [],
        imageDataA: null // Store image data for A once
    };

    function init() {
        uniqueState.currentFrame = 0;
        uniqueState.ifsMap = [];
        // Pre-calculate data for Image A once
        uniqueState.imageDataA = getPixelData(currentImage);

        const numSamples = WIDTH * HEIGHT;
        
        // Rules for Barnsley Fern-like map
        // ... (Rules remain the same)
        const rules = [
            { a: 0.85, b: 0.04, c: -0.04, d: 0.85, e: 0, f: 1.6, weight: 0.85 }, // Stem
            { a: 0.20, b: -0.26, c: 0.23, d: 0.22, e: 0, f: 1.6, weight: 0.07 }, // Small Leaf
            { a: -0.15, b: 0.28, c: 0.26, d: 0.24, e: 0, f: 0.44, weight: 0.07 }, // Small Leaf
            { a: 0.00, b: 0.00, c: 0.00, d: 0.16, e: 0, f: 0.00, weight: 0.01 }, // Base
        ];
        
        // Use a proper weighted random selection if possible (though the current approach is faster)
        // Since you're using wielsieder() * rules.length, I'll stick to that fast (but non-weighted) rule selection.

        let x = 0, y = 0; 
        for(let k = 0; k < numSamples * 0.5; k++) { // Only map half the pixels for speed
             // This assumes a global 'wielsieder' random function exists
             const rule = rules[Math.floor(wielsieder() * rules.length)]; 
             const next_x = rule.a * x + rule.b * y + rule.e;
             const next_y = rule.c * x + rule.d * y + rule.f;
             x = next_x; y = next_y;
             
             // The 10 / 10 scale seems arbitrary, but I'll keep the logic
             const mapX = Math.round(x * WIDTH / 10 + WIDTH/2);
             const mapY = Math.round(y * HEIGHT / 10 + HEIGHT/2);
             
             // Only store valid map coordinates
             if (mapX >= 0 && mapX < WIDTH && mapY >= 0 && mapY < HEIGHT) {
                 // Store the *source* pixel index (k) and the *initial target* IFS position (mapX, mapY)
                 uniqueState.ifsMap.push({ srcK: k, mapX: mapX, mapY: mapY });
             }
        }
        console.log(`IFS Map generated with ${uniqueState.ifsMap.length} points.`);
    }

    function animate() {
        const progress = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedProgress = easeInOutQuint(progress);

        // 1. Draw Image B (nextImage) as the base background
        ctx.clearRect(0, 0, WIDTH, HEIGHT);
        ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT); 

        // 2. Prepare new image data object for the 'warped A' layer
        // We reuse the imageDataA object to get a blank one of the correct size
        const warpedImageData = ctx.createImageData(WIDTH, HEIGHT);
        const warpedData = warpedImageData.data;
        
        const dataA = uniqueState.imageDataA.data;
        const numToDraw = uniqueState.ifsMap.length;
        
        // Calculate the blending alpha outside the loop
        const alpha = Math.max(0, 1 - easedProgress); 

        // --- FAST Pixel Manipulation (using ImageData) ---
        for (let idx = 0; idx < numToDraw; idx++) {
            const map = uniqueState.ifsMap[idx];
            
            // a) Source from Image A: The original index was 'k' (now map.srcK)
            // The pixel index in dataA is calculated from map.srcK, not idx
            const i = (map.srcK * 4); 
            
            if (i + 3 >= dataA.length) continue; // Safety check

            // b) Final Destination (Target B): The original logic used targetX/Y 
            // based on the loop index (k), which is now idx.
            const targetX = (idx % WIDTH); 
            const targetY = Math.floor(idx / WIDTH);

            // c) Interpolate position: This determines where the pixel *from* Image A *goes*
            const drawX = Math.round(map.mapX + (targetX - map.mapX) * easedProgress);
            const drawY = Math.round(map.mapY + (targetY - map.mapY) * easedProgress);

            // d) Write to warpedImageData: Only write if the target position is within bounds
            if (drawX >= 0 && drawX < WIDTH && drawY >= 0 && drawY < HEIGHT) {
                const targetPixelIndex = (drawY * WIDTH + drawX) * 4;
                
                // Read RGB from source A
                const r = dataA[i];
                const g = dataA[i+1];
                const b = dataA[i+2];

                // Write RGB and the calculated Alpha to the warped image data
                // Note: This overwrites any previous pixel written to this location.
                warpedData[targetPixelIndex] = r;
                warpedData[targetPixelIndex + 1] = g;
                warpedData[targetPixelIndex + 2] = b;
                warpedData[targetPixelIndex + 3] = 255 * alpha; // Set Alpha based on blend
            }
        }
        
        // 3. Draw the combined pixel data onto the canvas in a single, fast operation
        ctx.putImageData(warpedImageData, 0, 0);

        if (uniqueState.currentFrame++ < uniqueState.totalFrames) requestAnimationFrame(animate);
        else transitionEnd(nextImage);
    }
    return { title: "IFS Fractal Collapse", init: init, animate: animate };
})();

// --- ANIMATION 80: Statistical Moment Shift (Block-based, Pre-calculated) ---
ANIMATION_LOGIC[80] = (function() {
    const uniqueState = { totalFrames: 120, currentFrame: 0, blocks: [] };
    const BLOCK_SIZE = 10; 

    function init() {
        uniqueState.currentFrame = 0;
        uniqueState.blocks = [];
        const dataA = getPixelData(currentImage).data;

        for (let y = 0; y < HEIGHT; y += BLOCK_SIZE) {
            for (let x = 0; x < WIDTH; x += BLOCK_SIZE) {
                // Calculate Mean Luminance (1st moment)
                let sumL = 0;
                for (let dy = 0; dy < BLOCK_SIZE; dy++) {
                    for (let dx = 0; dx < BLOCK_SIZE; dx++) {
                        const i = ((y + dy) * WIDTH + (x + dx)) * 4;
                        if(i < dataA.length) sumL += (dataA[i] * 0.21 + dataA[i+1] * 0.72 + dataA[i+2] * 0.07);
                    }
                }
                const meanL = sumL / (BLOCK_SIZE * BLOCK_SIZE);
                
                uniqueState.blocks.push({
                    x: x, y: y,
                    // Darker blocks (low meanL) transition first (low delay)
                    delay: (255 - meanL) / 255 * 50 
                });
            }
        }
    }

    function animate() {
        const totalFrames = uniqueState.totalFrames;

        const outputImageData = ctx.createImageData(WIDTH, HEIGHT); // FIX
        const outputData = outputImageData.data; // FIX
        const dataA = getPixelData(currentImage).data;
        const dataB = getPixelData(nextImage).data;

        uniqueState.blocks.forEach(block => {
            const time = uniqueState.currentFrame - block.delay;
            
            const blockProgress = Math.min(1, Math.max(0, time / (totalFrames - 50))); 
            const easedProgress = easeInOutQuartic(blockProgress);

            for (let dy = 0; dy < BLOCK_SIZE; dy++) {
                for (let dx = 0; dx < BLOCK_SIZE; dx++) {
                    const x = block.x + dx;
                    const y = block.y + dy;
                    const i = (y * WIDTH + x) * 4;
                    
                    if(i < outputData.length) {
                        const r = dataA[i] + (dataB[i] - dataA[i]) * easedProgress;
                        const g = dataA[i + 1] + (dataB[i + 1] - dataA[i + 1]) * easedProgress;
                        const b = dataA[i + 2] + (dataB[i + 2] - dataA[i + 2]) * easedProgress;
                        
                        outputData[i] = Math.round(r); outputData[i + 1] = Math.round(g); 
                        outputData[i + 2] = Math.round(b); outputData[i + 3] = 255;
                    }
                }
            }
        });

        ctx.putImageData(outputImageData, 0, 0); // FIX

        if (uniqueState.currentFrame++ < uniqueState.totalFrames) requestAnimationFrame(animate);
        else transitionEnd(nextImage);
    }
    return { title: "Statistical Moment Shift", init: init, animate: animate };
})();

// --- ANIMATION 81: 3D Plane Slice and Rotate (Performance Optimized) ---
ANIMATION_LOGIC[81] = (function() {
    const uniqueState = { totalFrames: 140, currentFrame: 0 };
    const ANGLE_X = Math.PI / 6, ANGLE_Y = Math.PI / 4;
    const RENDER_STEP = 5; // Large step for speed

    function init() { uniqueState.currentFrame = 0; }
    
    // 3D projection helper
    function project3D(x, y, z, rotX, rotY, scale) {
        let tempY = y * Math.cos(rotX) - z * Math.sin(rotX);
        let tempZ = y * Math.sin(rotX) + z * Math.cos(rotX);
        let finalX = x * Math.cos(rotY) + tempZ * Math.sin(rotY);
        let finalZ = tempZ * Math.cos(rotY) - x * Math.sin(rotY);
        
        const perspective = 200 / (200 + finalZ);
        return { 
            x: finalX * perspective * scale + WIDTH / 2, 
            y: tempY * perspective * scale + HEIGHT / 2 
        };
    }

    function animate() {
        const progress = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedProgress = easeInOutQuint(progress);

        ctx.clearRect(0, 0, WIDTH, HEIGHT);
        const dataA = getPixelData(currentImage);
        const dataB = getPixelData(nextImage);
        
        const scale = 1.0; 
        const rotY = ANGLE_Y * (1 - progress) + progress * Math.PI * 2; 
        const rotX = ANGLE_X * (1 - progress) + progress * Math.PI / 2;
        const sliceZ = (easedProgress * 2 - 1) * 0.5; 

        for (let y = 0; y < HEIGHT; y += RENDER_STEP) {
            for (let x = 0; x < WIDTH; x += RENDER_STEP) {
                const nx = (x - WIDTH / 2) / WIDTH;
                const ny = (y - HEIGHT / 2) / HEIGHT;

                const image = (nx < sliceZ) ? dataA : dataB;
                
                const projected = project3D(nx * 200, ny * 200, 0, rotX, rotY, scale);

                if (projected.x >= 0 && projected.x < WIDTH && projected.y >= 0 && projected.y < HEIGHT) {
                    const i = (y * WIDTH + x) * 4;
                    const r = image.data[i], g = image.data[i + 1], b = image.data[i + 2];
                    
                    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    ctx.fillRect(projected.x, projected.y, RENDER_STEP, RENDER_STEP);
                }
            }
        }

        if (uniqueState.currentFrame++ < uniqueState.totalFrames) requestAnimationFrame(animate);
        else transitionEnd(nextImage);
    }
    return { title: "3D Plane Slice and Rotate", init: init, animate: animate };
})();
// --- ANIMATION 85: Moving Area: Swirl and Restore (Moving Shape) ---
ANIMATION_LOGIC[85] = (function() {
    const uniqueState = { totalFrames: 140, currentFrame: 0 };
    const SWIRL_RADIUS = 100; 

    function init() { uniqueState.currentFrame = 0; }

    function animate() {
        const progress = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedProgress = easeInOutQuint(progress);

        const outputImageData = ctx.createImageData(WIDTH, HEIGHT); // FIX
        const outputData = outputImageData.data; // FIX
        const dataA = getPixelData(currentImage).data;
        const dataB = getPixelData(nextImage).data;

        // Swirl Center (Moves diagonally)
        const swirlX = WIDTH * easedProgress;
        const swirlY = HEIGHT * easedProgress;
        
        for (let y = 0; y < HEIGHT; y++) {
            for (let x = 0; x < WIDTH; x++) {
                const i = (y * WIDTH + x) * 4;
                
                const dx = x - swirlX;
                const dy = y - swirlY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                const swirlFactor = Math.max(0, 1 - dist / SWIRL_RADIUS); 
                
                let sampleX = x, sampleY = y;
                let final_progress = 0;

                if (swirlFactor > 0.1) {
                    // Inside Swirl Area: Apply distortion (A only)
                    const angle = Math.atan2(dy, dx);
                    const newAngle = angle + swirlFactor * Math.PI * 2; 
                    
                    sampleX = swirlX + dist * Math.cos(newAngle);
                    sampleY = swirlY + dist * Math.sin(newAngle);
                    
                    final_progress = 0;
                } else if (y < swirlY && x < swirlX) {
                    // Area already passed by the center: fully transitioned to B
                    final_progress = 1;
                }
                
                const colorA = getPixelColor(dataA, sampleX, sampleY);
                const colorB = getPixelColor(dataB, x, y);

                outputData[i] = Math.round(colorA.r * (1 - final_progress) + colorB.r * final_progress);
                outputData[i + 1] = Math.round(colorA.g * (1 - final_progress) + colorB.g * final_progress);
                outputData[i + 2] = Math.round(colorA.b * (1 - final_progress) + colorB.b * final_progress);
                outputData[i + 3] = 255;
            }
        }
        
        ctx.putImageData(outputImageData, 0, 0); // FIX

        if (uniqueState.currentFrame++ < uniqueState.totalFrames) requestAnimationFrame(animate);
        else transitionEnd(nextImage);
    }
    return { title: "Moving Area: Swirl and Restore", init: init, animate: animate };
})();

// --- ANIMATION 86: 3-Image: Weighted Probability Field (A, M, B) ---
ANIMATION_LOGIC[86] = (function() {
    const uniqueState = { totalFrames: 130, currentFrame: 0 };

    function init() { uniqueState.currentFrame = 0; }

    function animate() {
        const progress = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedProgress = easeInOutQuint(progress);

        const outputImageData = ctx.createImageData(WIDTH, HEIGHT); // FIX
        const outputData = outputImageData.data; // FIX
        const dataA = getPixelData(currentImage).data;
        const dataB = getPixelData(nextImage).data;
        const dataM = dataA; // Fallback for Middle Image Data

        for (let y = 0; y < HEIGHT; y++) {
            for (let x = 0; x < WIDTH; x++) {
                const i = (y * WIDTH + x) * 4;
                
                // Chaotic Weight Generation (3D Noise)
                const noise1 = (perlinNoise(x * 0.01, y * 0.01, uniqueState.currentFrame * 0.01) + 1) / 2;
                const noise2 = (perlinNoise(x * 0.01 + 5, y * 0.01 + 5, uniqueState.currentFrame * 0.01) + 1) / 2;

                let wA_base = 1 - easedProgress;
                let wB_base = easedProgress;
                let wM_base = Math.sin(progress * Math.PI);

                // Apply chaos/noise modulation
                let wA = wA_base * (1 + (noise1 - 0.5) * wM_base * 0.5); 
                let wB = wB_base * (1 + (noise2 - 0.5) * wM_base * 0.5);
                let wM = wM_base * 0.5 + (noise1 * noise2) * wM_base * 0.5;

                // Normalize weights
                const sumW = wA + wB + wM;
                wA /= sumW; wB /= sumW; wM /= sumW;
                
                // Middle Image color (Blend of A and B for visual effect)
                const rM = dataM[i] + (dataB[i] - dataM[i]) * 0.5;
                const gM = dataM[i + 1] + (dataB[i + 1] - dataM[i + 1]) * 0.5;
                const bM = dataM[i + 2] + (dataB[i + 2] - dataM[i + 2]) * 0.5;

                const r = dataA[i] * wA + rM * wM + dataB[i] * wB;
                const g = dataA[i + 1] * wA + gM * wM + dataB[i + 1] * wB;
                const b = dataA[i + 2] * wA + bM * wM + dataB[i + 2] * wB;

                outputData[i] = Math.round(r); outputData[i + 1] = Math.round(g); 
                outputData[i + 2] = Math.round(b); outputData[i + 3] = 255;
            }
        }
        
        ctx.putImageData(outputImageData, 0, 0); // FIX

        if (uniqueState.currentFrame++ < uniqueState.totalFrames) requestAnimationFrame(animate);
        else transitionEnd(nextImage);
    }
    return { title: "Weighted Probability Field (3-Image)", init: init, animate: animate };
})();



// Helper to call next animation (must be defined in your environment)
function transitionEnd(nextImage) {
    // Implement logic to load the next image and start the next transition (e.g., ANIMATION_INDEX++)
    // This is a placeholder for your existing animation loop controller
  startNextTransition();
}











// ====================================================================
// --- 23 ADVANCED ANIMATIONS (Indices 88-110) ---
// ====================================================================

// --- ANIMATION 88: Logarithmic Decay Swirl ---
ANIMATION_LOGIC[88] = (function() {
    const uniqueState = { totalFrames: 110, currentFrame: 0 };
    const DECAY_RATE = 0.01; 

    function init() { uniqueState.currentFrame = 0; }

    function animate() {
        const progress = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedProgress = easeInOutQuint(progress);

        const outputImageData = ctx.createImageData(WIDTH, HEIGHT); // FIX
        const outputData = outputImageData.data; // FIX
        const dataA = getPixelData(currentImage).data;
        const dataB = getPixelData(nextImage).data;
        const midX = WIDTH / 2, midY = HEIGHT / 2;

        const maxAngle = Math.PI * 4 * (1 - easedProgress);

        for (let y = 0; y < HEIGHT; y++) {
            for (let x = 0; x < WIDTH; x++) {
                const i = (y * WIDTH + x) * 4;
                const dx = x - midX, dy = y - midY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                // Angle decay rate increases logarithmically with distance
                const angleDecay = Math.log(dist * DECAY_RATE + 1); 
                
                const originalAngle = Math.atan2(dy, dx);
                const currentAngle = originalAngle + maxAngle * angleDecay;

                const sampleX = Math.round(midX + dist * Math.cos(currentAngle));
                const sampleY = Math.round(midY + dist * Math.sin(currentAngle));
                
                const colorA = getPixelColor(dataA, sampleX, sampleY);
                const colorB = getPixelColor(dataB, x, y);

                outputData[i] = Math.round(colorA.r * (1 - easedProgress) + colorB.r * easedProgress);
                outputData[i + 1] = Math.round(colorA.g * (1 - easedProgress) + colorB.g * easedProgress);
                outputData[i + 2] = Math.round(colorA.b * (1 - easedProgress) + colorB.b * easedProgress);
                outputData[i + 3] = 255;
            }
        }
        
        ctx.putImageData(outputImageData, 0, 0); // FIX

        if (uniqueState.currentFrame++ < uniqueState.totalFrames) requestAnimationFrame(animate);
        else transitionEnd(nextImage);
    }
    return { title: "Logarithmic Decay Swirl", init: init, animate: animate };
})();

// --- ANIMATION 89: Statistical Histogram Equalization ---
ANIMATION_LOGIC[89] = (function() {
    const uniqueState = { totalFrames: 140, currentFrame: 0, cdfMap: [] };
    const NUM_BINS = 32; 

    function init() {
        uniqueState.currentFrame = 0;
        // Pre-calculate target Cumulative Distribution Function (CDF)
        const histA = new Array(NUM_BINS).fill(0);
        const dataA = getPixelData(currentImage).data;
        for (let i = 0; i < dataA.length; i += 4) {
             const lumA = (dataA[i] * 0.21 + dataA[i+1] * 0.72 + dataA[i+2] * 0.07);
             histA[Math.floor(lumA / 256 * NUM_BINS)]++;
        }
        
        let cumulative = 0;
        uniqueState.cdfMap = histA.map(count => {
            cumulative += count;
            return cumulative / (WIDTH * HEIGHT); // Normalized 0 to 1
        });
    }
    
    function animate() {
        const progress = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedProgress = easeInOutQuartic(progress);

        const outputImageData = ctx.createImageData(WIDTH, HEIGHT); // FIX
        const outputData = outputImageData.data; // FIX
        const dataA = getPixelData(currentImage).data;
        const dataB = getPixelData(nextImage).data;

        for (let y = 0; y < HEIGHT; y++) {
            for (let x = 0; x < WIDTH; x++) {
                const i = (y * WIDTH + x) * 4;
                
                const lumA = (dataA[i] * 0.21 + dataA[i+1] * 0.72 + dataA[i+2] * 0.07);
                const oldBin = Math.floor(lumA / 256 * NUM_BINS);
                
                // Transition speed is warped by the CDF (high density areas change faster)
                const cdfValue = uniqueState.cdfMap[oldBin] || 0;
                const final_progress = Math.min(1, easedProgress * (0.5 + cdfValue * 0.5));

                const r = dataA[i] + (dataB[i] - dataA[i]) * final_progress;
                const g = dataA[i + 1] + (dataB[i + 1] - dataA[i + 1]) * final_progress;
                const b = dataA[i + 2] + (dataB[i + 2] - dataA[i + 2]) * final_progress;

                outputData[i] = Math.round(r); outputData[i + 1] = Math.round(g); 
                outputData[i + 2] = Math.round(b); outputData[i + 3] = 255;
            }
        }
        
        ctx.putImageData(outputImageData, 0, 0); // FIX

        if (uniqueState.currentFrame++ < uniqueState.totalFrames) requestAnimationFrame(animate);
        else transitionEnd(nextImage);
    }
    return { title: "Statistical Histogram Equalization", init: init, animate: animate };
})();



// --- ANIMATION 95: Random Walk Noise Floor ---
ANIMATION_LOGIC[95] = (function() {
    const uniqueState = { totalFrames: 120, currentFrame: 0, walker: { x: 0, y: 0 } };
    const STEP_FACTOR = 5;

    function init() { 
        uniqueState.currentFrame = 0;
        uniqueState.walker = { x: WIDTH / 2, y: HEIGHT / 2 };
    }

    function animate() {
        const progress = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedProgress = easeInOutQuartic(progress);

        const outputImageData = ctx.createImageData(WIDTH, HEIGHT); // FIX
        const outputData = outputImageData.data; // FIX
        const dataA = getPixelData(currentImage).data;
        const dataB = getPixelData(nextImage).data;

        // Random Walk Step (Biased towards the center for visual stability)
        const dx = (wielsieder() * 2 - 1) * STEP_FACTOR * (1 - easedProgress);
        const dy = (wielsieder() * 2 - 1) * STEP_FACTOR * (1 - easedProgress);
        uniqueState.walker.x += dx;
        uniqueState.walker.y += dy;
        
        uniqueState.walker.x = Math.max(0, Math.min(WIDTH - 1, uniqueState.walker.x));
        uniqueState.walker.y = Math.max(0, Math.min(HEIGHT - 1, uniqueState.walker.y));
        
        const walkerX = Math.round(uniqueState.walker.x);
        const walkerY = Math.round(uniqueState.walker.y);
        
        for (let y = 0; y < HEIGHT; y++) {
            for (let x = 0; x < WIDTH; x++) {
                const i = (y * WIDTH + x) * 4;
                
                // Distance to the random walker
                const distSq = (x - walkerX)**2 + (y - walkerY)**2;
                const maxDistSq = (WIDTH**2 + HEIGHT**2) / 4;
                
                // Noise factor: Peaks near the walker's position
                const noise_factor = 1 - Math.min(1, distSq / maxDistSq);
                
                // Final progress is boosted by the noise factor
                const final_progress = Math.min(1, easedProgress + noise_factor * (1 - easedProgress));

                const r = dataA[i] + (dataB[i] - dataA[i]) * final_progress;
                const g = dataA[i + 1] + (dataB[i + 1] - dataA[i + 1]) * final_progress;
                const b = dataA[i + 2] + (dataB[i + 2] - dataA[i + 2]) * final_progress;

                outputData[i] = Math.round(r); outputData[i + 1] = Math.round(g); 
                outputData[i + 2] = Math.round(b); outputData[i + 3] = 255;
            }
        }
        
        ctx.putImageData(outputImageData, 0, 0); // FIX

        if (uniqueState.currentFrame++ < uniqueState.totalFrames) requestAnimationFrame(animate);
        else transitionEnd(nextImage);
    }
    return { title: "Random Walk Noise Floor", init: init, animate: animate };
})();

// --- ANIMATION 96: 3D Spherical Coordinate Unwrap ---
ANIMATION_LOGIC[91] = (function() {
    const uniqueState = { totalFrames: 130, currentFrame: 0 };
    const RENDER_STEP = 2; // Pixel stepping for speed

    function init() { uniqueState.currentFrame = 0; }

    function animate() {
        const progress = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedProgress = easeInOutQuint(progress);

        const outputImageData = ctx.createImageData(WIDTH, HEIGHT); // FIX
        const outputData = outputImageData.data; // FIX
        const dataA = getPixelData(currentImage).data;
        const dataB = getPixelData(nextImage).data;
        const midX = WIDTH / 2, midY = HEIGHT / 2;
        const MAX_R = Math.min(midX, midY);

        for (let y = 0; y < HEIGHT; y += RENDER_STEP) {
            for (let x = 0; x < WIDTH; x += RENDER_STEP) {
                const i = (y * WIDTH + x) * 4;
                
                const dx = x - midX, dy = y - midY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                // Phase 1: Wrap Image A onto sphere
                const theta = Math.atan2(dy, dx);
                const phi = (dist / MAX_R) * Math.PI / 2; // Radial distance mapped to polar angle 0 to 90 degrees

                // Sample coordinates on the *unwrapped* Image A
                const sampleXA = Math.round(WIDTH * (theta / (2 * Math.PI) + 0.5));
                const sampleYA = Math.round(HEIGHT * (phi / (Math.PI / 2)));
                
                const colorA = getPixelColor(dataA, sampleXA, sampleYA);
                
                // Final blend
                const r = colorA.r + (dataB[i] - colorA.r) * easedProgress;
                const g = colorA.g + (dataB[i + 1] - colorA.g) * easedProgress;
                const b = colorA.b + (dataB[i + 2] - colorA.b) * easedProgress;
                
                // Apply to block
                for(let dy=0; dy<RENDER_STEP; dy++) {
                    for(let dx=0; dx<RENDER_STEP; dx++) {
                        const cellI = ((y + dy) * WIDTH + (x + dx)) * 4;
                        if(cellI < outputData.length) {
                             outputData[cellI] = Math.round(r); outputData[cellI + 1] = Math.round(g); 
                             outputData[cellI + 2] = Math.round(b); outputData[cellI + 3] = 255;
                        }
                    }
                }
            }
        }
        
        ctx.putImageData(outputImageData, 0, 0); // FIX

        if (uniqueState.currentFrame++ < uniqueState.totalFrames) requestAnimationFrame(animate);
        else transitionEnd(nextImage);
    }
    return { title: "Spherical Coordinate Unwrap", init: init, animate: animate };
})();

// --- ANIMATION 97: Markov Chain Color Shift (Block-based) ---
ANIMATION_LOGIC[82] = (function() {
    const uniqueState = { totalFrames: 200, currentFrame: 0, colorMap: [] };
    const BLOCK_SIZE = 15;
    let NUM_BLOCKS;

    function init() {
        uniqueState.currentFrame = 0;
        const dataA = getPixelData(currentImage).data;
        NUM_BLOCKS = Math.ceil(WIDTH / BLOCK_SIZE) * Math.ceil(HEIGHT / BLOCK_SIZE);
        uniqueState.colorMap = [];

        // Pre-calculate starting colors (State 1)
        for (let i = 0; i < NUM_BLOCKS; i++) {
             // Sample the center of the block for color A
             const x = (i % Math.ceil(WIDTH / BLOCK_SIZE)) * BLOCK_SIZE + BLOCK_SIZE / 2;
             const y = Math.floor(i / Math.ceil(WIDTH / BLOCK_SIZE)) * BLOCK_SIZE + BLOCK_SIZE / 2;
             const color = getPixelColor(dataA, x, y);
             uniqueState.colorMap.push({
                 r: color.r, g: color.g, b: color.b, 
                 state: 0, // 0 = A, 1 = B
                 index: i,
                 delay: wielsieder() * 50 // Staggered start
             });
        }
    }

    // Simple Markov Transition Matrix (A->B, B->B, B->A (rare))
    function transition(state) {
        if (state === 0) return wielsieder() < 0.05 ? 1 : 0; // Low probability A to B
        if (state === 1) return wielsieder() < 0.005 ? 0 : 1; // Very low probability B back to A
        return state;
    }

    function animate() {
        const dataB = getPixelData(nextImage).data;

        uniqueState.colorMap.forEach(block => {
            if (uniqueState.currentFrame > block.delay) {
                 block.state = transition(block.state);
            }
            
            // Draw block
            const blockX = (block.index % Math.ceil(WIDTH / BLOCK_SIZE)) * BLOCK_SIZE;
            const blockY = Math.floor(block.index / Math.ceil(WIDTH / BLOCK_SIZE)) * BLOCK_SIZE;
            
            let targetColor;
            if (block.state === 1) {
                // Use color from Image B at the block's center
                const i = (Math.round(blockY + BLOCK_SIZE/2) * WIDTH + Math.round(blockX + BLOCK_SIZE/2)) * 4;
                targetColor = { r: dataB[i], g: dataB[i+1], b: dataB[i+2] };
            } else {
                targetColor = { r: block.r, g: block.g, b: block.b };
            }

            ctx.fillStyle = `rgb(${targetColor.r}, ${targetColor.g}, ${targetColor.b})`;
            ctx.fillRect(blockX, blockY, BLOCK_SIZE, BLOCK_SIZE);
        });

        if (uniqueState.currentFrame++ < uniqueState.totalFrames) requestAnimationFrame(animate);
        else transitionEnd(nextImage);
    }
    return { title: "Markov Chain Color Shift", init: init, animate: animate };
})();

// --- ANIMATION 98: Wavelet Decomposition Ripple ---
ANIMATION_LOGIC[76] = (function() {
    const uniqueState = { totalFrames: 120, currentFrame: 0 };
    const MAX_WAVELET_STRENGTH = 10; 

    function init() { uniqueState.currentFrame = 0; }

    function animate() {
        const progress = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedProgress = easeInOutQuartic(progress);

        const outputImageData = ctx.createImageData(WIDTH, HEIGHT); // FIX
        const outputData = outputImageData.data; // FIX
        const dataA = getPixelData(currentImage).data;
        const dataB = getPixelData(nextImage).data;
        const midX = WIDTH / 2, midY = HEIGHT / 2;

        const waveletStrength = Math.sin(progress * Math.PI) * MAX_WAVELET_STRENGTH;
        
        for (let y = 0; y < HEIGHT; y++) {
            for (let x = 0; x < WIDTH; x++) {
                const i = (y * WIDTH + x) * 4;
                
                const dx = x - midX, dy = y - midY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                // Simulate wavelet transformation (high frequency detail extraction)
                // Detail is based on sine waves rippling outwards, modulated by image A luminance
                const lumA = (dataA[i] + dataA[i+1] + dataA[i+2]) / 3;
                const phase = dist * 0.1 - uniqueState.currentFrame * 0.1;
                const detail_ripple = Math.sin(phase) * (lumA / 255);
                
                // Sample position (slight offset based on the detail ripple)
                const sampleX = x + detail_ripple * waveletStrength;
                const sampleY = y + detail_ripple * waveletStrength;
                
                const colorA = getPixelColor(dataA, sampleX, sampleY);

                // Blend: B is the base, A is the distorted overlay
                const r = colorA.r * (1 - easedProgress) + dataB[i] * easedProgress;
                const g = colorA.g * (1 - easedProgress) + dataB[i + 1] * easedProgress;
                const b = colorA.b * (1 - easedProgress) + dataB[i + 2] * easedProgress;

                outputData[i] = Math.round(r); outputData[i + 1] = Math.round(g); 
                outputData[i + 2] = Math.round(b); outputData[i + 3] = 255;
            }
        }
        
        ctx.putImageData(outputImageData, 0, 0); // FIX

        if (uniqueState.currentFrame++ < uniqueState.totalFrames) requestAnimationFrame(animate);
        else transitionEnd(nextImage);
    }
    return { title: "Wavelet Decomposition Ripple", init: init, animate: animate };
})();


// --- ANIMATION 100: Poincar Section Warp ---
ANIMATION_LOGIC[71] = (function() {
    const uniqueState = { totalFrames: 120, currentFrame: 0 };
    const MAX_SHEAR = 30;

    function init() { uniqueState.currentFrame = 0; }

    function animate() {
        const progress = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedProgress = Math.sin(progress * Math.PI); // Peaks at 50%

        const outputImageData = ctx.createImageData(WIDTH, HEIGHT); // FIX
        const outputData = outputImageData.data; // FIX
        const dataA = getPixelData(currentImage).data;
        const dataB = getPixelData(nextImage).data;
        const midY = HEIGHT / 2;

        const currentShear = easedProgress * MAX_SHEAR;
        
        for (let y = 0; y < HEIGHT; y++) {
            for (let x = 0; x < WIDTH; x++) {
                const i = (y * WIDTH + x) * 4;
                
                // Poincar Section: Shear is related to y-position and current time (t)
                const shearFactor = Math.sin(y / 50 + progress * Math.PI * 2) * currentShear; 
                
                // Sample image A at the sheared location
                const sampleXA = Math.round(x + shearFactor);
                const sampleYA = y; 
                
                // Blend: The amount of shear dictates the blend ratio
                const blendRatio = Math.min(1, Math.abs(shearFactor) / MAX_SHEAR) * easedProgress;

                const colorA = getPixelColor(dataA, sampleXA, sampleYA);
                
                const r = colorA.r * (1 - blendRatio) + dataB[i] * blendRatio;
                const g = colorA.g * (1 - blendRatio) + dataB[i + 1] * blendRatio;
                const b = colorA.b * (1 - blendRatio) + dataB[i + 2] * blendRatio;

                outputData[i] = Math.round(r); outputData[i + 1] = Math.round(g); 
                outputData[i + 2] = Math.round(b); outputData[i + 3] = 255;
            }
        }
        
        ctx.putImageData(outputImageData, 0, 0); // FIX

        if (uniqueState.currentFrame++ < uniqueState.totalFrames) requestAnimationFrame(animate);
        else transitionEnd(nextImage);
    }
    return { title: "Poincar Section Warp", init: init, animate: animate };
})();

// --- ANIMATION 101: Tesseract Rotation (4D to 2D) ---
ANIMATION_LOGIC[94] = (function() {
    const uniqueState = { totalFrames: 180, currentFrame: 0 };
    const MAX_ROT = Math.PI * 2;
    const RENDER_STEP = 5;

    function init() { uniqueState.currentFrame = 0; }

    function projectTesseract(x, y, z, w, rotAngle, progress) {
        // Simplified 4D rotation (XZ and YW planes) and perspective
        const rotX = rotAngle * progress;
        const rotY = rotAngle * (1 - progress);

        // 1. Rotate XZ
        let newX = x * Math.cos(rotX) + z * Math.sin(rotX);
        let newZ = z * Math.cos(rotX) - x * Math.sin(rotX);
        
        // 2. Rotate YW
        let newY = y * Math.cos(rotY) + w * Math.sin(rotY);
        let newW = w * Math.cos(rotY) - y * Math.sin(rotY);

        // 3. 3D Perspective (using Z and W)
        const perspective = 200 / (200 + newZ + newW * 0.5); 
        
        return { 
            x: newX * perspective + WIDTH / 2, 
            y: newY * perspective + HEIGHT / 2
        };
    }

    function animate() {
        const progress = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedProgress = easeInOutQuint(progress);

        ctx.clearRect(0, 0, WIDTH, HEIGHT);
        const dataA = getPixelData(currentImage);
        const dataB = getPixelData(nextImage);

        const rotAngle = MAX_ROT; 
        
        for (let y = 0; y < HEIGHT; y += RENDER_STEP) {
            for (let x = 0; x < WIDTH; x += RENDER_STEP) {
                const nx = (x - WIDTH / 2);
                const ny = (y - HEIGHT / 2);
                
                // Z and W are based on the blend ratio
                const z_coord = 50 * (1 - easedProgress); 
                const w_coord = -50 * easedProgress;

                const projected = projectTesseract(nx, ny, z_coord, w_coord, rotAngle, progress);
                
                const image = (z_coord > w_coord) ? dataA : dataB; // Arbitrary choice based on Z/W

                if (projected.x >= 0 && projected.x < WIDTH && projected.y >= 0 && projected.y < HEIGHT) {
                    const i = (y * WIDTH + x) * 4;
                    const r = image.data[i], g = image.data[i + 1], b = image.data[i + 2];
                    
                    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    ctx.fillRect(projected.x, projected.y, RENDER_STEP, RENDER_STEP);
                }
            }
        }

        if (uniqueState.currentFrame++ < uniqueState.totalFrames) requestAnimationFrame(animate);
        else transitionEnd(nextImage);
    }
    return { title: "Tesseract Rotation (4D)", init: init, animate: animate };
})();

// --- ANIMATION 102: Reaction-Diffusion Pattern (Simulated) ---
ANIMATION_LOGIC[95] = (function() {
    const uniqueState = { totalFrames: 250, currentFrame: 0, grid: [] };
    const BLOCK_SIZE = 4;
    let NUM_COLS, NUM_ROWS;
    
    // FIXED: Separate constant declarations
    const FEED = 0.055;
    const KILL = 0.062;
    // F and K for stable Turing pattern
    const DA = 1.0;
    const DB = 0.5;
    // Diffusion rates

    function init() {
        uniqueState.currentFrame = 0;
        NUM_COLS = Math.floor(WIDTH / BLOCK_SIZE);
        NUM_ROWS = Math.floor(HEIGHT / BLOCK_SIZE);
        uniqueState.grid = [];
        
        for (let r = 0; r < NUM_ROWS; r++) {
            uniqueState.grid[r] = [];
            for (let c = 0; c < NUM_COLS; c++) {
                // Initialize A (Activator) = 1, B (Inhibitor) = 0
                let b_init = 0;
                // Add a small seed of B (inhibitor)
                if (r > NUM_ROWS / 2 - 5 && r < NUM_ROWS / 2 + 5 && c > NUM_COLS / 2 - 5 && c < NUM_COLS / 2 + 5) {
                    b_init = 1; 
                }
                uniqueState.grid[r][c] = { A: 1.0, B: b_init, dA: 0, dB: 0 }; 
            }
        }
    }
    
    function laplace(r, c, prop) {
        let sum = 0;
        for (let dr = -1; dr <= 1; dr++) {
            for (let dc = -1; dc <= 1; dc++) {
                // FIXED: Separate constant declarations
                const nr = r + dr;
                const nc = c + dc;
                
                if (nr >= 0 && nr < NUM_ROWS && nc >= 0 && nc < NUM_COLS) {
                    const weight = (dr === 0 && dc === 0) ? -1 : 0.2; // 0.2, 0.05, 0.2 for full 9-point stencil
                    sum += uniqueState.grid[nr][nc][prop] * weight;
                }
            }
        }
        return sum;
    }

    function animate() {
        const dataB = getPixelData(nextImage).data;
        
        // 1. Calculate Deltas (Performance intensive: simplified model)
        const nextGrid = JSON.parse(JSON.stringify(uniqueState.grid));
        for (let r = 0; r < NUM_ROWS; r++) {
            for (let c = 0; c < NUM_COLS; c++) {
                const cell = uniqueState.grid[r][c];
                const La = laplace(r, c, 'A');
                const Lb = laplace(r, c, 'B');
                
                // Gray-Scott Equations (simplified time step)
                const reaction = cell.A * cell.B * cell.B;
                
                nextGrid[r][c].A = cell.A + (DA * La - reaction + FEED * (1 - cell.A));
                nextGrid[r][c].B = cell.B + (DB * Lb + reaction - (KILL + FEED) * cell.B);
                
                // Clamp values
                nextGrid[r][c].A = Math.min(1, Math.max(0, nextGrid[r][c].A));
                nextGrid[r][c].B = Math.min(1, Math.max(0, nextGrid[r][c].B));
            }
        }
        uniqueState.grid = nextGrid;

        // 2. Draw
        ctx.clearRect(0, 0, WIDTH, HEIGHT);
        for (let r = 0; r < NUM_ROWS; r++) {
            for (let c = 0; c < NUM_COLS; c++) {
                const cell = uniqueState.grid[r][c];
                const x = c * BLOCK_SIZE;
                const y = r * BLOCK_SIZE;
                
                const i = (y * WIDTH + x) * 4;
                
                // Blend color A and B based on the cell's B-concentration
                const alphaB = cell.B; 
                
                // This section was fixed in the previous turn
                const rB = dataB[i];
                const gB = dataB[i + 1];
                const bB = dataB[i + 2];
                
                const re = cell.A * (255 * (1 - alphaB)) + rB * alphaB;
                const g = cell.A * (255 * (1 - alphaB)) + gB * alphaB;
                const b = cell.A * (255 * (1 - alphaB)) + bB * alphaB;

                ctx.fillStyle = `rgb(${Math.round(re)}, ${Math.round(g)}, ${Math.round(b)})`;
                ctx.fillRect(x, y, BLOCK_SIZE, BLOCK_SIZE);
            }
        }

        if (uniqueState.currentFrame++ < uniqueState.totalFrames) requestAnimationFrame(animate);
        else transitionEnd(nextImage);
    }
    return { title: "Reaction-Diffusion Pattern", init: init, animate: animate };
})();

// --- ANIMATION 103: Dynamic Tessellation Shatter ---
ANIMATION_LOGIC[92] = (function() {
    const uniqueState = { totalFrames: 120, currentFrame: 0, cells: [] };
    const NUM_CELLS = 50;

    function init() {
        uniqueState.currentFrame = 0;
        uniqueState.cells = [];
        for (let i = 0; i < NUM_CELLS; i++) {
            uniqueState.cells.push({
                x: WIDTH * wielsieder(), y: HEIGHT * wielsieder(),
                vx: (wielsieder() * 2 - 1) * 2, vy: (wielsieder() * 2 - 1) * 2,
                color: [wielsieder() * 255, wielsieder() * 255, wielsieder() * 255],
                delay: wielsieder() * 30
            });
        }
    }













    function animate() {
        const progress = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedProgress = easeInOutQuartic(progress);

        ctx.clearRect(0, 0, WIDTH, HEIGHT);
        ctx.drawImage(nextImage, 0, 0, WIDTH, HEIGHT); // Draw B as base

        const dataA = getPixelData(currentImage).data;
        
        // 1. Draw Image A (Shattered Cells)
        uniqueState.cells.forEach((cell, cellIndex) => {
            const time = uniqueState.currentFrame - cell.delay;
            if (time < 0) return;
            
            const cellProgress = Math.min(1, time / (uniqueState.totalFrames - 30));
            
            if (cellProgress < 0.5) {
                // Shatter Phase (A): Move cell outwards
                cell.x += cell.vx;
                cell.y += cell.vy;
            } else {
                // Collapse Phase (B): Interpolate to final B state
                const collapseFactor = (cellProgress - 0.5) * 2;
                cell.vx *= 0.9; cell.vy *= 0.9;
                
                // Simulated return to center (collapse)
                cell.x = cell.x * (1 - collapseFactor) + WIDTH / 2 * collapseFactor;
                cell.y = cell.y * (1 - collapseFactor) + HEIGHT / 2 * collapseFactor;
            }

            // Draw Voronoi-like region for Image A
            ctx.beginPath();
            let boundary = []; // Simplification: just draw a shrinking square
            const size = 50 * (1 - easedProgress);
            ctx.rect(cell.x - size/2, cell.y - size/2, size, size);
            
            // Sample color from A (or use average block color)
            const i = (Math.round(cell.y) * WIDTH + Math.round(cell.x)) * 4;
            const r = dataA[i], g = dataA[i + 1], b = dataA[i + 2];
            
            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${1 - easedProgress})`;
            ctx.fill();
        });

        if (uniqueState.currentFrame++ < uniqueState.totalFrames) requestAnimationFrame(animate);
        else transitionEnd(nextImage);
    }
    return { title: "Dynamic Tessellation Shatter", init: init, animate: animate };
})();















ANIMATION_LOGIC[94] = (function() {
    const uniqueState = { totalFrames: 100, currentFrame: 0, traceMap: [] };
    
    // Simpele lineaire interpolatie
    function lerp(a, b, t) {
        return a + (b - a) * t;
    }

    function init() {
        uniqueState.currentFrame = 0;
    }

    function animate() {
        const progress = uniqueState.currentFrame / uniqueState.totalFrames;
        // Gebruik de easing functie voor een vloeiendere animatie
        const easedProgress = easeInOutQuint(progress);

        const outputImageData = ctx.createImageData(WIDTH, HEIGHT); 
        const outputData = outputImageData.data; 
        
        // Aangenomen: getPixelData retourneert een ImageData object
        const dataA = getPixelData(currentImage).data; // Pixeldata van Foto 1
        const dataB = getPixelData(nextImage).data;   // Pixeldata van Foto 2
        
        // --- Transformatie Logica ---

        // 1. Schaal (Vergroting/Verkleining)
        // Schaal van Foto 1: van 1.0 naar 0.0 (krimpt)
        const scaleA = 1 - easedProgress;
        // Schaal van Foto 2: van 0.0 naar 1.0 (groeit)
        const scaleB = easedProgress;

        // 2. Scheeftrekking (Skew/Shear)
        // Max Scheeftrek Factor (bijv. 0.5 voor een sterke scheeftrekking)
        const maxSkew = 0.5;
        // Scheeftrek Factor voor Foto 1: van 0.0 naar maxSkew
        const skewFactorA = maxSkew * easedProgress; 
        // Scheeftrek Factor voor Foto 2: van maxSkew naar 0.0
        const skewFactorB = maxSkew * (1 - easedProgress);

        const centerX = WIDTH / 2;
        const centerY = HEIGHT / 2;

        for (let y = 0; y < HEIGHT; y++) {
            for (let x = 0; x < WIDTH; x++) {
                const i = (y * WIDTH + x) * 4;
                
                // --- Berekening voor Foto 1 (Krimpen en Skew) ---
                
                // Anti-transformatie (van doel naar bron cordinaten)
                // 1. Descale (Inverse van scaleA)
                const descaledX_A = (x - centerX) / scaleA;
                const descaledY_A = (y - centerY) / scaleA;
                
                // 2. Deskew (Inverse van skew)
                // Shear X: x' = x + skewFactor * y
                // Inverse Shear X: x = x' - skewFactor * y'
                const srcX_A = Math.round(descaledX_A - skewFactorA * descaledY_A + centerX);
                const srcY_A = Math.round(descaledY_A + centerY);
                
                // --- Berekening voor Foto 2 (Groeien en Skew) ---
                
                // 1. Descale (Inverse van scaleB)
                const descaledX_B = (x - centerX) / scaleB;
                const descaledY_B = (y - centerY) / scaleB;
                
                // 2. Deskew (Inverse van skew)
                const srcX_B = Math.round(descaledX_B - skewFactorB * descaledY_B + centerX);
                const srcY_B = Math.round(descaledY_B + centerY);

                let r = 0, g = 0, b = 0, a = 0;

                // Haal pixels op en combineer (Alpha Blending op basis van progress)
                
                // Alleen pixels uit Foto A ophalen als de schaal > 0 is
                if (scaleA > 0.01 && srcX_A >= 0 && srcX_A < WIDTH && srcY_A >= 0 && srcY_A < HEIGHT) {
                    const iA = (srcY_A * WIDTH + srcX_A) * 4;
                    const alphaA = 1 - easedProgress; // Transparantie factor
                    
                    r += dataA[iA] * alphaA;
                    g += dataA[iA + 1] * alphaA;
                    b += dataA[iA + 2] * alphaA;
                    a += dataA[iA + 3] * alphaA / 255;
                }

                // Alleen pixels uit Foto B ophalen als de schaal > 0 is
                if (scaleB > 0.01 && srcX_B >= 0 && srcX_B < WIDTH && srcY_B >= 0 && srcY_B < HEIGHT) {
                    const iB = (srcY_B * WIDTH + srcX_B) * 4;
                    const alphaB = easedProgress; // Transparantie factor
                    
                    r += dataB[iB] * alphaB;
                    g += dataB[iB + 1] * alphaB;
                    b += dataB[iB + 2] * alphaB;
                    a += dataB[iB + 3] * alphaB / 255;
                }

                // Schrijf de gecombineerde pixeldata weg
                outputData[i] = Math.round(r);
                outputData[i + 1] = Math.round(g);
                outputData[i + 2] = Math.round(b);
                outputData[i + 3] = Math.min(255, Math.round(a * 255));
            }
        }
           
        ctx.putImageData(outputImageData, 0, 0); // Plaats de bewerkte data op het canvas

        if (uniqueState.currentFrame++ < uniqueState.totalFrames) {
            requestAnimationFrame(animate);
        } else {
            transitionEnd(nextImage);
        }
    }
    
    // De titel van de animatie
    return { title: "Schaal & Horizontale Scheeftrekking", init: init, animate: animate };
})();



ANIMATION_LOGIC[93] = (function() {
    const uniqueState = { totalFrames: 150, currentFrame: 0, traceMap: [] };
    const PHASE1_END_FRAME = 75; // 50% van de animatie
    
    function init() {
        uniqueState.currentFrame = 0;
    }

    // Functie om RGB om te zetten naar HSL (nodig voor de Kleurverschuiving)
    function rgbToHsl(r, g, b) {
        // [Implementatie van standaard rgbToHsl] ...
        // Voor beknoptheid weggelaten, maar nodig voor Kleurverschuiving (Hue Shift).
        // Aangenomen dat deze functie bestaat en [h, s, l] retourneert
        return [0, 0, 0]; 
    }
    
    // Functie om HSL om te zetten naar RGB
    function hslToRgb(h, s, l) {
        // [Implementatie van standaard hslToRgb] ...
        // Voor beknoptheid weggelaten, maar nodig voor Kleurverschuiving (Hue Shift).
        return [0, 0, 0];
    }
    
    function animate() {
        const progress = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedProgress = easeInOutQuint(progress);

        const outputImageData = ctx.createImageData(WIDTH, HEIGHT); 
        const outputData = outputImageData.data; 
        
        const dataA = getPixelData(currentImage).data; 
        const dataB = getPixelData(nextImage).data;   
        
        const centerX = WIDTH / 2;
        const centerY = HEIGHT / 2;
        
        // Breek de animatie op in twee fasen
        const phase1Progress = Math.min(1, uniqueState.currentFrame / PHASE1_END_FRAME); // Van 0 tot 1 in fase 1
        const phase2Progress = Math.min(1, Math.max(0, (uniqueState.currentFrame - PHASE1_END_FRAME) / (uniqueState.totalFrames - PHASE1_END_FRAME))); // Van 0 tot 1 in fase 2
        
        // Gebruik een willekeurige, herhaalbare zaadwaarde (seed) om de "chaos" te bepalen
        const seed = 1.618; 

        for (let y = 0; y < HEIGHT; y++) {
            for (let x = 0; x < WIDTH; x++) {
                const i = (y * WIDTH + x) * 4;
                
                let r = 0, g = 0, b = 0, a = 0;

                if (uniqueState.currentFrame <= PHASE1_END_FRAME) {
                    // --- FASE 1: Pixel Chaos & Desintegratie (Foto A -> Ruis) ---
                    
                    // 1. Scheeftrekking (niet-lineair): Verschuiving afhankelijk van de sin van de cordinaat.
                    // Dit creert een golvend, niet-intutief patroon.
                    const chaosFactor = 50 * Math.sin(x / 30 + y / 50 + seed);
                    const srcX = Math.round(x + chaosFactor * phase1Progress);
                    const srcY = Math.round(y + chaosFactor * phase1Progress * 0.5); // Minder impact op Y

                    // 2. Alpha/Kleur: Vervorming van de kleur en Alpha
                    const iA = ((y * WIDTH + x) * 4); // Basis cordinaat (voor kleur)

                    if (srcX >= 0 && srcX < WIDTH && srcY >= 0 && srcY < HEIGHT) {
                        const iSrc = (srcY * WIDTH + srcX) * 4;
                        
                        // Pixel van Foto A
                        let rA = dataA[iSrc], gA = dataA[iSrc + 1], bA = dataA[iSrc + 2];
                        let aA = dataA[iSrc + 3] / 255;
                        
                        // Radiale Hue Shift (Kleurverandering): Kleur roteert afhankelijk van de afstand tot het midden
                        const dist = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
                        const hueShift = (dist / (WIDTH / 2) * 180 * phase1Progress); // Verschuiving tot 180 graden

                        // *** HSL conversie zou hier moeten plaatsvinden om kleur te veranderen ***
                        // [rA, gA, bA] = hslToRgb(h + hueShift, s, l); 

                        // Alpha daalt
                        const currentAlpha = aA * (1 - phase1Progress);
                        
                        r = rA * currentAlpha;
                        g = gA * currentAlpha;
                        b = bA * currentAlpha;
                        a = currentAlpha;
                    }
                    
                } else {
                    // --- FASE 2: Radiale Convergentie (Ruis -> Foto B) ---
                    
                    // 1. Schaal/Skew (Radiale Convergentie): Pixels bewegen naar hun doelcordinaat.
                    // Progressie van de "ruis" (een punt in het centrum) naar de volledige afbeelding.
                    const scaleFactor = phase2Progress;
                    
                    // Omgekeerde transformatie van schaal:
                    const descaledX = (x - centerX) / scaleFactor;
                    const descaledY = (y - centerY) / scaleFactor;
                    
                    const srcX_B = Math.round(descaledX + centerX);
                    const srcY_B = Math.round(descaledY + centerY);
                    
                    // 2. Alpha/Kleur: Alpha stijgt naar 1.0; Radiale Hue Shift verdwijnt.
                    if (srcX_B >= 0 && srcX_B < WIDTH && srcY_B >= 0 && srcY_B < HEIGHT) {
                        const iB = (srcY_B * WIDTH + srcX_B) * 4;
                        
                        let rB = dataB[iB], gB = dataB[iB + 1], bB = dataB[iB + 2];
                        let aB = dataB[iB + 3] / 255;

                        // Radiale Hue Shift omgekeerd: verdwijnt
                        const dist = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
                        const hueShift = (dist / (WIDTH / 2) * 180 * (1 - phase2Progress)); 
                        
                        // *** HSL conversie zou hier moeten plaatsvinden om kleur te veranderen ***
                        // [rB, gB, bB] = hslToRgb(h + hueShift, s, l); 

                        const currentAlpha = aB * phase2Progress;
                        
                        r = rB * currentAlpha;
                        g = gB * currentAlpha;
                        b = bB * currentAlpha;
                        a = currentAlpha;
                    }
                }
                
                // Schrijf de gecombineerde pixeldata weg
                outputData[i] = Math.round(r);
                outputData[i + 1] = Math.round(g);
                outputData[i + 2] = Math.round(b);
                outputData[i + 3] = Math.min(255, Math.round(a * 255));
            }
        }
           
        ctx.putImageData(outputImageData, 0, 0);

        if (uniqueState.currentFrame++ < uniqueState.totalFrames) {
            requestAnimationFrame(animate);
        } else {
            transitionEnd(nextImage);
        }
    }
    
    // De titel van de animatie
    return { title: "Fractale Chaos & Chromatic Warp (2 Fasen)", init: init, animate: animate };
})();// --- ANIMATION 104: Gravitational Lens Distortion ---
ANIMATION_LOGIC[87] = (function() {
    const uniqueState = { totalFrames: 120, currentFrame: 0 };
    const MAX_STRENGTH = 0.5; // Max distortion factor

    function init() { uniqueState.currentFrame = 0; }

    // Simplified Lens Equation: Map observed point (x, y) to source point (beta_x, beta_y)
    function lensMap(x, y, strength) {
        const midX = WIDTH / 2, midY = HEIGHT / 2;
        const dx = x - midX, dy = y - midY;
        const distSq = dx*dx + dy*dy;
        
        const alpha = strength / distSq; // Deflection angle (proportional to 1/r)
        
        const betaX = x - dx * alpha;
        const betaY = y - dy * alpha;
        return { x: betaX, y: betaY };
    }

    function animate() {
        const progress = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedProgress = Math.sin(progress * Math.PI); // Peak distortion at 50%

        const outputImageData = ctx.createImageData(WIDTH, HEIGHT); // FIX
        const outputData = outputImageData.data; // FIX
        const dataA = getPixelData(currentImage).data;
        const dataB = getPixelData(nextImage).data;

        const strength = easedProgress * MAX_STRENGTH * WIDTH * 100; // Scaling for visualization
        
        for (let y = 0; y < HEIGHT; y++) {
            for (let x = 0; x < WIDTH; x++) {
                const i = (y * WIDTH + x) * 4;
                
                const source = lensMap(x, y, strength);
                
                // Sample image A at the mapped source location
                const colorA = getPixelColor(dataA, source.x, source.y);
                
                // Blend: High distortion = more blending to B
                const blendRatio = easedProgress;

                const r = colorA.r * (1 - blendRatio) + dataB[i] * blendRatio;
                const g = colorA.g * (1 - blendRatio) + dataB[i + 1] * blendRatio;
                const b = colorA.b * (1 - blendRatio) + dataB[i + 2] * blendRatio;

                outputData[i] = Math.round(r); outputData[i + 1] = Math.round(g); 
                outputData[i + 2] = Math.round(b); outputData[i + 3] = 255;
            }
        }
        
        ctx.putImageData(outputImageData, 0, 0); // FIX

        if (uniqueState.currentFrame++ < uniqueState.totalFrames) requestAnimationFrame(animate);
        else transitionEnd(nextImage);
    }
    return { title: "Gravitational Lens Distortion", init: init, animate: animate };
})();



// --- ANIMATION 106: Chaotic Bifurcation Split ---
ANIMATION_LOGIC[83] = (function() {
    const uniqueState = { totalFrames: 120, currentFrame: 0 };
    const R_MIN = 2.9, R_MAX = 4.0; // Bifurcation parameter range

    function init() { uniqueState.currentFrame = 0; }

    // Logistic Map (Chaotic System)
    function logisticMap(x, r) {
        return r * x * (1 - x);
    }

    function animate() {
        const progress = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedProgress = Math.sin(progress * Math.PI); // Peaks at 50%

        const outputImageData = ctx.createImageData(WIDTH, HEIGHT); // FIX
        const outputData = outputImageData.data; // FIX
        const dataA = getPixelData(currentImage).data;
        const dataB = getPixelData(nextImage).data;

        // Bifurcation parameter r: Moves through periodic, chaotic, and back to fixed points
        const r_value = R_MIN + (R_MAX - R_MIN) * easedProgress; 
        
        for (let y = 0; y < HEIGHT; y++) {
            for (let x = 0; x < WIDTH; x++) {
                const i = (y * WIDTH + x) * 4;
                
                // Initial condition x0 based on pixel position
                const x0 = (x / WIDTH) * 0.5 + 0.2; 
                let x_n = x0;
                
                // Iterate map 10 times to settle
                for(let iter=0; iter<10; iter++) x_n = logisticMap(x_n, r_value);
                
                // Map the final chaotic state (x_n) to a vertical distortion
                const distortionY = (x_n - 0.5) * HEIGHT * 0.1; 
                
                // Sample image A with distortion
                const sampleYA = y + distortionY;
                const colorA = getPixelColor(dataA, x, sampleYA);
                
                // Blend: Chaos factor (r > 3.5) determines transition
                const chaos_factor = Math.min(1, Math.max(0, r_value - 3.5) / 0.5);

                const r = colorA.r * (1 - chaos_factor) + dataB[i] * chaos_factor;
                const g = colorA.g * (1 - chaos_factor) + dataB[i + 1] * chaos_factor;
                const b = colorA.b * (1 - chaos_factor) + dataB[i + 2] * chaos_factor;

                outputData[i] = Math.round(r); outputData[i + 1] = Math.round(g); 
                outputData[i + 2] = Math.round(b); outputData[i + 3] = 255;
            }
        }
        
        ctx.putImageData(outputImageData, 0, 0); // FIX

        if (uniqueState.currentFrame++ < uniqueState.totalFrames) requestAnimationFrame(animate);
        else transitionEnd(nextImage);
    }
    return { title: "Chaotic Bifurcation Split", init: init, animate: animate };
})();
// --- ANIMATION 108: Spectral Clustering Wipe ---
ANIMATION_LOGIC[77] = (function() {
    const uniqueState = { totalFrames: 120, currentFrame: 0, clusterMap: [] };
    const NUM_CLUSTERS = 8;
    const RENDER_STEP = 5;

    function init() {
        uniqueState.currentFrame = 0;
        uniqueState.clusterMap = [];
        const dataA = getPixelData(currentImage).data;
        
        // Simplified clustering: assign pixels to a cluster based on initial luminance
        for (let y = 0; y < HEIGHT; y += RENDER_STEP) {
            for (let x = 0; x < WIDTH; x += RENDER_STEP) {
                const i = ((y + RENDER_STEP/2) * WIDTH + (x + RENDER_STEP/2)) * 4;
                const lum = (dataA[i] + dataA[i+1] + dataA[i+2]) / 3;
                const cluster = Math.floor(lum / 256 * NUM_CLUSTERS);
                uniqueState.clusterMap.push(cluster);
            }
        }
    }

    function animate() {
        const progress = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedProgress = easeInOutQuartic(progress);

        const outputImageData = ctx.createImageData(WIDTH, HEIGHT); // FIX
        const outputData = outputImageData.data; // FIX
        const dataA = getPixelData(currentImage).data;
        const dataB = getPixelData(nextImage).data;
        let blockIndex = 0;

        // Determine which clusters have transitioned
        const clustersToTransition = Math.floor(easedProgress * NUM_CLUSTERS); 

        for (let y = 0; y < HEIGHT; y += RENDER_STEP) {
            for (let x = 0; x < WIDTH; x += RENDER_STEP) {
                const cluster = uniqueState.clusterMap[blockIndex++];
                
                let final_progress = (cluster < clustersToTransition) ? 1 : 0;
                
                for (let dy = 0; dy < RENDER_STEP; dy++) {
                    for (let dx = 0; dx < RENDER_STEP; dx++) {
                        const i = ((y + dy) * WIDTH + (x + dx)) * 4;
                        
                        if(i < outputData.length) {
                            const r = dataA[i] + (dataB[i] - dataA[i]) * final_progress;
                            const g = dataA[i + 1] + (dataB[i + 1] - dataA[i + 1]) * final_progress;
                            const b = dataA[i + 2] + (dataB[i + 2] - dataA[i + 2]) * final_progress;
                            
                            outputData[i] = Math.round(r); outputData[i + 1] = Math.round(g); 
                            outputData[i + 2] = Math.round(b); outputData[i + 3] = 255;
                        }
                    }
                }
            }
        }
        
        ctx.putImageData(outputImageData, 0, 0); // FIX

        if (uniqueState.currentFrame++ < uniqueState.totalFrames) requestAnimationFrame(animate);
        else transitionEnd(nextImage);
    }
    return { title: "Spectral Clustering Wipe", init: init, animate: animate };
})();





























ANIMATION_LOGIC[101] = (function() {
    const uniqueState = { totalFrames: 100, currentFrame: 0 };
    function init() { uniqueState.currentFrame = 0; }
    function animate() {
        const progress = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedProgress = easeInOutQuint(progress);
        const outputImageData = ctx.createImageData(WIDTH, HEIGHT); 
        const outputData = outputImageData.data; 
        const dataA = getPixelData(currentImage).data; 
        const dataB = getPixelData(nextImage).data;   

        // Schaal A: van 1.0 naar 0.0 (Implosie)
        const scaleA = 1 - easedProgress;
        // Schaal B: van 0.0 naar 1.0 (Explosie)
        const scaleB = easedProgress;
        
        const alphaA = scaleA; // Alpha volgt schaal
        const alphaB = scaleB;

        const centerX = WIDTH / 2;
        const centerY = HEIGHT / 2;

        for (let y = 0; y < HEIGHT; y++) {
            for (let x = 0; x < WIDTH; x++) {
                const i = (y * WIDTH + x) * 4;
                
                // Inverse schaling
                const srcX_A = Math.round(((x - centerX) / scaleA) + centerX);
                const srcY_A = Math.round(((y - centerY) / scaleA) + centerY);
                
                const srcX_B = Math.round(((x - centerX) / scaleB) + centerX);
                const srcY_B = Math.round(((y - centerY) / scaleB) + centerY);
                
                let r = 0, g = 0, b = 0, a = 0;
                
                // ... (Pixel ophalen en Blenden logica - analoog aan #98) ...
                if (scaleA > 0.01 && srcX_A >= 0 && srcX_A < WIDTH && srcY_A >= 0 && srcY_A < HEIGHT) {
                    const iA = (srcY_A * WIDTH + srcX_A) * 4;
                    r += dataA[iA] * alphaA; g += dataA[iA+1] * alphaA; b += dataA[iA+2] * alphaA; a += (dataA[iA+3]/255) * alphaA;
                }
                if (scaleB > 0.01 && srcX_B >= 0 && srcX_B < WIDTH && srcY_B >= 0 && srcY_B < HEIGHT) {
                    const iB = (srcY_B * WIDTH + srcX_B) * 4;
                    r += dataB[iB] * alphaB; g += dataB[iB+1] * alphaB; b += dataB[iB+2] * alphaB; a += (dataB[iB+3]/255) * alphaB;
                }

                const finalAlpha = Math.min(1, a);
                if (finalAlpha > 0) {
                    outputData[i] = Math.round(r / finalAlpha); outputData[i + 1] = Math.round(g / finalAlpha); outputData[i + 2] = Math.round(b / finalAlpha); outputData[i + 3] = Math.round(finalAlpha * 255);
                } else { outputData[i] = 0; outputData[i + 1] = 0; outputData[i + 2] = 0; outputData[i + 3] = 0; }
            }
        }
        ctx.putImageData(outputImageData, 0, 0); 
        if (uniqueState.currentFrame++ < uniqueState.totalFrames) requestAnimationFrame(animate);
        else transitionEnd(nextImage);
    }
    return { title: "Schaal & Transparantie (Implosie/Explosie)", init: init, animate: animate };
})();



ANIMATION_LOGIC[100] = (function() {
    const uniqueState = { totalFrames: 100, currentFrame: 0 };
    function init() { uniqueState.currentFrame = 0; }
    function animate() {
        const progress = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedProgress = easeInOutQuint(progress);
        const outputImageData = ctx.createImageData(WIDTH, HEIGHT); 
        const outputData = outputImageData.data; 
        const dataA = getPixelData(currentImage).data; 
        const dataB = getPixelData(nextImage).data;   

        // Simuleer 3D-rotatie met Skew factor (grootste vervorming in het midden)
        const maxSkew = 0.5; 
        const maxRotation = Math.PI; // Halve draai
        
        const skewA = maxSkew * Math.sin(Math.PI * easedProgress); // Gaat van 0 naar max en terug naar 0
        const rotA = maxRotation * easedProgress;
        
        const skewB = maxSkew * Math.sin(Math.PI * easedProgress); // Zelfde skew
        const rotB = maxRotation * (1 - easedProgress); // Tegengestelde rotatie

        const centerX = WIDTH / 2;
        const centerY = HEIGHT / 2;

        for (let y = 0; y < HEIGHT; y++) {
            for (let x = 0; x < WIDTH; x++) {
                const i = (y * WIDTH + x) * 4;
                
                // Rotatie- en Skew matrices combineren... (Hier vereenvoudigd tot een Skew-Rotate transformatie)
                
                const dx_A = x - centerX;
                const dy_A = y - centerY;
                
                // Inverse Skew (Y-Skew, afhankelijk van X)
                const preRotY_A = dy_A;
                const preRotX_A = dx_A - (skewA * preRotY_A);

                // Inverse Rotatie
                const cosA = Math.cos(-rotA); // Inverse rotatie
                const sinA = Math.sin(-rotA); 
                const srcX_A = Math.round(preRotX_A * cosA - preRotY_A * sinA + centerX);
                const srcY_A = Math.round(preRotX_A * sinA + preRotY_A * cosA + centerY);
                
                // ... (Analoge berekening voor Foto B: srcX_B en srcY_B) ...
                const dx_B = x - centerX;
                const dy_B = y - centerY;
                const preRotY_B = dy_B;
                const preRotX_B = dx_B - (skewB * preRotY_B);
                const cosB = Math.cos(-rotB); 
                const sinB = Math.sin(-rotB); 
                const srcX_B = Math.round(preRotX_B * cosB - preRotY_B * sinB + centerX);
                const srcY_B = Math.round(preRotX_B * sinB + preRotY_B * cosB + centerY);


                const alphaA = 1 - easedProgress;
                const alphaB = easedProgress;
                let r = 0, g = 0, b = 0, a = 0;
                
                // ... (Pixel ophalen en Blenden logica - analoog aan #98) ...
                if (alphaA > 0.01 && srcX_A >= 0 && srcX_A < WIDTH && srcY_A >= 0 && srcY_A < HEIGHT) {
                    const iA = (srcY_A * WIDTH + srcX_A) * 4;
                    r += dataA[iA] * alphaA; g += dataA[iA+1] * alphaA; b += dataA[iA+2] * alphaA; a += (dataA[iA+3]/255) * alphaA;
                }
                if (alphaB > 0.01 && srcX_B >= 0 && srcX_B < WIDTH && srcY_B >= 0 && srcY_B < HEIGHT) {
                    const iB = (srcY_B * WIDTH + srcX_B) * 4;
                    r += dataB[iB] * alphaB; g += dataB[iB+1] * alphaB; b += dataB[iB+2] * alphaB; a += (dataB[iB+3]/255) * alphaB;
                }

                const finalAlpha = Math.min(1, a);
                if (finalAlpha > 0) {
                    outputData[i] = Math.round(r / finalAlpha); outputData[i + 1] = Math.round(g / finalAlpha); outputData[i + 2] = Math.round(b / finalAlpha); outputData[i + 3] = Math.round(finalAlpha * 255);
                } else { outputData[i] = 0; outputData[i + 1] = 0; outputData[i + 2] = 0; outputData[i + 3] = 0; }
            }
        }
        ctx.putImageData(outputImageData, 0, 0); 
        if (uniqueState.currentFrame++ < uniqueState.totalFrames) requestAnimationFrame(animate);
        else transitionEnd(nextImage);
    }
    return { title: "Scheeftrekking & Rotatie (Pseudo 3D)", init: init, animate: animate };
})();










ANIMATION_LOGIC[99] = (function() {
    const uniqueState = { totalFrames: 80, currentFrame: 0 };
    function init() { uniqueState.currentFrame = 0; }
    function animate() {
        const progress = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedProgress = easeInOutQuint(progress);
        const outputImageData = ctx.createImageData(WIDTH, HEIGHT); 
        const outputData = outputImageData.data; 
        const dataA = getPixelData(currentImage).data; 
        const dataB = getPixelData(nextImage).data;   

        // Horizontale Schaal (van 1 naar 0)
        const scaleX_A = 1 - easedProgress;
        const scaleX_B = easedProgress;

        // Verticale Scheeftrekking (Y-Skew, afhankelijk van X)
        const maxSkew = 0.4;
        const skewY_A = maxSkew * easedProgress;
        const skewY_B = maxSkew * (1 - easedProgress);

        const centerX = WIDTH / 2;
        const centerY = HEIGHT / 2;

        for (let y = 0; y < HEIGHT; y++) {
            for (let x = 0; x < WIDTH; x++) {
                const i = (y * WIDTH + x) * 4;
                
                // Inverse Horizontale Schaal
                const preSkewX_A = ((x - centerX) / scaleX_A) + centerX;
                const preSkewY_A = y;
                
                // Inverse Y-Skew
                const srcX_A = Math.round(preSkewX_A);
                const srcY_A = Math.round(preSkewY_A - (skewY_A * (preSkewX_A - centerX))); // Afhankelijk van X-afstand

                // ... (Analoge berekening voor Foto B: srcX_B en srcY_B) ...
                const preSkewX_B = ((x - centerX) / scaleX_B) + centerX;
                const preSkewY_B = y;
                const srcX_B = Math.round(preSkewX_B);
                const srcY_B = Math.round(preSkewY_B - (skewY_B * (preSkewX_B - centerX)));
                
                const alphaA = 1 - easedProgress;
                const alphaB = easedProgress;
                let r = 0, g = 0, b = 0, a = 0;
                
                // ... (Pixel ophalen en Blenden logica - analoog aan #98) ...
                if (scaleX_A > 0.01 && srcX_A >= 0 && srcX_A < WIDTH && srcY_A >= 0 && srcY_A < HEIGHT) {
                    const iA = (srcY_A * WIDTH + srcX_A) * 4;
                    r += dataA[iA] * alphaA; g += dataA[iA+1] * alphaA; b += dataA[iA+2] * alphaA; a += (dataA[iA+3]/255) * alphaA;
                }
                if (scaleX_B > 0.01 && srcX_B >= 0 && srcX_B < WIDTH && srcY_B >= 0 && srcY_B < HEIGHT) {
                    const iB = (srcY_B * WIDTH + srcX_B) * 4;
                    r += dataB[iB] * alphaB; g += dataB[iB+1] * alphaB; b += dataB[iB+2] * alphaB; a += (dataB[iB+3]/255) * alphaB;
                }

                const finalAlpha = Math.min(1, a);
                if (finalAlpha > 0) {
                    outputData[i] = Math.round(r / finalAlpha); outputData[i + 1] = Math.round(g / finalAlpha); outputData[i + 2] = Math.round(b / finalAlpha); outputData[i + 3] = Math.round(finalAlpha * 255);
                } else { outputData[i] = 0; outputData[i + 1] = 0; outputData[i + 2] = 0; outputData[i + 3] = 0; }
            }
        }
        ctx.putImageData(outputImageData, 0, 0); 
        if (uniqueState.currentFrame++ < uniqueState.totalFrames) requestAnimationFrame(animate);
        else transitionEnd(nextImage);
    }
    return { title: "Schaal & Scheeftrekking (Horizontale Compressie)", init: init, animate: animate };
})();













ANIMATION_LOGIC[98] = (function() {
    const uniqueState = { totalFrames: 100, currentFrame: 0 };
    function init() { uniqueState.currentFrame = 0; }
    function animate() {
        const progress = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedProgress = easeInOutQuint(progress);
        const outputImageData = ctx.createImageData(WIDTH, HEIGHT); 
        const outputData = outputImageData.data; 
        const dataA = getPixelData(currentImage).data; 
        const dataB = getPixelData(nextImage).data;   

        // Alpha golf midden van het scherm
        const centerAlpha = Math.sin(Math.PI * easedProgress); // Alpha is 1.0 in het midden van de transitie
        
        // Scheeftrekking factor (Skew Y afhankelijk van X)
        const maxSkew = 0.5;
        const skewY_Factor = maxSkew * centerAlpha; // Maximale skew in het midden van de transitie

        const centerX = WIDTH / 2;
        
        for (let y = 0; y < HEIGHT; y++) {
            for (let x = 0; x < WIDTH; x++) {
                const i = (y * WIDTH + x) * 4;

                // De alpha/transparantie is hier complexer: het is een 'waaier' van 1-progress tot progress
                const alphaWeight = 1 - Math.abs(easedProgress - 0.5) * 2; // Wordt 1.0 in het midden, 0.0 aan de randen

                // Scheeftrekking
                const srcX = x;
                const srcY = Math.round(y - (skewY_Factor * (x - centerX))); // Y-Skew
                
                let r = 0, g = 0, b = 0, a = 0;

                if (srcX >= 0 && srcX < WIDTH && srcY >= 0 && srcY < HEIGHT) {
                    const iSrc = (srcY * WIDTH + srcX) * 4;
                    
                    // Crossfade: Foto A en Foto B zijn beide zichtbaar
                    let rA = dataA[iSrc], gA = dataA[iSrc + 1], bA = dataA[iSrc + 2];
                    let rB = dataB[iSrc], gB = dataB[iSrc + 1], bB = dataB[iSrc + 2];
                    
                    // Sterke alpha fade in de skew zone
                    const currentAlpha = alphaWeight; 
                    
                    // Blending
                    r = rA * (1 - currentAlpha) + rB * currentAlpha;
                    g = gA * (1 - currentAlpha) + gB * currentAlpha;
                    b = bA * (1 - currentAlpha) + bB * currentAlpha;
                    a = 1.0; 
                }

                outputData[i] = Math.round(r); outputData[i + 1] = Math.round(g); outputData[i + 2] = Math.round(b); outputData[i + 3] = Math.round(a * 255);
            }
        }
        ctx.putImageData(outputImageData, 0, 0); 
        if (uniqueState.currentFrame++ < uniqueState.totalFrames) requestAnimationFrame(animate);
        else transitionEnd(nextImage);
    }
    return { title: "Transparantie & Scheeftrekking (Alpha Golf)", init: init, animate: animate };
})();










ANIMATION_LOGIC[97] = (function() {
    const uniqueState = { totalFrames: 120, currentFrame: 0 };
    function init() { uniqueState.currentFrame = 0; }
    function animate() {
        const progress = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedProgress = easeInOutQuint(progress);
        const outputImageData = ctx.createImageData(WIDTH, HEIGHT); 
        const outputData = outputImageData.data; 
        const dataA = getPixelData(currentImage).data; 
        const dataB = getPixelData(nextImage).data;   

        const maxRotation = Math.PI * 4; // Twee volledige rotaties
        const rot = maxRotation * easedProgress;

        // Maximale kleurverschuiving (360 graden)
        const maxHueShift = 360; 
        const hueShift = maxHueShift * easedProgress; 

        const centerX = WIDTH / 2;
        const centerY = HEIGHT / 2;

        for (let y = 0; y < HEIGHT; y++) {
            for (let x = 0; x < WIDTH; x++) {
                const i = (y * WIDTH + x) * 4;
                const dx = x - centerX;
                const dy = y - centerY;
                
                // Rotatie
                const cosRot = Math.cos(-rot);
                const sinRot = Math.sin(-rot);
                const srcX = Math.round(centerX + (dx * cosRot - dy * sinRot));
                const srcY = Math.round(centerY + (dx * sinRot + dy * cosRot));
                
                let r = 0, g = 0, b = 0, a = 0;

                if (srcX >= 0 && srcX < WIDTH && srcY >= 0 && srcY < HEIGHT) {
                    const iSrc = (srcY * WIDTH + srcX) * 4;
                    
                    // Alpha Blending
                    const alphaA = 1 - easedProgress;
                    const alphaB = easedProgress;
                    
                    let rA = dataA[iSrc], gA = dataA[iSrc + 1], bA = dataA[iSrc + 2];
                    let rB = dataB[iSrc], gB = dataB[iSrc + 1], bB = dataB[iSrc + 2];

                    // Kleurverschuiving op Foto A tijdens rotatie
                    // ... (RGB naar HSL, Hue aanpassen, HSL naar RGB conversie logica hier) ...
                    // Voorbeeld: [rA, gA, bA] = ApplyHueShift([rA, gA, bA], hueShift);
                    
                    r = rA * alphaA + rB * alphaB;
                    g = gA * alphaA + gB * alphaB;
                    b = bA * alphaA + bB * alphaB;
                    a = (dataA[iSrc+3]/255) * alphaA + (dataB[iSrc+3]/255) * alphaB;
                }

                const finalAlpha = Math.min(1, a);
                if (finalAlpha > 0) {
                    outputData[i] = Math.round(r / finalAlpha); outputData[i + 1] = Math.round(g / finalAlpha); outputData[i + 2] = Math.round(b / finalAlpha); outputData[i + 3] = Math.round(finalAlpha * 255);
                } else { outputData[i] = 0; outputData[i + 1] = 0; outputData[i + 2] = 0; outputData[i + 3] = 0; }
            }
        }
        ctx.putImageData(outputImageData, 0, 0); 
        if (uniqueState.currentFrame++ < uniqueState.totalFrames) requestAnimationFrame(animate);
        else transitionEnd(nextImage);
    }
    return { title: "Kleurverandering & Rotatie (Hue-Warp)", init: init, animate: animate };
})();












ANIMATION_LOGIC[96] = (function() {
    const uniqueState = { totalFrames: 100, currentFrame: 0 };
    function init() { uniqueState.currentFrame = 0; }
    function animate() {
        const progress = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedProgress = easeInOutQuint(progress);
        const outputImageData = ctx.createImageData(WIDTH, HEIGHT); 
        const outputData = outputImageData.data; 
        const dataA = getPixelData(currentImage).data; 
        const dataB = getPixelData(nextImage).data;   

        // Schaal: A zoomt uit (1.0 -> 0.1), B zoomt in (0.1 -> 1.0)
        const minScale = 0.1;
        const scaleA = lerp(1.0, minScale, easedProgress);
        const scaleB = lerp(minScale, 1.0, easedProgress);
        
        // Rotatie
        const maxRotation = Math.PI; // 180 graden
        const rotA = maxRotation * easedProgress;
        const rotB = maxRotation * (1 - easedProgress);

        const centerX = WIDTH / 2;
        const centerY = HEIGHT / 2;

        for (let y = 0; y < HEIGHT; y++) {
            for (let x = 0; x < WIDTH; x++) {
                const i = (y * WIDTH + x) * 4;
                
                // Rotatie en Schaal (omgekeerd)
                const dx = x - centerX;
                const dy = y - centerY;
                
                // A: Inverse schaal -> Inverse rotatie
                const descaledX_A = dx / scaleA;
                const descaledY_A = dy / scaleA;
                const srcX_A = Math.round(centerX + (descaledX_A * Math.cos(-rotA) - descaledY_A * Math.sin(-rotA)));
                const srcY_A = Math.round(centerY + (descaledX_A * Math.sin(-rotA) + descaledY_A * Math.cos(-rotA)));

                // B: Inverse schaal -> Inverse rotatie
                const descaledX_B = dx / scaleB;
                const descaledY_B = dy / scaleB;
                const srcX_B = Math.round(centerX + (descaledX_B * Math.cos(rotB) - descaledY_B * Math.sin(rotB)));
                const srcY_B = Math.round(centerY + (descaledX_B * Math.sin(rotB) + descaledY_B * Math.cos(rotB)));
                
                const alphaA = 1 - easedProgress;
                const alphaB = easedProgress;
                let r = 0, g = 0, b = 0, a = 0;
                
                // ... (Pixel ophalen en Blenden logica - analoog aan #98) ...
                if (scaleA > 0.01 && srcX_A >= 0 && srcX_A < WIDTH && srcY_A >= 0 && srcY_A < HEIGHT) {
                    const iA = (srcY_A * WIDTH + srcX_A) * 4;
                    r += dataA[iA] * alphaA; g += dataA[iA+1] * alphaA; b += dataA[iA+2] * alphaA; a += (dataA[iA+3]/255) * alphaA;
                }
                if (scaleB > 0.01 && srcX_B >= 0 && srcX_B < WIDTH && srcY_B >= 0 && srcY_B < HEIGHT) {
                    const iB = (srcY_B * WIDTH + srcX_B) * 4;
                    r += dataB[iB] * alphaB; g += dataB[iB+1] * alphaB; b += dataB[iB+2] * alphaB; a += (dataB[iB+3]/255) * alphaB;
                }

                const finalAlpha = Math.min(1, a);
                if (finalAlpha > 0) {
                    outputData[i] = Math.round(r / finalAlpha); outputData[i + 1] = Math.round(g / finalAlpha); outputData[i + 2] = Math.round(b / finalAlpha); outputData[i + 3] = Math.round(finalAlpha * 255);
                } else { outputData[i] = 0; outputData[i + 1] = 0; outputData[i + 2] = 0; outputData[i + 3] = 0; }
            }
        }
        ctx.putImageData(outputImageData, 0, 0); 
        if (uniqueState.currentFrame++ < uniqueState.totalFrames) requestAnimationFrame(animate);
        else transitionEnd(nextImage);
    }
    return { title: "Schaal & Rotatie (Zoom-Draai)", init: init, animate: animate };
})();








ANIMATION_LOGIC[95] = (function() {
    const uniqueState = { 
        totalFrames: 400, 
        currentFrame: 0, 
        paletteA: [],        // 11 Kleuren Palet A
        paletteB: [],        // 11 Kleuren Palet B
        avgColorA: [0, 0, 0], // Gemiddelde kleur A
        avgColorB: [0, 0, 0], // Gemiddelde kleur B
        pixelMap: null       // Cache voor de gepalettiseerde en gemapte pixels van A
    };
    const NUM_COLORS = 11;
    const HALF_WAY_FRAME = 200; 
    
    // --- FUNCTIES: Plaats houders voor de complexe stappen ---



/**
 * Berekent de gemiddelde kleur van alle pixels in de afbeelding.
 * @param {ImageData} imageData Het Canvas ImageData object.
 * @returns {number[]} [R, G, B] array van de gemiddelde kleur.
 */
function calculateAverageColor(imageData) {
    const data = imageData.data;
    let rSum = 0, gSum = 0, bSum = 0;
    let pixelCount = 0;

    // Loop over de pixeldata (R, G, B, A)
    for (let i = 0; i < data.length; i += 4) {
        rSum += data[i];
        gSum += data[i + 1];
        bSum += data[i + 2];
        pixelCount++;
    }

    if (pixelCount === 0) {
        return [0, 0, 0];
    }

    // Bereken het gemiddelde en rond af
    const rAvg = Math.round(rSum / pixelCount);
    const gAvg = Math.round(gSum / pixelCount);
    const bAvg = Math.round(bSum / pixelCount);

    return [rAvg, gAvg, bAvg];
}


/**
 * Vindt de dichtstbijzijnde kleur in een palet met behulp van Euclidische afstand.
 * @param {number[]} rgbColor [R, G, B] van de kleur die gemapt moet worden.
 * @param {number[][]} palette Array van [R, G, B] kleuren in het palet.
 * @returns {number[]} De [R, G, B] array van de dichtstbijzijnde kleur.
 */
function findNearestColor(rgbColor, palette) {
    if (palette.length === 0) return [0, 0, 0];

    let minDistanceSq = Infinity;
    let nearestColor = palette[0];

    const r1 = rgbColor[0], g1 = rgbColor[1], b1 = rgbColor[2];

    for (const color of palette) {
        const r2 = color[0], g2 = color[1], b2 = color[2];

        // Bereken het kwadraat van de Euclidische afstand: (r1-r2)^2 + (g1-g2)^2 + (b1-b2)^2
        // We gebruiken het kwadraat om de dure Math.sqrt() te vermijden
        const distanceSq = (r1 - r2) ** 2 + (g1 - g2) ** 2 + (b1 - b2) ** 2;

        if (distanceSq < minDistanceSq) {
            minDistanceSq = distanceSq;
            nearestColor = color;
        }
    }

    return nearestColor;
}


/**
 * Genereert een palet van dominante kleuren met behulp van een vereenvoudigde kwantisatie.
 * Dit is een vereenvoudiging van geavanceerde algoritmes (K-Means/Octree).
 * @param {ImageData} imageData Het Canvas ImageData object.
 * @param {number} numColors Het gewenste aantal kleuren (bijv. 11).
 * @returns {number[][]} Een array van [R, G, B] kleuren die het palet vormen.
 */
function getPalette(imageData, numColors) {
    const data = imageData.data;
    const colorFrequency = new Map();
    const step = 32; // Verdeel 256 kleurwaarden in 8 stappen (256/32)

    // 1. Verzamel de frequentie van gekwantiseerde kleuren ('buckets')
    for (let i = 0; i < data.length; i += 4) {
        // Quantiseer elke component naar de dichtstbijzijnde 'bucket' (veelvouden van 32)
        const qr = Math.floor(data[i] / step) * step;
        const qg = Math.floor(data[i + 1] / step) * step;
        const qb = Math.floor(data[i + 2] / step) * step;
        
        // De gekwantiseerde kleur (string-sleutel)
        const key = `${qr},${qg},${qb}`;
        
        // Tel de frequentie
        colorFrequency.set(key, (colorFrequency.get(key) || 0) + 1);
    }

    // 2. Sorteer de 'buckets' op frequentie
    const sortedFrequencies = Array.from(colorFrequency.entries())
        .sort((a, b) => b[1] - a[1]); // Sorteer aflopend op frequentie

    // 3. Selecteer de tophoeveelheid en converteer de sleutel terug naar een kleurarray
    const palette = [];
    for (let i = 0; i < Math.min(numColors, sortedFrequencies.length); i++) {
        const key = sortedFrequencies[i][0];
        const color = key.split(',').map(Number); // [qr, qg, qb]
        
        // Gebruik het midden van de 'bucket' voor een betere kleurrepresentatie
        palette.push([color[0] + step / 2, color[1] + step / 2, color[2] + step / 2].map(Math.round));
    }
    
    // Zorg ervoor dat er altijd numColors worden geretourneerd (vul aan met de topkleur indien nodig)
    while (palette.length < numColors) {
        if (palette.length > 0) {
            palette.push([...palette[0]]); // Kopieer de dominante kleur
        } else {
            palette.push([0, 0, 0]); // Vul aan met zwart als de afbeelding leeg is
        }
    }

    return palette;
}
    
    // Lineaire interpolatie
    function lerp(a, b, t) {
        return a + (b - a) * t;
    }
    
    // --- INITILE ANALYSE ---

    function init() {
        uniqueState.currentFrame = 0;
        
        // Aanname: imageDataA_full en imageDataB_full zijn CanvasImageData objecten
        const imageDataA_full = ctx.getImageData(0,0,WIDTH,HEIGHT);
        const imageDataB_full = ctx.getImageData(0,0,WIDTH,HEIGHT); 
        const dataA = getPixelData(currentImage).data;

        // 1. Kleuranalyse
        uniqueState.paletteA = getPalette(imageDataA_full, NUM_COLORS);
        uniqueState.paletteB = getPalette(imageDataB_full, NUM_COLORS);
        uniqueState.avgColorA = calculateAverageColor(imageDataA_full);
        uniqueState.avgColorB = calculateAverageColor(imageDataB_full);

        // 2. Initialiseer de Pixel Map (De bron van alle beweging)
        // Deze structuur moet voor elke pixel in het beeld bepalen:
        // { x, y, r, g, b, a, mappedColorVector }
        uniqueState.pixelMap = new Array(WIDTH * HEIGHT);
        
        for (let y = 0; y < HEIGHT; y++) {
            for (let x = 0; x < WIDTH; x++) {
                const i = (y * WIDTH + x) * 4;
                const r = dataA[i], g = dataA[i + 1], b = dataA[i + 2], a = dataA[i + 3];
                
                // Vind de 11-kleuren paletkleur voor deze pixel
                const mappedColor = findNearestColor([r, g, b], uniqueState.paletteA);

                // RGB -> Vector mapping: [R=ForceX, G=ForceY, B=Velocity/MaxShift]
                // Normaliseer de kleurcomponenten (0-255) naar een bruikbare vectorgrootte
                const maxShift = Math.max(WIDTH, HEIGHT); // Maximale verschuiving = grootste dimensie
                
                const forceX = (mappedColor[0] / 255.0) * maxShift; // Max X shift
                const forceY = (mappedColor[1] / 255.0) * maxShift; // Max Y shift
                const velocity = (mappedColor[2] / 255.0); // Bepaalt de totale afgelegde afstand

                uniqueState.pixelMap[y * WIDTH + x] = {
                    srcX: x, 
                    srcY: y, 
                    color: [r, g, b, a],
                    // De vector bepaalt hoe ver en in welke richting de pixel beweegt
                    vectorX: forceX * velocity,
                    vectorY: forceY * velocity
                };
            }
        }
    }

    // --- ANIMATIE LOGICA ---

    function animate() {
        const outputImageData = ctx.createImageData(WIDTH, HEIGHT); 
        const outputData = outputImageData.data; 
        
        const progress = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedProgress = easeInOutQuint(progress);

        // Bepaal de achtergrondkleur (Gemiddelde kleur A in fase 1, Gemiddelde kleur B in fase 2)
        const bgColor = uniqueState.currentFrame < HALF_WAY_FRAME ? uniqueState.avgColorA : uniqueState.avgColorB;
        
        // Vul de output met de gemiddelde achtergrondkleur
        for (let i = 0; i < WIDTH * HEIGHT * 4; i += 4) {
            outputData[i] = bgColor[0];
            outputData[i + 1] = bgColor[1];
            outputData[i + 2] = bgColor[2];
            outputData[i + 3] = 255;
        }

        // --- FASE 1: DESINTEGRATIE (0 tot 50) ---
        if (uniqueState.currentFrame < HALF_WAY_FRAME) {
            const phaseProgress = easedProgress * 2; // Loopt van 0 tot 1
            const dataA = getPixelData(currentImage).data; 
            
            // Loop over de pixel Map (gebaseerd op Afbeelding A)
            for (let idx = 0; idx < uniqueState.pixelMap.length; idx++) {
                const pixel = uniqueState.pixelMap[idx];
                
                // Bereken de huidige verschuiving
                const currentShiftX = pixel.vectorX * phaseProgress;
                const currentShiftY = pixel.vectorY * phaseProgress;
                
                // Bepaal de nieuwe positie
                const destX = Math.round(pixel.srcX + currentShiftX);
                const destY = Math.round(pixel.srcY + currentShiftY);
                
                // Teken de pixel op de nieuwe positie
                if (destX >= 0 && destX < WIDTH && destY >= 0 && destY < HEIGHT) {
                    const outputIdx = (destY * WIDTH + destX) * 4;
                    // Gebruik de originele kleur van de bronpixel
                    outputData[outputIdx]     = pixel.color[0];
                    outputData[outputIdx + 1] = pixel.color[1];
                    outputData[outputIdx + 2] = pixel.color[2];
                    
                    // Alpha-fade is optioneel, maar we laten de alpha hoog
                    outputData[outputIdx + 3] = pixel.color[3];
                }
            }
        } 
        // --- FASE 2: RECONSTRUCTIE (50 tot 100) ---
        else {
            const phaseProgress = (easedProgress - 0.5) * 2; // Loopt van 0 tot 1
            const dataB = getPixelData(nextImage).data; 
            
            // De omgekeerde beweging vereist dat we de pixels van Afbeelding B binnenzuigen.
            // Hiervoor moeten we een Pixel Map voor B maken (of de B-data in real-time verwerken).
            // Laten we de B-data in real-time verwerken, gebaseerd op de A-mapping.
            
            for (let y = 0; y < HEIGHT; y++) {
                for (let x = 0; x < WIDTH; x++) {
                    const srcIdx = y * WIDTH + x;
                    const i = srcIdx * 4;
                    
                    const r = dataB[i], g = dataB[i + 1], b = dataB[i + 2], a = dataB[i + 3];
                    
                    // 1. Vind de paletkleur en de bijbehorende vector voor Afbeelding B
                    const mappedColor = findNearestColor([r, g, b], uniqueState.paletteB);

                    const maxShift = Math.max(WIDTH, HEIGHT); 
                    const forceX = (mappedColor[0] / 255.0) * maxShift; 
                    const forceY = (mappedColor[1] / 255.0) * maxShift; 
                    const velocity = (mappedColor[2] / 255.0); 
                    
                    const vectorX = forceX * velocity;
                    const vectorY = forceY * velocity;

                    // 2. De pixels van B moeten van de buitenkant naar de startpositie (x, y) bewegen.
                    // De verschuiving neemt af van 1.0 naar 0.0
                    const currentShiftX = vectorX * (1 - phaseProgress);
                    const currentShiftY = vectorY * (1 - phaseProgress);
                    
                    // 3. De startpositie ligt buiten beeld, we bewegen naar de doelpositie (x, y)
                    const startX_out = x + vectorX; // Bepaalde startpunt buiten beeld
                    const startY_out = y + vectorY; 

                    // Nieuwe positie: beweeg van startX_out naar X (doel)
                    const destX = Math.round(lerp(startX_out, x, phaseProgress));
                    const destY = Math.round(lerp(startY_out, y, phaseProgress));
                    
                    // 4. Teken de pixel op de nieuwe positie
                    if (destX >= 0 && destX < WIDTH && destY >= 0 && destY < HEIGHT) {
                        const outputIdx = (destY * WIDTH + destX) * 4;
                        outputData[outputIdx]     = r;
                        outputData[outputIdx + 1] = g;
                        outputData[outputIdx + 2] = b;
                        outputData[outputIdx + 3] = a;
                    }
                }
            }
        }
           
        ctx.putImageData(outputImageData, 0, 0);

        if (uniqueState.currentFrame++ < uniqueState.totalFrames) {
            requestAnimationFrame(animate);
        } else {
            transitionEnd(nextImage);
        }
    }
    
    return { title: "RGB-Vector Pixel Dispersie", init: init, animate: animate };
})();




ANIMATION_LOGIC[103] = (function() {
    const uniqueState = { totalFrames: 100, currentFrame: 0 };
    function init() { uniqueState.currentFrame = 0; }
    function animate() {
        const progress = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedProgress = easeInOutQuint(progress);
        const outputImageData = ctx.createImageData(WIDTH, HEIGHT); 
        const outputData = outputImageData.data; 
        const dataA = getPixelData(currentImage).data; 
        const dataB = getPixelData(nextImage).data;   

        // Horizontale Translatie
        const maxShift = WIDTH;
        const shiftX_A = maxShift * easedProgress;
        const shiftX_B = maxShift * (1 - easedProgress);

        // Verticale Scheeftrekking (Skew Y)
        const maxSkew = 0.5;
        // Skew is maximaal in het midden (simuleert de zijkant van de kaart)
        const skewFactor = maxSkew * Math.sin(Math.PI * easedProgress); 

        const centerX = WIDTH / 2;
        
        for (let y = 0; y < HEIGHT; y++) {
            for (let x = 0; x < WIDTH; x++) {
                const i = (y * WIDTH + x) * 4;
                
                // Inverse Translatie
                const preSkewX_A = x - shiftX_A;
                const preSkewX_B = x - shiftX_B;

                // Inverse Y-Skew (Skew y = skewFactor * x)
                const srcX_A = Math.round(preSkewX_A);
                const srcY_A = Math.round(y - (skewFactor * (preSkewX_A - centerX)));

                const srcX_B = Math.round(preSkewX_B);
                const srcY_B = Math.round(y - (skewFactor * (preSkewX_B - centerX)));
                
                const alphaA = 1 - easedProgress;
                const alphaB = easedProgress;
                let r = 0, g = 0, b = 0, a = 0;
                
                // ... (Pixel ophalen en Blenden logica - analoog aan #98) ...
                if (alphaA > 0.01 && srcX_A >= 0 && srcX_A < WIDTH && srcY_A >= 0 && srcY_A < HEIGHT) {
                    const iA = (srcY_A * WIDTH + srcX_A) * 4;
                    r += dataA[iA] * alphaA; g += dataA[iA+1] * alphaA; b += dataA[iA+2] * alphaA; a += (dataA[iA+3]/255) * alphaA;
                }
                if (alphaB > 0.01 && srcX_B >= 0 && srcX_B < WIDTH && srcY_B >= 0 && srcY_B < HEIGHT) {
                    const iB = (srcY_B * WIDTH + srcX_B) * 4;
                    r += dataB[iB] * alphaB; g += dataB[iB+1] * alphaB; b += dataB[iB+2] * alphaB; a += (dataB[iB+3]/255) * alphaB;
                }

                const finalAlpha = Math.min(1, a);
                if (finalAlpha > 0) {
                    outputData[i] = Math.round(r / finalAlpha); outputData[i + 1] = Math.round(g / finalAlpha); outputData[i + 2] = Math.round(b / finalAlpha); outputData[i + 3] = Math.round(finalAlpha * 255);
                } else { outputData[i] = 0; outputData[i + 1] = 0; outputData[i + 2] = 0; outputData[i + 3] = 0; }
            }
        }
        ctx.putImageData(outputImageData, 0, 0); 
        if (uniqueState.currentFrame++ < uniqueState.totalFrames) requestAnimationFrame(animate);
        else transitionEnd(nextImage);
    }
    return { title: "Translatie & Scheeftrekking (Kaart Flip)", init: init, animate: animate };
})();


















    // --- Initial Setup and Start ---
    onload = function() {
        canvas = document.getElementById('animationCanvas');
        ctx = canvas.getContext('2d');

        // Ensure the global ANIMATION_INDEX is a valid starting index
        if (ANIMATION_LOGIC[ANIMATION_INDEX % TOTAL_ANIMATIONS]) {
           // Request the first two images (A and B) to start the loop
           requestRandom(0);
        } else {
           // Fallback to the first defined animation if the chosen start index is empty
           ANIMATION_INDEX = 0;
           requestRandom(0);
        }
    };


/*

// --- COMMON UTILITY FUNCTIONS (REQUIRED FOR ALL ANIMATIONS) ---

// Linear Interpolation
const lerp = (a, b, t) => a + (b - a) * t;

// Quintic Ease In/Out (Standard Easing Function)
const easeInOutQuint = t => t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t;
*/
// Helper to draw the image to cover the canvas (adapted from 02_3649.html)
// This function calculates the correct scale and position to ensure the image covers the canvas without stretching.
function drawCoverImage(img, ctx, canvas, alpha = 1) {
    if (!img) return { x: 0, y: 0, w: 0, h: 0 };
    const canvasWidth = canvas.width;
    const canvasHeight = canvas.height;
    const imgRatio = img.width / img.height;
    const canvasRatio = canvasWidth / canvasHeight;
    let dx, dy, dw, dh;

    if (imgRatio > canvasRatio) { // Image is wider than canvas
        dh = canvasHeight;
        dw = canvasHeight * imgRatio;
        dx = (canvasWidth - dw) / 2;
        dy = 0;
    } else { // Image is taller or same ratio
        dw = canvasWidth;
        dh = canvasWidth / imgRatio;
        dx = 0;
        dy = (canvasHeight - dh) / 2;
    }

    ctx.globalAlpha = alpha;
    ctx.drawImage(img, 0, 0, img.width, img.height, dx, dy, dw, dh);
    ctx.globalAlpha = 1; // Reset alpha
    return { x: dx, y: dy, w: dw, h: dh };
}

// Placeholder for pixel data functions (assumed globally defined in your original setup)
// function getPixelData(img) { /* ... implementation to get ImageData ... */ }
// function putImageData(imageData) { /* ... implementation to put ImageData ... */ }

// --- ANIMATION LOGIC STARTING FROM INDEX 102 ---

// ------------------------------------
// EXTRACTED FROM 02_3649.html (7 Animations: 102-108)
// ------------------------------------

// --- 1. Vertical Wipe Slide (Index 102) ---
ANIMATION_LOGIC[1020] = (function() {
    const uniqueState = { totalFramesbb: 120, currentFramebb: 0, numSlices: 20 };
    function init() { uniqueState.currentFramebb = 0; }
    function animate() {
        const t = uniqueState.currentFramebb / uniqueState.totalFramesbb;
        const easedT = easeInOutQuint(t);
       
        const imgProps1 = drawCoverImage(currentImage, ctx, canvas, 0); // Get properties
        
        const slideAmount = easedT * imgProps1.w;
        const sliceHeight = imgProps1.h / uniqueState.numSlices;

        drawCoverImage(nextImage, ctx, canvas, 1); // Draw Image 2 first

        for (let i = 0; i < uniqueState.numSlices; i++) {
            const yPos = imgProps1.y + i * sliceHeight;
            const currentSlide = i % 2 === 0 ? slideAmount : -slideAmount;

            if (currentImage) {
                ctx.save();
                ctx.beginPath();
                ctx.rect(imgProps1.x, yPos, imgProps1.w, sliceHeight);
                ctx.clip();
                ctx.translate(currentSlide, 0); // Apply slide
                drawCoverImage(currentImage, ctx, canvas, 1);
                ctx.restore();
            }
        }
        
        if (uniqueState.currentFramebb < uniqueState.totalFramesbb) {
            uniqueState.currentFramebb++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, canvas.width, canvas.height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();

// --- 2. Pixelation/Block-based (Index 103) ---
ANIMATION_LOGIC[103] = (function() {
    const uniqueState = { totalFramesbb: 120, currentFramebb: 0, pixelSizeStart: 1, pixelSizeEnd: 50 };
    function init() { uniqueState.currentFramebb = 0; }
    function animate() {
        const t = uniqueState.currentFramebb / uniqueState.totalFramesbb;
        const easedT = easeInOutQuint(t);
       
        
        const pixelS = Math.round(lerp(uniqueState.pixelSizeStart, uniqueState.pixelSizeEnd, easedT < 0.5 ? easedT * 2 : (1 - easedT) * 2));
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (pixelS <= 1) { 
            drawCoverImage(easedT < 0.5 ? currentImage : nextImage, ctx, canvas, 1);
        } else {
            ctx.imageSmoothingEnabled = false; 
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width / pixelS;
            tempCanvas.height = canvas.height / pixelS;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.imageSmoothingEnabled = false; 

            if (t <= 0.5) {
                tempCtx.globalAlpha = lerp(1, 0, easedT * 2);
                drawCoverImage(currentImage, tempCtx, tempCanvas, 1);
                ctx.drawImage(tempCanvas, 0, 0, canvas.width, canvas.height);
            }
            if (t >= 0.5) {
                tempCtx.globalAlpha = lerp(0, 1, (easedT - 0.5) * 2);
                tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
                drawCoverImage(nextImage, tempCtx, tempCanvas, 1);
                ctx.drawImage(tempCanvas, 0, 0, canvas.width, canvas.height);
            }
        }
        
        if (uniqueState.currentFramebb < uniqueState.totalFramesbb) {
            uniqueState.currentFramebb++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, canvas.width, canvas.height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();

// --- 4. Radial Warp / Zoom (Index 105) ---
ANIMATION_LOGIC[105] = (function() {
    const uniqueState = { totalFramesbb: 120, currentFramebb: 0 };
    function init() { uniqueState.currentFramebb = 0; }
    function animate() {
        const t = uniqueState.currentFramebb / uniqueState.totalFramesbb;
        const easedT = easeInOutQuint(t);
       
        const canvasW = WIDTH; const  canvasH = HEIGHT;

        ctx.clearRect(0, 0, canvasW, canvasH);
        
        if (t <= 0.5) {
            ctx.save();
            const progress = easedT * 2;
            const scale = lerp(1, 0.1, progress);
            const alpha = lerp(1, 0, progress);
            
            ctx.globalAlpha = alpha;
            ctx.translate(canvasW / 2, canvasH / 2);
            ctx.scale(scale, scale);
            ctx.rotate(progress * Math.PI);
            ctx.translate(-canvasW / 2, -canvasH / 2);
            drawCoverImage(currentImage, ctx, canvas, 1);
            ctx.restore();
        }

        if (t >= 0.5) {
            ctx.save();
            const progress = (easedT - 0.5) * 2;
            const scale = lerp(0.1, 1, progress);
            const alpha = lerp(0, 1, progress);
            
            ctx.globalAlpha = alpha;
            ctx.translate(canvasW / 2, canvasH / 2);
            ctx.scale(scale, scale);
            ctx.rotate((1 - progress) * -Math.PI);
            ctx.translate(-canvasW / 2, -canvasH / 2);
            drawCoverImage(nextImage, ctx, canvas, 1);
            ctx.restore();
        }
        
        if (uniqueState.currentFramebb < uniqueState.totalFramesbb) {
            uniqueState.currentFramebb++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, canvasW, canvasH);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();

// --- 5. Kaleidoscope-like Zoom (Index 106) ---
ANIMATION_LOGIC[106] = (function() {
    const uniqueState = { totalFramesbb: 120, currentFramebb: 0, maxScale: 2.0 };
    function init() { uniqueState.currentFramebb = 0; }
    function animate() {
        const t = uniqueState.currentFramebb / uniqueState.totalFramesbb;
        const easedT = easeInOutQuint(t);
       
        const canvasW = WIDTH; const  canvasH = HEIGHT;

        ctx.clearRect(0, 0, canvasW, canvasH);
        
        // Image 1: Zoom in and fade out
        ctx.save();
        const scale1 = lerp(1, uniqueState.maxScale, easedT);
        const alpha1 = lerp(1, 0, easedT);
        ctx.globalAlpha = alpha1;
        ctx.translate(canvasW / 2, canvasH / 2);
        ctx.scale(scale1, scale1);
        ctx.translate(-canvasW / 2, -canvasH / 2);
        drawCoverImage(currentImage, ctx, canvas, 1);
        ctx.restore();

        // Image 2: Zoom out and fade in
        ctx.save();
        const scale2 = lerp(uniqueState.maxScale, 1, easedT);
        const alpha2 = lerp(0, 1, easedT);
        ctx.globalAlpha = alpha2;
        ctx.translate(canvasW / 2, canvasH / 2);
        ctx.scale(scale2, scale2);
        ctx.translate(-canvasW / 2, -canvasH / 2);
        drawCoverImage(nextImage, ctx, canvas, 1);
        ctx.restore();

        // Overlay radial mask for tunnel effect
        if (t > 0.4 && t < 0.6) {
            ctx.save();
            const radius = lerp(0, Math.max(canvasW, canvasH) * 0.7, Math.sin(easedT * Math.PI));
            const gradient = ctx.createRadialGradient(canvasW / 2, canvasH / 2, 0, canvasW / 2, canvasH / 2, radius);
            gradient.addColorStop(0, `rgba(0, 0, 0, ${1 - Math.abs(t - 0.5) * 2})`);
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvasW, canvasH);
            ctx.restore();
        }

        if (uniqueState.currentFramebb < uniqueState.totalFramesbb) {
            uniqueState.currentFramebb++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, canvasW, canvasH);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();

// --- 6. Tile Scramble (Index 107) ---
ANIMATION_LOGIC[107] = (function() {
    const uniqueState = { totalFramesbb: 120, currentFramebb: 0, tiles: [], numX: 10, numY: 8, initialized: false };
    
    function initializeTiles(canvas) {
        uniqueState.tiles = [];
        const canvasW = WIDTH; const  canvasH = HEIGHT;
        const pieceW = canvasW / uniqueState.numX;
        const pieceH = canvasH / uniqueState.numY;
        
        for (let y = 0; y < uniqueState.numY; y++) {
            for (let x = 0; x < uniqueState.numX; x++) {
                uniqueState.tiles.push({
                    x: x * pieceW, y: y * pieceH, w: pieceW, h: pieceH,
                    randomOffsetX: Math.random(), randomOffsetY: Math.random(),
                    randomSpin: (Math.random() - 0.5) * 2
                });
            }
        }
        uniqueState.initialized = true;
    }

    function init() { 
        uniqueState.currentFramebb = 0;
        initializeTiles(canvas, currentImage);
    }
    
    function animate() {
        if (!uniqueState.initialized) { init(); }
        
        const t = uniqueState.currentFramebb / uniqueState.totalFramesbb;
        const easedT = easeInOutQuint(t);
       
        const canvasW = WIDTH; const  canvasH = HEIGHT;

        ctx.clearRect(0, 0, canvasW, canvasH);
        
        const scatterStrength = lerp(0, Math.min(canvasW, canvasH) * 0.5, Math.sin(easedT * Math.PI));
        const rotationAngle = lerp(0, Math.PI * 4, easedT);

        uniqueState.tiles.forEach(tile => {
            const translateX = (tile.randomOffsetX - 0.5) * scatterStrength;
            const translateY = (tile.randomOffsetY - 0.5) * scatterStrength;
            
            ctx.save();
            ctx.globalAlpha = Math.sin(easedT * Math.PI);
            
            ctx.translate(tile.x + tile.w / 2, tile.y + tile.h / 2);
            ctx.rotate(tile.randomSpin * rotationAngle);
            ctx.translate(translateX, translateY);
            
            if (t < 0.5) {
                ctx.drawImage(currentImage, tile.x, tile.y, tile.w, tile.h, -tile.w / 2, -tile.h / 2, tile.w, tile.h);
            }
            if (t >= 0.5) {
                ctx.drawImage(nextImage, tile.x, tile.y, tile.w, tile.h, -tile.w / 2, -tile.h / 2, tile.w, tile.h);
            }
            
            ctx.restore();
        });
        
        if (uniqueState.currentFramebb < uniqueState.totalFramesbb) {
            uniqueState.currentFramebb++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, canvasW, canvasH);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();

// --- 7. RGB Split/Jitter (Index 108) ---
ANIMATION_LOGIC[108] = (function() {
    const uniqueState = { totalFramesbb: 120, currentFramebb: 0 };
    function init() { uniqueState.currentFramebb = 0; }
    function animate() {
        const t = uniqueState.currentFramebb / uniqueState.totalFramesbb;
        const easedT = easeInOutQuint(t);
       
        const canvasW = WIDTH; const  canvasH = HEIGHT;

        ctx.clearRect(0, 0, canvasW, canvasH);
        
        const maxOffset = 20; 
        const offset = lerp(0, maxOffset, Math.sin(easedT * Math.PI));
        const alphaSplit = lerp(1, 0, easedT * 2);
        const alphaMerge = lerp(0, 1, (easedT - 0.5) * 2);

        // Draw Image 2 first as background, fading in
        ctx.globalAlpha = alphaMerge;
        drawCoverImage(nextImage, ctx, canvas, 1);
        
        // Draw Image 1 with RGB split effect (fading out)
        if (t < 0.5) {
            ctx.globalAlpha = alphaSplit;

            // R, G, B channels with offsets and lighter composite
            ctx.globalCompositeOperation = 'lighter';
            
            // Red channel (offset)
            ctx.save();
            ctx.filter = 'hue-rotate(0deg) saturate(1)'; 
            ctx.translate(offset, 0);
            drawCoverImage(currentImage, ctx, canvas, 1);
            ctx.restore();

            // Green channel (center)
            ctx.save();
            ctx.filter = 'hue-rotate(120deg) saturate(1)';
            drawCoverImage(currentImage, ctx, canvas, 1);
            ctx.restore();

            // Blue channel (-offset)
            ctx.save();
            ctx.filter = 'hue-rotate(240deg) saturate(1)';
            ctx.translate(-offset, 0);
            drawCoverImage(currentImage, ctx, canvas, 1);
            ctx.restore();
            
            ctx.globalCompositeOperation = 'source-over'; // Reset blend mode
        }

        if (uniqueState.currentFramebb < uniqueState.totalFramesbb) {
            uniqueState.currentFramebb++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, canvasW, canvasH);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();

// ------------------------------------
// EXTRACTED FROM 02_3920.html (1 Animation: 109)
// ------------------------------------

// --- 8. Morphing Spin/Shear (Index 109) ---
ANIMATION_LOGIC[109] = (function() {
    const uniqueState = { totalFramesbb: 120, currentFramebb: 0 };
    function init() { uniqueState.currentFramebb = 0; }
    function animate() {
        const t = uniqueState.currentFramebb / uniqueState.totalFramesbb;
        const easedT = easeInOutQuint(t);
       
        const canvasW = WIDTH; const  canvasH = HEIGHT;

        ctx.clearRect(0, 0, canvasW, canvasH);
        
        // Image 1: Fades out, rotates, shears
        ctx.save();
        const rot1 = lerp(0, Math.PI / 2, easedT);
        const shearX1 = lerp(0, 0.5, easedT);
        const scale1 = lerp(1, 0.8, easedT);
        const alpha1 = lerp(1, 0, easedT);

        ctx.globalAlpha = alpha1;
        ctx.translate(canvasW / 2, canvasH / 2);
        ctx.rotate(rot1);
        ctx.transform(1, 0, shearX1, 1, 0, 0); 
        ctx.scale(scale1, scale1);
        ctx.translate(-canvasW / 2, -canvasH / 2);
        drawCoverImage(currentImage, ctx, canvas, 1);
        ctx.restore();

        // Image 2: Fades in, un-shears, un-rotates
        ctx.save();
        const rot2 = lerp(-Math.PI / 2, 0, easedT);
        const shearX2 = lerp(-0.5, 0, easedT);
        const scale2 = lerp(0.8, 1, easedT);
        const alpha2 = lerp(0, 1, easedT);

        ctx.globalAlpha = alpha2;
        ctx.translate(canvasW / 2, canvasH / 2);
        ctx.rotate(rot2);
        ctx.transform(1, 0, shearX2, 1, 0, 0);
        ctx.scale(scale2, scale2);
        ctx.translate(-canvasW / 2, -canvasH / 2);
        drawCoverImage(nextImage, ctx, canvas, 1);
        ctx.restore();

        if (uniqueState.currentFramebb < uniqueState.totalFramesbb) {
            uniqueState.currentFramebb++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, canvasW, canvasH);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();

// ------------------------------------
// EXTRACTED FROM 02_5363.html (1 Animation: 110)
// ------------------------------------

// --- 9. Combined Dynamic Transformation (Index 110) ---
ANIMATION_LOGIC[110] = (function() {
    const uniqueState = { totalFramesbb: 120, currentFramebb: 0, 
        xTrans: 0, yTrans: 0, rotation: 0, scale: 0, shear: 0
    };
    function init() { 
        uniqueState.currentFramebb = 0;
        // Re-calculate random parameters on init
        uniqueState.xTrans = (Math.random() - 0.5) * 400; 
        uniqueState.yTrans = (Math.random() - 0.5) * 300;
        uniqueState.rotation = (Math.random() - 0.5) * Math.PI;
        uniqueState.scale = 1 + Math.random() * 0.5;
        uniqueState.shear = (Math.random() - 0.5) * 0.5;
    }
    function animate() {
        const t = uniqueState.currentFramebb / uniqueState.totalFramesbb;
        const easedT = easeInOutQuint(t);
       
        const canvasW = WIDTH; const  canvasH = HEIGHT;

        ctx.clearRect(0, 0, canvasW, canvasH);

        // --- Image 1: Disperse and Transform (Fade Out) ---
        ctx.save();
        const progress1 = easedT;
        const alpha1 = lerp(1, 0, progress1);
        
        ctx.globalAlpha = alpha1;
        
        const currentXTrans = uniqueState.xTrans * progress1;
        const currentYTrans = uniqueState.yTrans * progress1;
        const currentScale1 = lerp(1, 1 / uniqueState.scale, progress1);
        const currentRotation1 = uniqueState.rotation * progress1;
        
        ctx.translate(canvasW / 2 + currentXTrans, canvasH / 2 + currentYTrans);
        ctx.rotate(currentRotation1);
        ctx.scale(currentScale1, currentScale1);
        ctx.translate(-canvasW / 2, -canvasH / 2);
        
        drawCoverImage(currentImage, ctx, canvas, 1);
        ctx.restore();

        // --- Image 2: Coalesce and Transform (Fade In) ---
        ctx.save();
        const progress2 = 1 - easedT;
        const alpha2 = lerp(0, 1, easedT);
        
        ctx.globalAlpha = alpha2;

        const currentXTrans2 = uniqueState.xTrans * progress2;
        const currentYTrans2 = uniqueState.yTrans * progress2;
        const currentScale2 = lerp(uniqueState.scale, 1, easedT);
        const currentRotation2 = uniqueState.rotation * progress2;
        
        ctx.translate(canvasW / 2 - currentXTrans2, canvasH / 2 - currentYTrans2);
        ctx.rotate(-currentRotation2);
        ctx.scale(currentScale2, currentScale2);
        ctx.translate(-canvasW / 2, -canvasH / 2);
        
        drawCoverImage(nextImage, ctx, canvas, 1);
        ctx.restore();

        if (uniqueState.currentFramebb < uniqueState.totalFramesbb) {
            uniqueState.currentFramebb++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, canvasW, canvasH);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();

// ------------------------------------
// EXTRACTED FROM 02_6122.html (1 Animation: 111)
// ------------------------------------

// --- 10. Fragmented Morph (Index 111) ---
ANIMATION_LOGIC[111] = (function() {
    const uniqueState = { totalFramesbb: 120, currentFramebb: 0, fragments: [], numX: 15, numY: 10, initialized: false };
    
    function initializeFragments(canvas) {
        uniqueState.fragments = [];
        const canvasW = WIDTH; const  canvasH = HEIGHT;
        const fragW = canvasW / uniqueState.numX;
        const fragH = canvasH / uniqueState.numY;
        
        for (let y = 0; y < uniqueState.numY; y++) {
            for (let x = 0; x < uniqueState.numX; x++) {
                uniqueState.fragments.push({
                    x: x * fragW, y: y * fragH, w: fragW, h: fragH,
                    finalX: (Math.random() - 0.5) * 500,
                    finalY: (Math.random() - 0.5) * 500,
                    finalRot: (Math.random() - 0.5) * Math.PI * 2,
                    initialDelay: Math.random()
                });
            }
        }
        uniqueState.initialized = true;
    }

    function init() { 
        uniqueState.currentFramebb = 0;
        initializeFragments(canvas);
    }
    
    function animate() {
        if (!uniqueState.initialized) { init(); }
        
        const t = uniqueState.currentFramebb / uniqueState.totalFramesbb;
        const easedT = easeInOutQuint(t);
       
        const canvasW = WIDTH; const  canvasH = HEIGHT;

        ctx.clearRect(0, 0, canvasW, canvasH);

        uniqueState.fragments.forEach(frag => {
            const delayT = Math.max(0, Math.min(1, (easedT - frag.initialDelay * 0.3) * 1.5));
            const invDelayT = 1 - delayT;

            // --- Draw Image 1 (Scattering) ---
            if (delayT < 1) {
                ctx.save();
                
                const alpha = invDelayT;
                const rot = frag.finalRot * invDelayT;
                const scale = lerp(1, 0.5, invDelayT);
                const cx = frag.x + frag.w / 2;
                const cy = frag.y + frag.h / 2;
                const translateX = frag.finalX * delayT;
                const translateY = frag.finalY * delayT;

                ctx.globalAlpha = alpha;
                ctx.translate(cx + translateX, cy + translateY);
                ctx.rotate(rot);
                ctx.scale(scale, scale);
                
                ctx.drawImage(currentImage, frag.x, frag.y, frag.w, frag.h, -frag.w / 2, -frag.h / 2, frag.w, frag.h);
                
                ctx.restore();
            }

            // --- Draw Image 2 (Coalescing) ---
            if (delayT > 0) {
                ctx.save();

                const alpha = delayT;
                const rot = frag.finalRot * delayT;
                const scale = lerp(0.5, 1, delayT);
                const cx = frag.x + frag.w / 2;
                const cy = frag.y + frag.h / 2;
                const translateX = frag.finalX * (1 - delayT);
                const translateY = frag.finalY * (1 - delayT);

                ctx.globalAlpha = alpha;
                ctx.translate(cx - translateX, cy - translateY);
                ctx.rotate(-rot);
                ctx.scale(scale, scale);
                
                ctx.drawImage(nextImage, frag.x, frag.y, frag.w, frag.h, -frag.w / 2, -frag.h / 2, frag.w, frag.h);
                
                ctx.restore();
            }

        });

        if (uniqueState.currentFramebb < uniqueState.totalFramesbb) {
            uniqueState.currentFramebb++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, canvasW, canvasH);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();

// ------------------------------------
// EXTRACTED FROM 02_6272.html (13 Animations: 112-124)
// ------------------------------------

// --- 11. Dissolve & Distort (Index 112) ---
ANIMATION_LOGIC[112] = (function() {
    const uniqueState = { totalFramesbb: 120, currentFramebb: 0 };
    function init() { uniqueState.currentFramebb = 0; }
    function animate() {
        const t = uniqueState.currentFramebb / uniqueState.totalFramesbb;
        const easedT = easeInOutQuint(t);
       
        const canvasW = WIDTH; const  canvasH = HEIGHT;

        ctx.clearRect(0, 0, canvasW, canvasH);
        
        ctx.save();
        const rot1 = lerp(0, Math.PI / 4, easedT);
        const alpha1 = lerp(1, 0, easedT);
        
        ctx.globalAlpha = alpha1;
        ctx.translate(canvasW / 2, canvasH / 2);
        ctx.rotate(rot1);
        ctx.translate(-canvasW / 2, -canvasH / 2);
        drawCoverImage(currentImage, ctx, canvas, 1);
        ctx.restore();

        ctx.save();
        const rot2 = lerp(-Math.PI / 4, 0, easedT);
        const alpha2 = lerp(0, 1, easedT);

        ctx.globalAlpha = alpha2;
        ctx.translate(canvasW / 2, canvasH / 2);
        ctx.rotate(rot2);
        ctx.translate(-canvasW / 2, -canvasH / 2);
        drawCoverImage(nextImage, ctx, canvas, 1);
        ctx.restore();

        if (uniqueState.currentFramebb < uniqueState.totalFramesbb) {
            uniqueState.currentFramebb++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, canvasW, canvasH);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();
// --- 13. Slice & Skew (Index 114) ---
ANIMATION_LOGIC[114] = (function() {
    const uniqueState = { totalFramesbb: 120, currentFramebb: 0, numSlices: 10 };
    function init() { uniqueState.currentFramebb = 0; }
    function animate() {
        const t = uniqueState.currentFramebb / uniqueState.totalFramesbb;
        const easedT = easeInOutQuint(t);
       
        const canvasW = WIDTH; const  canvasH = HEIGHT;
        const sliceHeight = canvasH / uniqueState.numSlices;
        
        ctx.clearRect(0, 0, canvasW, canvasH);

        for (let i = 0; i < uniqueState.numSlices; i++) {
            const y = i * sliceHeight;
            const skewFactor = lerp(0, 0.5, Math.sin(easedT * Math.PI));
            const translateX = lerp(0, canvasW / 2, easedT);
            const offsetDir = i % 2 === 0 ? 1 : -1;

            if (t < 0.5) {
                ctx.save();
                ctx.globalAlpha = lerp(1, 0, easedT * 2);
                ctx.beginPath();
                ctx.rect(0, y, canvasW, sliceHeight);
                ctx.clip();
                ctx.translate(offsetDir * translateX, 0);
                ctx.transform(1, 0, skewFactor, 1, 0, 0);
                drawCoverImage(currentImage, ctx, canvas, 1);
                ctx.restore();
            }

            if (t >= 0.5) {
                ctx.save();
                ctx.globalAlpha = lerp(0, 1, (easedT - 0.5) * 2);
                ctx.beginPath();
                ctx.rect(0, y, canvasW, sliceHeight);
                ctx.clip();
                ctx.translate(-offsetDir * (canvasW / 2 - translateX), 0);
                ctx.transform(1, 0, -skewFactor, 1, 0, 0);
                drawCoverImage(nextImage, ctx, canvas, 1);
                ctx.restore();
            }
        }
        
        if (uniqueState.currentFramebb < uniqueState.totalFramesbb) {
            uniqueState.currentFramebb++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, canvasW, canvasH);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();

// --- 14. Shard Explode (Index 115) ---
ANIMATION_LOGIC[115] = (function() {
    const uniqueState = { totalFramesbb: 120, currentFramebb: 0, shards: [], numX: 10, numY: 8, initialized: false };
    
    function initializeShards(canvas) {
        uniqueState.shards = [];
        const canvasW = WIDTH; const  canvasH = HEIGHT;
        const shardW = canvasW / uniqueState.numX;
        const shardH = canvasH / uniqueState.numY;
        
        for (let y = 0; y < uniqueState.numY; y++) {
            for (let x = 0; x < uniqueState.numX; x++) {
                uniqueState.shards.push({
                    x: x * shardW, y: y * shardH, w: shardW, h: shardH,
                    cx: x * shardW + shardW / 2, cy: y * shardH + shardH / 2,
                    dirX: (x - uniqueState.numX / 2),
                    dirY: (y - uniqueState.numY / 2),
                    randRot: (Math.random() - 0.5) * Math.PI
                });
            }
        }
        uniqueState.initialized = true;
    }

    function init() { 
        uniqueState.currentFramebb = 0;
        initializeShards(canvas);
    }
    
    function animate() {
        if (!uniqueState.initialized) { init(); }
        
        const t = uniqueState.currentFramebb / uniqueState.totalFramesbb;
        const easedT = easeInOutQuint(t);
       
        const canvasW = WIDTH; const  canvasH = HEIGHT;

        ctx.clearRect(0, 0, canvasW, canvasH);
        
        const maxScatter = Math.max(canvasW, canvasH) * 0.4;
        const scatter = lerp(0, maxScatter, Math.sin(easedT * Math.PI));

        uniqueState.shards.forEach(shard => {
            if (t < 0.5) {
                ctx.save();
                const alpha = lerp(1, 0, easedT * 2);
                const rot = lerp(0, shard.randRot, easedT * 2);
                const translateX = shard.dirX * scatter;
                const translateY = shard.dirY * scatter;
                
                ctx.globalAlpha = alpha;
                ctx.translate(shard.cx + translateX, shard.cy + translateY);
                ctx.rotate(rot);
                ctx.drawImage(currentImage, shard.x, shard.y, shard.w, shard.h, -shard.w / 2, -shard.h / 2, shard.w, shard.h);
                ctx.restore();
            }
            
            if (t >= 0.5) {
                ctx.save();
                const progress2 = (easedT - 0.5) * 2;
                const alpha = lerp(0, 1, progress2);
                const rot = lerp(-shard.randRot, 0, progress2);
                const translateX = shard.dirX * (maxScatter * (1 - progress2));
                const translateY = shard.dirY * (maxScatter * (1 - progress2));
                
                ctx.globalAlpha = alpha;
                ctx.translate(shard.cx - translateX, shard.cy - translateY);
                ctx.rotate(rot);
                ctx.drawImage(nextImage, shard.x, shard.y, shard.w, shard.h, -shard.w / 2, -shard.h / 2, shard.w, shard.h);
                ctx.restore();
            }
        });
        
        if (uniqueState.currentFramebb < uniqueState.totalFramesbb) {
            uniqueState.currentFramebb++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, canvasW, canvasH);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();

// --- 15. Cube Flip (Index 116) ---
ANIMATION_LOGIC[116] = (function() {
    const uniqueState = { totalFramesbb: 120, currentFramebb: 0, cubes: [], numX: 8, numY: 6, initialized: false };
    
    function initializeCubes(canvas) {
        uniqueState.cubes = [];
        const canvasW = WIDTH; const  canvasH = HEIGHT;
        const cubeW = canvasW / uniqueState.numX;
        const cubeH = canvasH / uniqueState.numY;
        
        for (let y = 0; y < uniqueState.numY; y++) {
            for (let x = 0; x < uniqueState.numX; x++) {
                uniqueState.cubes.push({
                    x: x * cubeW, y: y * cubeH, w: cubeW, h: cubeH,
                    cx: x * cubeW + cubeW / 2, cy: y * cubeH + cubeH / 2
                });
            }
        }
        uniqueState.initialized = true;
    }

    function init() { 
        uniqueState.currentFramebb = 0;
        initializeCubes(canvas);
    }
    
    function animate() {
        if (!uniqueState.initialized) { init(); }
        
        const t = uniqueState.currentFramebb / uniqueState.totalFramesbb;
        const easedT = easeInOutQuint(t);
       
        const canvasW = WIDTH; const  canvasH = HEIGHT;

        ctx.clearRect(0, 0, canvasW, canvasH);
        
        uniqueState.cubes.forEach(cube => {
            const rotationY = (1 - easedT) * Math.PI;
            
            // Image 1 face (0 to PI/2, fades out)
            if (rotationY > Math.PI / 2) {
                ctx.save();
                const rotProgress = (rotationY - Math.PI / 2) / (Math.PI / 2);
                const scaleX = Math.cos(rotationY);
                ctx.globalAlpha = rotProgress;
                ctx.translate(cube.cx, cube.cy);
                ctx.scale(scaleX, 1);
                ctx.drawImage(currentImage, cube.x, cube.y, cube.w, cube.h, -cube.w / 2, -cube.h / 2, cube.w, cube.h);
                ctx.restore();
            }

            // Image 2 face (PI/2 to 0, fades in)
            if (rotationY <= Math.PI / 2) {
                ctx.save();
                const rotProgress = rotationY / (Math.PI / 2);
                const scaleX = Math.cos(rotationY);
                ctx.globalAlpha = 1 - rotProgress;
                ctx.translate(cube.cx, cube.cy);
                ctx.scale(scaleX, 1);
                ctx.drawImage(nextImage, cube.x, cube.y, cube.w, cube.h, -cube.w / 2, -cube.h / 2, cube.w, cube.h);
                ctx.restore();
            }
        });
        
        if (uniqueState.currentFramebb < uniqueState.totalFramesbb) {
            uniqueState.currentFramebb++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, canvasW, canvasH);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();


// --- 19. Horizontal Scanline Reveal (Index 120) ---
ANIMATION_LOGIC[120] = (function() {
    const uniqueState = { totalFramesbb: 120, currentFramebb: 0, numLines: 50 };
    function init() { uniqueState.currentFramebb = 0; }
    function animate() {
        const t = uniqueState.currentFramebb / uniqueState.totalFramesbb;
        const easedT = easeInOutQuint(t);
       
        const canvasW = WIDTH; const  canvasH = HEIGHT;
        const lineHeight = canvasH / uniqueState.numLines;

        ctx.clearRect(0, 0, canvasW, canvasH);
        
        drawCoverImage(currentImage, ctx, canvas, 1);

        for (let i = 0; i < uniqueState.numLines; i++) {
            const yStart = i * lineHeight;
            const center = yStart + lineHeight / 2;
            const revealHeight = lerp(0, lineHeight * 2, easedT); 
            
            ctx.save();
            ctx.beginPath();
            ctx.rect(0, center - revealHeight / 2, canvasW, revealHeight);
            ctx.clip();
            drawCoverImage(nextImage, ctx, canvas, 1);
            ctx.restore();
        }
        
        if (uniqueState.currentFramebb < uniqueState.totalFramesbb) {
            uniqueState.currentFramebb++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, canvasW, canvasH);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();

// --- 20. Distorted Tunnel (Index 121) ---
ANIMATION_LOGIC[121] = (function() {
    const uniqueState = { totalFramesbb: 120, currentFramebb: 0 };
    function init() { uniqueState.currentFramebb = 0; }
    function animate() {
        const t = uniqueState.currentFramebb / uniqueState.totalFramesbb;
        const easedT = easeInOutQuint(t);
       
        const canvasW = WIDTH; const  canvasH = HEIGHT;

        ctx.clearRect(0, 0, canvasW, canvasH);
        
        ctx.save();
        const scale1 = lerp(1, 0.1, easedT);
        const alpha1 = lerp(1, 0, easedT);
        const waveOffset = Math.sin(easedT * Math.PI * 8) * 50 * (1 - easedT);

        ctx.globalAlpha = alpha1;
        ctx.translate(canvasW / 2 + waveOffset, canvasH / 2);
        ctx.scale(scale1, scale1);
        ctx.rotate(easedT * Math.PI);
        ctx.translate(-canvasW / 2, -canvasH / 2);
        drawCoverImage(currentImage, ctx, canvas, 1);
        ctx.restore();

        ctx.save();
        const scale2 = lerp(0.1, 1, easedT);
        const alpha2 = lerp(0, 1, easedT);

        ctx.globalAlpha = alpha2;
        ctx.translate(canvasW / 2 - waveOffset, canvasH / 2);
        ctx.scale(scale2, scale2);
        ctx.rotate((1 - easedT) * -Math.PI);
        ctx.translate(-canvasW / 2, -canvasH / 2);
        drawCoverImage(nextImage, ctx, canvas, 1);
        ctx.restore();
        
        if (uniqueState.currentFramebb < uniqueState.totalFramesbb) {
            uniqueState.currentFramebb++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, canvasW, canvasH);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();

// --- 21. Chromatic Aberration & Blur (Index 122) ---
ANIMATION_LOGIC[122] = (function() {
    const uniqueState = { totalFramesbb: 120, currentFramebb: 0 };
    function init() { uniqueState.currentFramebb = 0; }
    function animate() {
        const t = uniqueState.currentFramebb / uniqueState.totalFramesbb;
        const easedT = easeInOutQuint(t);
       
        const canvasW = WIDTH; const  canvasH = HEIGHT;

        ctx.clearRect(0, 0, canvasW, canvasH);
        
        ctx.save();
        const alpha1 = lerp(1, 0, easedT);
        const aberrationOffset1 = lerp(15, 0, easedT);
        const blurAmount1 = lerp(5, 0, easedT);

        ctx.globalAlpha = alpha1;
        ctx.filter = `blur(${blurAmount1}px)`;
        
        ctx.globalCompositeOperation = 'lighter';
        
        ctx.save();
        ctx.translate(aberrationOffset1, 0);
        ctx.filter = `hue-rotate(0deg) brightness(1.5)`;
        drawCoverImage(currentImage, ctx, canvas, 1);
        ctx.restore();

        ctx.save();
        ctx.translate(-aberrationOffset1, 0);
        ctx.filter = `hue-rotate(240deg) brightness(1.5)`;
        drawCoverImage(currentImage, ctx, canvas, 1);
        ctx.restore();

        ctx.restore();
        
        ctx.globalAlpha = lerp(0, 1, easedT);
        ctx.filter = 'none';
        drawCoverImage(nextImage, ctx, canvas, 1);
        
        if (uniqueState.currentFramebb < uniqueState.totalFramesbb) {
            uniqueState.currentFramebb++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, canvasW, canvasH);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();

// --- 22. Zoom Fade Center (Index 123) ---
ANIMATION_LOGIC[123] = (function() {
    const uniqueState = { totalFramesbb: 120, currentFramebb: 0 };
    function init() { uniqueState.currentFramebb = 0; }
    function animate() {
        const t = uniqueState.currentFramebb / uniqueState.totalFramesbb;
        const easedT = easeInOutQuint(t);
       
        const canvasW = WIDTH; const  canvasH = HEIGHT;

        ctx.clearRect(0, 0, canvasW, canvasH);
        
        ctx.save();
        const scale1 = lerp(1, 0.5, easedT);
        const alpha1 = lerp(1, 0, easedT);
        
        ctx.globalAlpha = alpha1;
        ctx.translate(canvasW / 2, canvasH / 2);
        ctx.scale(scale1, scale1);
        ctx.translate(-canvasW / 2, -canvasH / 2);
        drawCoverImage(currentImage, ctx, canvas, 1);
        ctx.restore();

        ctx.save();
        const scale2 = lerp(0.5, 1, easedT);
        const alpha2 = lerp(0, 1, easedT);
        
        ctx.globalAlpha = alpha2;
        ctx.translate(canvasW / 2, canvasH / 2);
        ctx.scale(scale2, scale2);
        ctx.translate(-canvasW / 2, -canvasH / 2);
        drawCoverImage(nextImage, ctx, canvas, 1);
        ctx.restore();
        
        if (uniqueState.currentFramebb < uniqueState.totalFramesbb) {
            uniqueState.currentFramebb++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, canvasW, canvasH);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();
// --- 24. Simple Horizontal Reveal (Index 125) ---
ANIMATION_LOGIC[125] = (function() {
    const uniqueState = { totalFramesbb: 120, currentFramebb: 0 };
    function init() { uniqueState.currentFramebb = 0; }
    function animate() {
        const t = uniqueState.currentFramebb / uniqueState.totalFramesbb;
        const easedT = easeInOutQuint(t);
       
        const canvasW = WIDTH; const  canvasH = HEIGHT;
        
        ctx.clearRect(0, 0, canvasW, canvasH);
        
        const revealWidth = lerp(0, canvasW, easedT); 
        
        drawCoverImage(nextImage, ctx, canvas, 1);

        ctx.save();
        ctx.beginPath();
        ctx.rect(revealWidth, 0, canvasW - revealWidth, canvasH);
        ctx.clip();
        drawCoverImage(currentImage, ctx, canvas, 1);
        ctx.restore();
        
        if (uniqueState.currentFramebb < uniqueState.totalFramesbb) {
            uniqueState.currentFramebb++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, canvasW, canvasH);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();

// ------------------------------------
// EXTRACTED FROM 02_6854.html (1 Animation: 126)
// ------------------------------------

// --- 25. Complex Tiled Dispersal (Index 126) ---
ANIMATION_LOGIC[126] = (function() {
    const uniqueState = { totalFramesbb: 120, currentFramebb: 0, tiles: [], numX: 12, numY: 8, initialized: false };
    
    function initializeTiles(canvas) {
        uniqueState.tiles = [];
        const canvasW = WIDTH; const  canvasH = HEIGHT;
        const tileW = canvasW / uniqueState.numX;
        const tileH = canvasH / uniqueState.numY;
        const effectTypes = ['scale_rotate', 'alpha_shear_translate'];
        
        for (let y = 0; y < uniqueState.numY; y++) {
            for (let x = 0; x < uniqueState.numX; x++) {
                uniqueState.tiles.push({
                    x: x * tileW, y: y * tileH, w: tileW, h: tileH,
                    effectTypeOut: effectTypes[Math.floor(Math.random() * 2)],
                    randomRot: (Math.random() - 0.5) * Math.PI,
                    randomShear: (Math.random() - 0.5) * 0.5,
                    randomTransX: (Math.random() - 0.5) * canvasW * 0.5,
                    randomTransY: (Math.random() - 0.5) * canvasH * 0.5
                });
            }
        }
        uniqueState.initialized = true;
    }

    function init() { 
        uniqueState.currentFramebb = 0;
        initializeTiles(canvas);
    }
    
    function animate() {
        if (!uniqueState.initialized) { init(); }
        
        const t = uniqueState.currentFramebb / uniqueState.totalFramesbb;
        const easedT = easeInOutQuint(t);
       

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawCoverImage(nextImage, ctx, canvas, 1);

        uniqueState.tiles.forEach(tile => {
            const tileProgress = Math.sin((1 - easedT) * Math.PI);

            ctx.save();
            ctx.translate(tile.x + tile.w / 2, tile.y + tile.h / 2);
            
            if (tile.effectTypeOut === 'scale_rotate') {
                const rotation = tile.randomRot * tileProgress;
                const scale = lerp(1, 0, tileProgress); 
                ctx.rotate(rotation);
                ctx.scale(scale, scale);
            } else if (tile.effectTypeOut === 'alpha_shear_translate') {
                const shearX = tile.randomShear * tileProgress; 
                const translateX = tile.randomTransX * tileProgress; 
                const translateY = tile.randomTransY * tileProgress; 
                ctx.translate(translateX, translateY);
                ctx.transform(1, 0, shearX, 1, 0, 0); 
            }

            ctx.globalAlpha = lerp(1, 0, tileProgress); 
            ctx.drawImage(currentImage, tile.x, tile.y, tile.w, tile.h, -tile.w / 2, -tile.h / 2, tile.w, tile.h);
            
            ctx.restore();
        });
        
        if (uniqueState.currentFramebb < uniqueState.totalFramesbb) {
            uniqueState.currentFramebb++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, canvas.width, canvas.height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();

// ------------------------------------
// EXTRACTED FROM 02_7380.html (5 Pixel Animations: 127-131)
// REQUIRES GLOBAL FUNCTIONS: getPixelData(img) and ctx.putImageData(imageData, 0, 0)
// ------------------------------------
// --- 27. Wave Swirl (Index 128) ---
ANIMATION_LOGIC[128] = (function() {
    const uniqueState = { totalFramesbb: 120, currentFramebb: 0, srcData: null, destData: null };
    function init() { 
        uniqueState.currentFramebb = 0;
        if (typeof getPixelData === 'function') {
            uniqueState.srcData = getPixelData(currentImage);
            uniqueState.destData = getPixelData(nextImage);
        }
    }
    function animate() {
        const t = uniqueState.currentFramebb / uniqueState.totalFramesbb;
        const easedT = easeInOutQuint(t);
        const { srcData, destData } = uniqueState;
        
        if (!srcData || !destData || typeof ctx.putImageData !== 'function') {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.globalAlpha = 1 - easedT;
            drawCoverImage(currentImage, ctx, canvas, 1);
            ctx.globalAlpha = easedT;
            drawCoverImage(nextImage, ctx, canvas, 1);
        } else {
            const width = srcData.width, height = srcData.height;
            const newImageData = ctx.createImageData(width, height);
            const dataLength = srcData.data.length;
            const centerSwirl = Math.PI * 4 * easedT;
            const radiusFactor = 0.01;

            for (let i = 0; i < dataLength; i += 4) {
                const x = (i / 4) % width;
                const y = Math.floor((i / 4) / width);
                
                const dx = x - width / 2;
                const dy = y - height / 2;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                const angle = Math.atan2(dy, dx) + centerSwirl * (1 - dist * radiusFactor);

                const displacedX = Math.round(width / 2 + dist * Math.cos(angle));
                const displacedY = Math.round(height / 2 + dist * Math.sin(angle));

                const sourceX = Math.max(0, Math.min(width - 1, displacedX));
                const sourceY = Math.max(0, Math.min(height - 1, displacedY));
                const sourceI = (sourceY * width + sourceX) * 4;

                const blendFactor = easedT; 
                
                newImageData.data[i] = Math.round(srcData.data[sourceI] * (1 - blendFactor) + destData.data[i] * blendFactor); 
                newImageData.data[i+1] = Math.round(srcData.data[sourceI+1] * (1 - blendFactor) + destData.data[i+1] * blendFactor); 
                newImageData.data[i+2] = Math.round(srcData.data[sourceI+2] * (1 - blendFactor) + destData.data[i+2] * blendFactor); 
                newImageData.data[i+3] = 255;
            }
            ctx.putImageData(newImageData, 0, 0);
        }

        if (uniqueState.currentFramebb < uniqueState.totalFramesbb) {
            uniqueState.currentFramebb++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, canvas.width, canvas.height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();

// --- 28. Expanding Circle Reveal (Index 129) ---
ANIMATION_LOGIC[129] = (function() {
    const uniqueState = { totalFramesbb: 120, currentFramebb: 0, srcData: null, destData: null };
    function init() { 
        uniqueState.currentFramebb = 0;
        if (typeof getPixelData === 'function') {
            uniqueState.srcData = getPixelData(currentImage);
            uniqueState.destData = getPixelData(nextImage);
        }
    }
    function animate() {
        const t = uniqueState.currentFramebb / uniqueState.totalFramesbb;
        const easedT = easeInOutQuint(t);
        const { srcData, destData } = uniqueState;

        if (!srcData || !destData || typeof ctx.putImageData !== 'function') {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.globalAlpha = 1 - easedT;
            drawCoverImage(currentImage, ctx, canvas, 1);
            ctx.globalAlpha = easedT;
            drawCoverImage(nextImage, ctx, canvas, 1);
        } else {
            const width = srcData.width, height = srcData.height;
            const newImageData = ctx.createImageData(width, height);
            const dataLength = srcData.data.length;
            const centerX = width / 2;
            const centerY = height / 2;
            const maxRadius = Math.sqrt(centerX * centerX + centerY * centerY);

            for (let i = 0; i < dataLength; i += 4) {
                const x = (i / 4) % width;
                const y = Math.floor((i / 4) / width);
                
                const dist = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                const pixelProgress = dist / maxRadius;
                
                const blend = Math.max(0, Math.min(1, (easedT - pixelProgress) * 5));
                
                newImageData.data[i] = Math.round(srcData.data[i] * (1 - blend) + destData.data[i] * blend); 
                newImageData.data[i+1] = Math.round(srcData.data[i+1] * (1 - blend) + destData.data[i+1] * blend); 
                newImageData.data[i+2] = Math.round(srcData.data[i+2] * (1 - blend) + destData.data[i+2] * blend); 
                newImageData.data[i+3] = 255;
            }
            ctx.putImageData(newImageData, 0, 0);
        }

        if (uniqueState.currentFramebb < uniqueState.totalFramesbb) {
            uniqueState.currentFramebb++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, canvas.width, canvas.height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();

// --- 29. Wipe from Edge (Index 130) ---
ANIMATION_LOGIC[130] = (function() {
    const uniqueState = { totalFramesbb: 120, currentFramebb: 0, srcData: null, destData: null };
    function init() { 
        uniqueState.currentFramebb = 0;
        if (typeof getPixelData === 'function') {
            uniqueState.srcData = getPixelData(currentImage);
            uniqueState.destData = getPixelData(nextImage);
        }
    }
    function animate() {
        const t = uniqueState.currentFramebb / uniqueState.totalFramesbb;
        const easedT = easeInOutQuint(t);
        const { srcData, destData } = uniqueState;

        if (!srcData || !destData || typeof ctx.putImageData !== 'function') {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.globalAlpha = 1 - easedT;
            drawCoverImage(currentImage, ctx, canvas, 1);
            ctx.globalAlpha = easedT;
            drawCoverImage(nextImage, ctx, canvas, 1);
        } else {
            const width = srcData.width, height = srcData.height;
            const newImageData = ctx.createImageData(width, height);
            const dataLength = srcData.data.length;
            
            for (let i = 0; i < dataLength; i += 4) {
                const y = Math.floor((i / 4) / width);
                const revealFactor = y / height; 
                const blend = Math.max(0, Math.min(1, (easedT - revealFactor) * 5)); 
                
                newImageData.data[i] = Math.round(srcData.data[i] * (1 - blend) + destData.data[i] * blend); 
                newImageData.data[i+1] = Math.round(srcData.data[i+1] * (1 - blend) + destData.data[i+1] * blend); 
                newImageData.data[i+2] = Math.round(srcData.data[i+2] * (1 - blend) + destData.data[i+2] * blend); 
                newImageData.data[i+3] = 255;
            }
            ctx.putImageData(newImageData, 0, 0);
        }

        if (uniqueState.currentFramebb < uniqueState.totalFramesbb) {
            uniqueState.currentFramebb++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, canvas.width, canvas.height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();

// --- 30. Pixel Displacement (Index 131) ---
ANIMATION_LOGIC[131] = (function() {
    const uniqueState = { totalFramesbb: 120, currentFramebb: 0, srcData: null, destData: null };
    function init() { 
        uniqueState.currentFramebb = 0;
        if (typeof getPixelData === 'function') {
            uniqueState.srcData = getPixelData(currentImage);
            uniqueState.destData = getPixelData(nextImage);
        }
    }
    function animate() {
        const t = uniqueState.currentFramebb / uniqueState.totalFramesbb;
        const easedT = easeInOutQuint(t);
        const { srcData, destData } = uniqueState;

        if (!srcData || !destData || typeof ctx.putImageData !== 'function') {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.globalAlpha = 1 - easedT;
            drawCoverImage(currentImage, ctx, canvas, 1);
            ctx.globalAlpha = easedT;
            drawCoverImage(nextImage, ctx, canvas, 1);
        } else {
            const width = srcData.width, height = srcData.height;
            const newImageData = ctx.createImageData(width, height);
            const dataLength = srcData.data.length;
            
            const displacementFactor = lerp(0, 50, Math.sin(easedT * Math.PI));
            const waveFrequency = 0.05;

            for (let i = 0; i < dataLength; i += 4) {
                const x = (i / 4) % width;
                const y = Math.floor((i / 4) / width);
                
                const offsetX = Math.sin(y * waveFrequency + easedT * Math.PI * 2) * displacementFactor;
                const offsetY = Math.cos(x * waveFrequency + easedT * Math.PI * 2) * displacementFactor;

                const sourceX = Math.max(0, Math.min(width - 1, Math.round(x - offsetX)));
                const sourceY = Math.max(0, Math.min(height - 1, Math.round(y - offsetY)));
                const sourceI = (sourceY * width + sourceX) * 4;

                const blendFactor = easedT; 
                
                newImageData.data[i] = Math.round(srcData.data[sourceI] * (1 - blendFactor) + destData.data[i] * blendFactor); 
                newImageData.data[i+1] = Math.round(srcData.data[sourceI+1] * (1 - blendFactor) + destData.data[i+1] * blendFactor); 
                newImageData.data[i+2] = Math.round(srcData.data[sourceI+2] * (1 - blendFactor) + destData.data[i+2] * blendFactor); 
                newImageData.data[i+3] = 255;
            }
            ctx.putImageData(newImageData, 0, 0);
        }

        if (uniqueState.currentFramebb < uniqueState.totalFramesbb) {
            uniqueState.currentFramebb++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, canvas.width, canvas.height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();

// ------------------------------------
// EXTRACTED FROM 02_8088.html (4 Animations: 132-135)
// ------------------------------------

// --- 31. Dissolve Spin (Index 132) ---
ANIMATION_LOGIC[132] = (function() {
    const uniqueState = { totalFramesbb: 120, currentFramebb: 0 };
    function init() { uniqueState.currentFramebb = 0; }
    function animate() {
        const t = uniqueState.currentFramebb / uniqueState.totalFramesbb;
        const easedT = easeInOutQuint(t);
       
        const canvasW = WIDTH; const  canvasH = HEIGHT;

        ctx.clearRect(0, 0, canvasW, canvasH);
        
        ctx.save();
        const rot1 = lerp(0, Math.PI / 4, easedT);
        const alpha1 = lerp(1, 0, easedT);
        
        ctx.globalAlpha = alpha1;
        ctx.translate(canvasW / 2, canvasH / 2);
        ctx.rotate(rot1);
        ctx.translate(-canvasW / 2, -canvasH / 2);
        drawCoverImage(currentImage, ctx, canvas, 1);
        ctx.restore();

        ctx.save();
        const rot2 = lerp(-Math.PI / 4, 0, easedT);
        const alpha2 = lerp(0, 1, easedT);

        ctx.globalAlpha = alpha2;
        ctx.translate(canvasW / 2, canvasH / 2);
        ctx.rotate(rot2);
        ctx.translate(-canvasW / 2, -canvasH / 2);
        drawCoverImage(nextImage, ctx, canvas, 1);
        ctx.restore();
        
        if (uniqueState.currentFramebb < uniqueState.totalFramesbb) {
            uniqueState.currentFramebb++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, canvasW, canvasH);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();

// --- 32. Zoom Focus (Index 133) ---
ANIMATION_LOGIC[133] = (function() {
    const uniqueState = { totalFramesbb: 120, currentFramebb: 0 };
    function init() { uniqueState.currentFramebb = 0; }
    function animate() {
        const t = uniqueState.currentFramebb / uniqueState.totalFramesbb;
        const easedT = easeInOutQuint(t);
       
        const canvasW = WIDTH; const  canvasH = HEIGHT;

        ctx.clearRect(0, 0, canvasW, canvasH);
        
        ctx.save();
        const scale1 = lerp(1, 1.5, easedT);
        const blur1 = lerp(0, 5, easedT);
        const alpha1 = lerp(1, 0, easedT);
        
        ctx.globalAlpha = alpha1;
        ctx.filter = `blur(${blur1}px)`;
        ctx.translate(canvasW / 2, canvasH / 2);
        ctx.scale(scale1, scale1);
        ctx.translate(-canvasW / 2, -canvasH / 2);
        drawCoverImage(currentImage, ctx, canvas, 1);
        ctx.restore();

        ctx.save();
        const scale2 = lerp(1.5, 1, easedT);
        const blur2 = lerp(5, 0, easedT);
        const alpha2 = lerp(0, 1, easedT);

        ctx.globalAlpha = alpha2;
        ctx.filter = `blur(${blur2}px)`;
        ctx.translate(canvasW / 2, canvasH / 2);
        ctx.scale(scale2, scale2);
        ctx.translate(-canvasW / 2, -canvasH / 2);
        drawCoverImage(nextImage, ctx, canvas, 1);
        ctx.restore();
        
        if (uniqueState.currentFramebb < uniqueState.totalFramesbb) {
            uniqueState.currentFramebb++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, canvasW, canvasH);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();

// --- 33. Skew Slide (Index 134) ---
ANIMATION_LOGIC[134] = (function() {
    const uniqueState = { totalFramesbb: 120, currentFramebb: 0 };
    function init() { uniqueState.currentFramebb = 0; }
    function animate() {
        const t = uniqueState.currentFramebb / uniqueState.totalFramesbb;
        const easedT = easeInOutQuint(t);
       
        const canvasW = WIDTH; const  canvasH = HEIGHT;

        ctx.clearRect(0, 0, canvasW, canvasH);
        
        ctx.save();
        const skew1 = lerp(0, 0.5, easedT);
        const slideX1 = lerp(0, canvasW, easedT);
        const alpha1 = lerp(1, 0, easedT);
        
        ctx.globalAlpha = alpha1;
        ctx.translate(slideX1, 0);
        ctx.transform(1, 0, skew1, 1, 0, 0);
        drawCoverImage(currentImage, ctx, canvas, 1);
        ctx.restore();

        ctx.save();
        const skew2 = lerp(0.5, 0, easedT);
        const slideX2 = lerp(-canvasW, 0, easedT);
        const alpha2 = lerp(0, 1, easedT);

        ctx.globalAlpha = alpha2;
        ctx.translate(slideX2, 0);
        ctx.transform(1, 0, -skew2, 1, 0, 0);
        drawCoverImage(nextImage, ctx, canvas, 1);
        ctx.restore();
        
        if (uniqueState.currentFramebb < uniqueState.totalFramesbb) {
            uniqueState.currentFramebb++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, canvasW, canvasH);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();

// ------------------------------------
// EXTRACTED FROM 02_9148.html (1 Animation: 136)
// ------------------------------------

// --- 35. Piece-wise Chaos (Index 136) ---
ANIMATION_LOGIC[135] = (function() {
    const uniqueState = { totalFramesbb: 120, currentFramebb: 0, pieces: [], numX: 10, numY: 8, initialized: false };
    
    function initializePieces(canvas) {
        uniqueState.pieces = [];
        const canvasW = WIDTH; const  canvasH = HEIGHT;
        const pieceW = canvasW / uniqueState.numX;
        const pieceH = canvasH / uniqueState.numY;
        const types = ['slide', 'scale', 'rotate', 'skew'];
        
        for (let y = 0; y < uniqueState.numY; y++) {
            for (let x = 0; x < uniqueState.numX; x++) {
                const type = types[Math.floor(Math.random() * types.length)];
                
                uniqueState.pieces.push({
                    x: x * pieceW, y: y * pieceH, w: pieceW, h: pieceH,
                    type: type,
                    rot: (Math.random() - 0.5) * Math.PI,
                    scale: 0.5 + Math.random() * 0.5,
                    transX: (Math.random() - 0.5) * canvasW * 0.8,
                    transY: (Math.random() - 0.5) * canvasH * 0.8,
                    skew: (Math.random() - 0.5) * 0.5
                });
            }
        }
        uniqueState.initialized = true;
    }

    function init() { 
        uniqueState.currentFramebb = 0;
        initializePieces(canvas);
    }
    
    function animate() {
        if (!uniqueState.initialized) { init(); }
        
        const t = uniqueState.currentFramebb / uniqueState.totalFramesbb;
        const easedT = easeInOutQuint(t);
       

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        uniqueState.pieces.forEach(piece => {
            ctx.save();
            ctx.translate(piece.x + piece.w / 2, piece.y + piece.h / 2);

            let alpha = 1;
            
            // --- Image 1 (fading out) ---
            if (t < 0.5) {
                const progress = easedT * 2;
                alpha = lerp(1, 0, progress);

                if (piece.type === 'slide') { ctx.translate(piece.transX * progress, piece.transY * progress); } 
                else if (piece.type === 'scale') { ctx.scale(lerp(1, 0.1, progress), lerp(1, 0.1, progress)); } 
                else if (piece.type === 'rotate') { ctx.rotate(piece.rot * progress); } 
                else if (piece.type === 'skew') { ctx.transform(1, 0, piece.skew * progress, 1, 0, 0); }

                ctx.globalAlpha = alpha;
                ctx.drawImage(currentImage, piece.x, piece.y, piece.w, piece.h, -piece.w / 2, -piece.h / 2, piece.w, piece.h);
            }
            
            // --- Image 2 (fading in) ---
            if (t >= 0.5) {
                const progress = (easedT - 0.5) * 2;
                alpha = lerp(0, 1, progress);

                if (piece.type === 'slide') { ctx.translate(piece.transX * (1 - progress), piece.transY * (1 - progress)); } 
                else if (piece.type === 'scale') { ctx.scale(lerp(0.1, 1, progress), lerp(0.1, 1, progress)); } 
                else if (piece.type === 'rotate') { ctx.rotate(piece.rot * (1 - progress)); } 
                else if (piece.type === 'skew') { ctx.transform(1, 0, piece.skew * (1 - progress), 1, 0, 0); }

                ctx.globalAlpha = alpha;
                ctx.drawImage(nextImage, piece.x, piece.y, piece.w, piece.h, -piece.w / 2, -piece.h / 2, piece.w, piece.h);
            }
            
            ctx.restore();
        });
        
        if (uniqueState.currentFramebb < uniqueState.totalFramesbb) {
            uniqueState.currentFramebb++;
            requestAnimationFrame(animate);
        } else {	
            ctx.drawImage(nextImage, 0, 0, canvas.width, canvas.height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();

















// Functie voor vloeiende overgangen (Cubic Ease In/Out)
const easeInOutCubic = (t) => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
// BELANGRIJK: Alle ANIMATION_LOGIC functies hieronder gaan ervan uit dat
// 'canvas', 'ctx', 'currentImage', 'nextImage', en 'startNextTransition'
// globaal beschikbaar zijn.

// ====================================================================
// 137. Quantum Split-Screen (De Quantum Kansen) - GECORRIGEERD
// ====================================================================
ANIMATION_LOGIC[137] = (function() {
    let uniqueState = {
        totalFrames: 90, 
        currentFrame: 0,
        slices: 60, 
    };

    const getProbability = (t) => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;

    function init() {
        uniqueState.currentFrame = 0;
    }

    function animate() {
        const { width, height } = canvas;
        const sliceWidth = width / uniqueState.slices;
        const progress = uniqueState.currentFrame / uniqueState.totalFrames;
        const probabilityFactor = getProbability(progress); 

        ctx.clearRect(0, 0, width, height);
        ctx.save();
        
        for (let i = 0; i < uniqueState.slices; i++) {
            const x = i * sliceWidth;
            
            const imageToDraw = (Math.random() < probabilityFactor) ? nextImage : currentImage;

            ctx.drawImage(
                imageToDraw, 
                x, 0, sliceWidth, height, 
                x, 0, sliceWidth, height
            );
        }
        
        ctx.restore();

        if (uniqueState.currentFrame < uniqueState.totalFrames) {
            uniqueState.currentFrame++;
            requestAnimationFrame(animate); 
        } else {
            ctx.drawImage(nextImage, 0, 0, width, height);
            startNextTransition();
        }
    }
    
    return { init: init, animate: animate, uniqueState: uniqueState };
})();


// ====================================================================
// 138. The Glitch Weave (Het Glitch Weefsel) - GECORRIGEERD
// ====================================================================
ANIMATION_LOGIC[138] = (function() {
    let uniqueState = {
        totalFrames: 60,
        currentFrame: 0,
        threads: 80, 
        maxOffset: 50, 
    };

    function init() {
        uniqueState.currentFrame = 0;
    }

    function animate() {
        const { width, height } = canvas;
        const threadHeight = height / uniqueState.threads;
        const progress = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedProgress = easeInOutCubic(progress);

        ctx.clearRect(0, 0, width, height);
        ctx.save();
        
        for (let i = 0; i < uniqueState.threads; i++) {
            const y = i * threadHeight;
            
            const direction = (i % 2 === 0) ? 1 : -1;
            const offset = direction * uniqueState.maxOffset * easedProgress;

            // Deel 1: Glitch (Tekent de oude scne met verschuiving)
            ctx.drawImage(
                currentImage, 
                0, y, width, threadHeight, 
                offset, y, width, threadHeight
            );
            
            // Deel 2: Weave (Tekent de nieuwe scne over de verschoven ruimte)
            ctx.globalAlpha = easedProgress;
            ctx.drawImage(
                nextImage, 
                0, y, width, threadHeight, 
                0, y, width, threadHeight
            );
            ctx.globalAlpha = 1; 
        }
        
        ctx.restore();

        if (uniqueState.currentFrame < uniqueState.totalFrames) {
            uniqueState.currentFrame++;
            requestAnimationFrame(animate); 
        } else {
            ctx.drawImage(nextImage, 0, 0, width, height);
            startNextTransition();
        }
    }
    
    return { init: init, animate: animate, uniqueState: uniqueState };
})();


// ====================================================================
// 139. The Voxel Melt (De Voxel Smelting) - GECORRIGEERD
// ====================================================================
ANIMATION_LOGIC[139] = (function() {
    let uniqueState = {
        totalFrames: 120, 
        currentFrame: 0,
        voxelSize: 10, 
        voxels: [],
    };

    function init() {
        uniqueState.currentFrame = 0;
        uniqueState.voxels = [];
    }

    function animate() {
        const { width, height } = canvas;
        const progress = uniqueState.currentFrame / uniqueState.totalFrames;
        
        ctx.clearRect(0, 0, width, height);
        ctx.save();
        
        const phase1_progress = Math.min(1, progress * 2);
        const phase2_progress = Math.max(0, (progress - 0.5) * 2); 
        
        // FASE 1: Voxel Melt
        if (progress <= 0.5) {
            const currentMeltHeight = height * easeInQuad(phase1_progress); 
            const remainingHeight = height - currentMeltHeight;
            
            ctx.drawImage(
                currentImage, 
                0, 0, width, remainingHeight, 
                0, 0, width, remainingHeight
            );
        }
        
        // FASE 2: Voxel Grow
        if (progress >= 0.5) {
            const revealHeight = height * easeOutQuad(phase2_progress);
            const destinationY = height - revealHeight;
            
            ctx.drawImage(
                nextImage, 
                0, destinationY, width, revealHeight, 
                0, destinationY, width, revealHeight
            );
        }
        
        ctx.restore();

        if (uniqueState.currentFrame < uniqueState.totalFrames) {
            uniqueState.currentFrame++;
            requestAnimationFrame(animate); 
        } else {
            ctx.drawImage(nextImage, 0, 0, width, height);
            startNextTransition();
        }
    }
    
    return { init: init, animate: animate, uniqueState: uniqueState };
})();


// ====================================================================
// 140. Wave Reveal - GECORRIGEERD
// ====================================================================
ANIMATION_LOGIC[140] = (function() {
    let uniqueState = { 
        totalFrames: 120, 
        currentFrame: 0, 
        numStrips: 50,
    };
    
    const lerp = (a, b, t) => a + (b - a) * t;

    function init() { 
        uniqueState.currentFrame = 0;
    }
    
    function animate() {
        const t = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedT = easeInOutQuint(t); 
        
        const canvasW = canvas.width; 
        const canvasH = canvas.height;
        const stripWidth = canvasW / uniqueState.numStrips;

        ctx.clearRect(0, 0, canvasW, canvasH);
        
        const amplitude = 30 * Math.sin(easedT * Math.PI);
        const waveSpeed = t * 2 * Math.PI;

        for (let i = 0; i < uniqueState.numStrips; i++) {
            const x = i * stripWidth;
            const dy = amplitude * Math.sin(i * 0.5 + waveSpeed);
            
            // Image 1 (fading out)
            ctx.save();
            ctx.beginPath();
            ctx.rect(x, 0, stripWidth, canvasH);
            ctx.clip();
            ctx.globalAlpha = lerp(1, 0, easedT);
            ctx.translate(0, dy * (1 - easedT));
            ctx.drawImage(currentImage, 0, 0, canvasW, canvasH); 
            ctx.restore();
            
            // Image 2 (fading in)
            ctx.save();
            ctx.beginPath();
            ctx.rect(x, 0, stripWidth, canvasH);
            ctx.clip();
            ctx.globalAlpha = lerp(0, 1, easedT);
            ctx.translate(0, dy * easedT);
            ctx.drawImage(nextImage, 0, 0, canvasW, canvasH); 
            ctx.restore();
        }
        
        if (uniqueState.currentFrame < uniqueState.totalFrames) {
            uniqueState.currentFrame++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, canvasW, canvasH);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();


// ====================================================================
// 141. Wave Strip Slide - GECORRIGEERD
// ====================================================================
ANIMATION_LOGIC[141] = (function() {
    const uniqueState = { 
        totalFramesbb: 90, 
        currentFramebb: 0, 
        numStrips: 40, 
        maxOffset: 150, 
        initialized: false 
    };
    
    function init() {
        uniqueState.currentFramebb = 0;
        uniqueState.initialized = true;
    }
    
    function animate() {
        if (!uniqueState.initialized) { init(); }
        
        const t = uniqueState.currentFramebb / uniqueState.totalFramesbb;
        const easedT = easeInOutQuint(t);
        
        const canvasW = canvas.width; 
        const canvasH = canvas.height;
        const stripWidth = canvasW / uniqueState.numStrips;

        ctx.clearRect(0, 0, canvasW, canvasH);
        
        const waveFrequency = 0.05; 
        const amplitude = 30; 

        for (let i = 0; i < uniqueState.numStrips; i++) {
            const x = i * stripWidth;
            
            const waveOffset = amplitude * Math.sin(i * waveFrequency + easedT * Math.PI * 2);

            // Image 1 (currentImage - schuift uit)
            ctx.save();
            ctx.beginPath();
            ctx.rect(x, 0, stripWidth, canvasH);
            ctx.clip();

            const translateX = lerp(0, -uniqueState.maxOffset, easedT); 
            ctx.translate(translateX, waveOffset * (1 - easedT)); 

            ctx.globalAlpha = lerp(1, 0, easedT);
            ctx.drawImage(currentImage, x, 0, stripWidth, canvasH, x, 0, stripWidth, canvasH); 
            
            ctx.restore();
            
            // Image 2 (nextImage - schuift in)
            ctx.save();
            ctx.beginPath();
            ctx.rect(x, 0, stripWidth, canvasH);
            ctx.clip();

            const translateXIn = lerp(uniqueState.maxOffset, 0, easedT);
            ctx.translate(translateXIn, waveOffset * easedT); 

            ctx.globalAlpha = lerp(0, 1, easedT);
            ctx.drawImage(nextImage, x, 0, stripWidth, canvasH, x, 0, stripWidth, canvasH); 
            
            ctx.restore();
        }
        
        if (uniqueState.currentFramebb < uniqueState.totalFramesbb) {
            uniqueState.currentFramebb++;
            requestAnimationFrame(animate); 
        } else {	
            ctx.drawImage(nextImage, 0, 0, canvas.width, canvas.height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();


// ====================================================================
// 142. Radial Wipe (Cirkel onthulling)
// ====================================================================
ANIMATION_LOGIC[142] = (function() {
    const uniqueState = { 
        totalFrames: 90, 
        currentFrame: 0,
    };

    function init() {
        uniqueState.currentFrame = 0;
    }
    
    function animate() {
        const { width, height } = canvas;
        const t = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedT = easeInOutQuint(t); 
        
        // De maximale straal is de afstand van het midden tot de verst verwijderde hoek
        const maxRadius = Math.sqrt(width * width + height * height) / 2;
        const currentRadius = maxRadius * easedT;
        
        const centerX = width / 2;
        const centerY = height / 2;

        ctx.clearRect(0, 0, width, height);

        // Teken de oude afbeelding volledig (als achtergrond)
        ctx.drawImage(currentImage, 0, 0, width, height); 

        // Nu de nieuwe afbeelding clippen in een groeiende cirkel
        ctx.save();
        
        // Creer de cirkel clip
        ctx.beginPath();
        ctx.arc(centerX, centerY, currentRadius, 0, 2 * Math.PI);
        ctx.clip();
        
        // Teken de nieuwe afbeelding (wordt alleen getoond binnen de clip)
        ctx.drawImage(nextImage, 0, 0, width, height); 

        ctx.restore();

        if (uniqueState.currentFrame < uniqueState.totalFrames) {
            uniqueState.currentFrame++;
            requestAnimationFrame(animate);
        } else {
            // Zorg ervoor dat de nieuwe afbeelding volledig wordt getoond
            ctx.drawImage(nextImage, 0, 0, width, height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();


// ====================================================================
// 143. Checkerboard Dissolve (Schaakbord Oplossing)
// ====================================================================
ANIMATION_LOGIC[143] = (function() {
    const uniqueState = { 
        totalFrames: 100, 
        currentFrame: 0,
        numX: 12, // 12 blokjes horizontaal
        numY: 10, // 10 blokjes verticaal
    };

    function init() {
        uniqueState.currentFrame = 0;
    }
    
    function animate() {
        const { width, height } = canvas;
        const t = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedT = easeInOutQuint(t); 
        
        const pieceW = width / uniqueState.numX;
        const pieceH = height / uniqueState.numY;
        
        ctx.clearRect(0, 0, width, height);
        
        for (let y = 0; y < uniqueState.numY; y++) {
            for (let x = 0; x < uniqueState.numX; x++) {
                const startX = x * pieceW;
                const startY = y * pieceH;
                const isOdd = (x + y) % 2 !== 0; // Check voor schaakbordpatroon
                
                // Bepaal de progress op basis van het patroon: oneven cellen in fase 1, even in fase 2
                let cellT;
                if (isOdd) {
                    // Oneven cellen lossen op in de eerste helft
                    cellT = Math.min(1, easedT * 2);
                } else {
                    // Even cellen lossen op in de tweede helft
                    cellT = Math.max(0, (easedT - 0.5) * 2);
                }
                
                // Schaal voor de nieuwe (inkomende) cel
                const scaleNew = cellT;
                // Schaal voor de oude (uitgaande) cel
                const scaleOld = 1 - cellT;

                // --- 1. Teken de oude afbeelding (krimpt) ---
                ctx.save();
                ctx.translate(startX + pieceW / 2, startY + pieceH / 2);
                ctx.scale(scaleOld, scaleOld);
                
                ctx.drawImage(
                    currentImage, 
                    startX, startY, pieceW, pieceH, // Bron: het stuk uit de oude afbeelding
                    -pieceW / 2, -pieceH / 2, pieceW, pieceH // Bestemming: gecentreerd
                );
                ctx.restore();

                // --- 2. Teken de nieuwe afbeelding (groeit) ---
                ctx.save();
                ctx.translate(startX + pieceW / 2, startY + pieceH / 2);
                ctx.scale(scaleNew, scaleNew);
                
                ctx.drawImage(
                    nextImage, 
                    startX, startY, pieceW, pieceH, // Bron: het stuk uit de nieuwe afbeelding
                    -pieceW / 2, -pieceH / 2, pieceW, pieceH // Bestemming: gecentreerd
                );
                ctx.restore();
            }
        }

        if (uniqueState.currentFrame < uniqueState.totalFrames) {
            uniqueState.currentFrame++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, width, height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();


// ====================================================================
// 144. 3D Fold-Out (3D Uitklap)
// ====================================================================
ANIMATION_LOGIC[144] = (function() {
    const uniqueState = { 
        totalFrames: 120, 
        currentFrame: 0,
        numStrips: 15, // Aantal horizontale stroken
    };

    function init() {
        uniqueState.currentFrame = 0;
    }
    
    function animate() {
        const { width, height } = canvas;
        const t = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedT = easeInOutCubic(t); 
        
        const stripH = height / uniqueState.numStrips;
        
        ctx.clearRect(0, 0, width, height);
        ctx.save();
        
        // Teken de nieuwe afbeelding als volledige achtergrond
        ctx.drawImage(nextImage, 0, 0, width, height);

        // De oude afbeelding wordt weggemoffeld door stroken
        for (let i = 0; i < uniqueState.numStrips; i++) {
            const y = i * stripH;
            
            ctx.save();
            ctx.beginPath();
            ctx.rect(0, y, width, stripH);
            ctx.clip();
            
            // Roteer rond de bovenkant (voor even stroken) of onderkant (voor oneven stroken)
            const isTopFold = i % 2 === 0;
            
            // Bepaal de rotatie: van 0 naar 90 graden (1.57 rad)
            const rotation = (isTopFold ? 1 : -1) * (easedT * Math.PI / 2);

            // Transformatie
            ctx.translate(width / 2, isTopFold ? y : y + stripH);
            ctx.rotate(rotation);
            ctx.translate(-width / 2, isTopFold ? -y : -(y + stripH));
            
            // Teken de oude afbeelding in de clip
            ctx.drawImage(currentImage, 0, 0, width, height);
            
            ctx.restore();
        }
        
        ctx.restore();

        if (uniqueState.currentFrame < uniqueState.totalFrames) {
            uniqueState.currentFrame++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, width, height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();


// ====================================================================
// 145. Pixel Swarm (Pixel Zwerm)
// ====================================================================
ANIMATION_LOGIC[145] = (function() {
    const uniqueState = { 
        totalFrames: 180, // Langere duur voor het zwerm-effect
        currentFrame: 0,
        pieces: [], 
        numX: 25, 
        numY: 20,
        initialized: false
    };

    function initializePieces() {
        uniqueState.pieces = [];
        const canvasW = canvas.width; 
        const canvasH = canvas.height;
        const pieceW = canvasW / uniqueState.numX;
        const pieceH = canvasH / uniqueState.numY;
        
        for (let y = 0; y < uniqueState.numY; y++) {
            for (let x = 0; x < uniqueState.numX; x++) {
                // Positie en afmetingen van het stuk
                const startX = x * pieceW;
                const startY = y * pieceH;

                uniqueState.pieces.push({
                    x: startX, y: startY, w: pieceW, h: pieceH,
                    // Willekeurige snelheden/richtingen voor zwerm
                    velX: (Math.random() - 0.5) * 800,
                    velY: (Math.random() - 0.5) * 800,
                    rotSpeed: (Math.random() - 0.5) * Math.PI * 4,
                });
            }
        }
        uniqueState.initialized = true;
    }

    function init() {
        uniqueState.currentFrame = 0;
        initializePieces();
    }
    
    function animate() {
        if (!uniqueState.initialized) { init(); }

        const t = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedT = easeInOutQuint(t);
        const { width, height } = canvas;
        const dt = 1 / uniqueState.totalFrames; // Tijdsinterval per frame

        ctx.clearRect(0, 0, width, height);
        
        uniqueState.pieces.forEach(piece => {
            const centerX = piece.x + piece.w / 2;
            const centerY = piece.y + piece.h / 2;
            
            // --- Oude afbeelding (zwermt uit) ---
            if (t < 0.5) {
                const progress = easedT * 2;
                const alpha = 1 - progress; // Fade out

                ctx.save();
                ctx.translate(centerX, centerY);
                
                // Beweging
                const moveX = piece.velX * progress * dt * 80;
                const moveY = piece.velY * progress * dt * 80;
                ctx.translate(moveX, moveY);
                
                // Rotatie
                ctx.rotate(piece.rotSpeed * progress);
                
                ctx.globalAlpha = alpha;
                ctx.drawImage(
                    currentImage, 
                    piece.x, piece.y, piece.w, piece.h, 
                    -piece.w / 2, -piece.h / 2, piece.w, piece.h
                );
                ctx.restore();
            }
            
            // --- Nieuwe afbeelding (zwermt in) ---
            if (t >= 0.5) {
                const progress = (easedT - 0.5) * 2;
                const alpha = progress; // Fade in

                ctx.save();
                ctx.translate(centerX, centerY);
                
                // Beweging (omgekeerd, komt terug van de zwermpositie)
                const moveX = piece.velX * (1 - progress) * dt * 80;
                const moveY = piece.velY * (1 - progress) * dt * 80;
                ctx.translate(moveX, moveY);
                
                // Rotatie (omgekeerd)
                ctx.rotate(piece.rotSpeed * (1 - progress));
                
                ctx.globalAlpha = alpha;
                ctx.drawImage(
                    nextImage, 
                    piece.x, piece.y, piece.w, piece.h, 
                    -piece.w / 2, -piece.h / 2, piece.w, piece.h
                );
                ctx.restore();
            }
        });

        if (uniqueState.currentFrame < uniqueState.totalFrames) {
            uniqueState.currentFrame++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, width, height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();


// ====================================================================
// 146. Venetian Blinds (Jaloezien)
// ====================================================================
ANIMATION_LOGIC[146] = (function() {
    const uniqueState = { 
        totalFrames: 70, 
        currentFrame: 0,
        numBlinds: 20, // Aantal verticale stroken
    };

    function init() {
        uniqueState.currentFrame = 0;
    }
    
    function animate() {
        const { width, height } = canvas;
        const t = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedT = easeInOutCubic(t); 
        
        const blindW = width / uniqueState.numBlinds;
        
        ctx.clearRect(0, 0, width, height);
        
        for (let i = 0; i < uniqueState.numBlinds; i++) {
            const x = i * blindW;
            const centerX = x + blindW / 2;
            
            // De schaal gaat van 1.0 (vol) naar 0.0 (gespiegeld) en terug naar 1.0
            // Bij 0.5 is de strook onzichtbaar (0 breedte)
            const scaleX = Math.abs(1 - 2 * easedT);
            
            // De afbeelding die op dat moment zichtbaar moet zijn
            const imageToDraw = easedT < 0.5 ? currentImage : nextImage;
            
            ctx.save();
            
            // Vertaal naar het midden van de blind om de schaal toe te passen
            ctx.translate(centerX, 0);
            ctx.scale(scaleX, 1);
            ctx.translate(-centerX, 0);
            
            // Teken de strook van de afbeelding
            ctx.drawImage(
                imageToDraw,
                x, 0, blindW, height, // Bron
                x, 0, blindW, height  // Bestemming
            );
            
            ctx.restore();
        }

        if (uniqueState.currentFrame < uniqueState.totalFrames) {
            uniqueState.currentFrame++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, width, height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();



// ====================================================================
// Gedeelde Data en Hulpfuncties
// ====================================================================

// Lijst van "Welkom Wereld" in 15 verschillende talen
const WELCOME_MESSAGES = [
    { lang: "NL", text: "Welkom Wereld" },
    { lang: "EN", text: "Welcome World" },
    { lang: "FR", text: "Bienvenue Monde" },
    { lang: "DE", text: "Willkommen Welt" },
    { lang: "ES", text: "Bienvenido Mundo" },
    { lang: "IT", text: "Benvenuto Mondo" },
    { lang: "PT", text: "Bem-vindo Mundo" },
    { lang: "RU", text: " , " },
    { lang: "ZH", text: "" },
    { lang: "JA", text: "" },
    { lang: "AR", text: " " },
    { lang: "HI", text: "    " },
    { lang: "KO", text: ", " },
    { lang: "SW", text: "Karibu Dunia" },
    { lang: "EL", text: "  " }
];



/**
 * Tekent de "Welkom Wereld" boodschap met geanimeerde transparantie en schaal.
 * @param {number} t De geaste progress van de animatie (0 tot 1).
 * @param {string} text Het te tekenen bericht.
 */
function drawSpiritualText(t, text) {
    if (!ctx || !canvas) return;
    
    const { width, height } = canvas;
    const alpha = Math.sin(t * Math.PI); // Gaat van 0 -> 1 -> 0
    const scale = 1 + Math.sin(t * Math.PI) * 0.5; // Gaat van 1 -> 1.5 -> 1 (Subtiel pulserend)
    
    ctx.save();
    ctx.globalAlpha = alpha;
    
    ctx.font = `${40 * scale}px 'Inter', sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    // Gradient voor een 'goddelijk' lichteffect
    const gradient = ctx.createLinearGradient(0, height / 2 - 50, width, height / 2 + 50);
    gradient.addColorStop(0, `rgba(255, 255, 255, ${alpha * 0.5})`);
    gradient.addColorStop(0.5, `rgba(255, 255, 255, ${alpha})`);
    gradient.addColorStop(1, `rgba(255, 255, 255, ${alpha * 0.5})`);
    
    ctx.fillStyle = gradient;
    ctx.shadowColor = `rgba(180, 255, 255, ${alpha})`;
    ctx.shadowBlur = 20 * alpha;
    
    // Teken de tekst in het midden
    ctx.fillText(text, width / 2, height / 2);
    
    ctx.restore();
}

// ====================================================================
// 148. The Seed of Light (Lichtzaad)
// ====================================================================
ANIMATION_LOGIC[148] = (function() {
    const uniqueState = { 
        totalFrames: 100, 
        currentFrame: 0,
        textMessage: "" 
    };

    function init() {
        uniqueState.currentFrame = 0;
        const randomIndex = Math.floor(Math.random() * WELCOME_MESSAGES.length);
        uniqueState.textMessage = WELCOME_MESSAGES[randomIndex].text;
    }
    
    function animate() {
        const t = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedT = easeInOutQuint(t); 
        const { width, height } = canvas;
        const centerX = width / 2;
        const centerY = height / 2;
        
        ctx.clearRect(0, 0, width, height);

        // 1. Oude afbeelding: Fade out en krimp
        const scaleOld = lerp(1, 0, easedT);
        ctx.save();
        ctx.globalAlpha = 1 - easedT;
        ctx.translate(centerX, centerY);
        ctx.scale(scaleOld, scaleOld);
        ctx.drawImage(currentImage, -centerX, -centerY, width, height);
        ctx.restore();

        // 2. Nieuwe afbeelding: Groei vanuit een punt (Lichtzaad)
        // Gebruik de Fibonacci reeks om de onthulling een organisch/fractal gevoel te geven
        const maxDim = Math.max(width, height);
        const radius = maxDim * easedT; 
        
        ctx.save();
        ctx.beginPath();
        // Gebruik een willekeurige start hoek om de spiraal te variren
        let angle = 0; 
        for (let i = 0; i < 300; i++) {
            // Gouden hoek (ongeveer 137.5 graden)
            angle += 2.39996; 
            const dist = (i / 300) * radius;
            const x = centerX + Math.cos(angle) * dist;
            const y = centerY + Math.sin(angle) * dist;
            if (i === 0) { ctx.moveTo(x, y); } else { ctx.lineTo(x, y); }
        }
        ctx.clip(); // Clip gebied is de gespiraliseerde vorm (voor een organisch effect)
        ctx.drawImage(nextImage, 0, 0, width, height);
        ctx.restore();

        // 3. Tekst
        drawSpiritualText(t, uniqueState.textMessage);
        
        if (uniqueState.currentFrame < uniqueState.totalFrames) {
            uniqueState.currentFrame++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, width, height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();


// ====================================================================
// 149. Aura Shift (Aura Verschuiving)
// ====================================================================
ANIMATION_LOGIC[149] = (function() {
    const uniqueState = { 
        totalFrames: 120, 
        currentFrame: 0, 
        textMessage: "" 
    };

    function init() {
        uniqueState.currentFrame = 0;
        const randomIndex = Math.floor(Math.random() * WELCOME_MESSAGES.length);
        uniqueState.textMessage = WELCOME_MESSAGES[randomIndex].text;
    }
    
    function animate() {
        const t = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedT = easeInOutQuint(t); 
        const { width, height } = canvas;
        
        ctx.clearRect(0, 0, width, height);
        
        // FASE 1: Oude Afbeelding (Desaturatie en Expansie)
        if (t < 0.5) {
            const progress = easedT * 2;
            const blur = lerp(0, 30, progress); // Wazige 'Aura'
            const alpha = lerp(1, 0.2, progress);
            
            // Teken de oude afbeelding met wazigheid en lage alfa
            ctx.filter = `grayscale(${progress}) blur(${blur}px)`;
            ctx.globalAlpha = alpha;
            ctx.drawImage(currentImage, 0, 0, width, height);
            ctx.filter = 'none'; // Reset voor de volgende fase
        }

        // FASE 2: Nieuwe Afbeelding (Inwaartse Focus)
        if (t >= 0.5) {
            const progress = (easedT - 0.5) * 2;
            const scale = lerp(0.5, 1, progress); // Komt van een ingezoomde/gefocuste staat
            const alpha = lerp(0, 1, progress);

            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.translate(width/2, height/2);
            ctx.scale(scale, scale);
            ctx.drawImage(nextImage, -width/2, -height/2, width, height);
            ctx.restore();
        } else {
             // Zorg ervoor dat de oude afbeelding volledig getekend is in fase 1
             if (t < 0.5) {
                 ctx.globalAlpha = 1;
                 ctx.drawImage(currentImage, 0, 0, width, height);
             }
        }
        
        // 3. Tekst
        drawSpiritualText(t, uniqueState.textMessage);

        if (uniqueState.currentFrame < uniqueState.totalFrames) {
            uniqueState.currentFrame++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, width, height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();


// ====================================================================
// 150. The Golden Ratio Unfold (Gulden Snede Onthulling)
// ====================================================================
ANIMATION_LOGIC[150] = (function() {
    const uniqueState = { 
        totalFrames: 100, 
        currentFrame: 0,
        textMessage: "",
        startAngle: 0
    };

    function init() {
        uniqueState.currentFrame = 0;
        const randomIndex = Math.floor(Math.random() * WELCOME_MESSAGES.length);
        uniqueState.textMessage = WELCOME_MESSAGES[randomIndex].text;
        uniqueState.startAngle = Math.random() * 2 * Math.PI;
    }
    
    function animate() {
        const t = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedT = easeInOutQuint(t); 
        const { width, height } = canvas;
        const maxDim = Math.max(width, height);
        const centerX = width / 2;
        const centerY = height / 2;
        
        ctx.clearRect(0, 0, width, height);

        // 1. Oude afbeelding als achtergrond
        ctx.drawImage(currentImage, 0, 0, width, height);

        // 2. Nieuwe afbeelding geclipped door de Gulden Spiraal (Fibonacci)
        ctx.save();
        
        ctx.beginPath();
        const numTurns = 5 * easedT; // Aantal draaiingen in de spiraal
        
        // Gulden ratio (Phi) = 1.6180339887...
        const phi = 1.6180339887; 
        const b = 0.5 * phi / (2 * Math.PI); // Spiraal constante
        
        // Maak de spiraal groter met de tijd
        for (let theta = uniqueState.startAngle; theta < uniqueState.startAngle + numTurns * 2 * Math.PI; theta += 0.1) {
            const r = maxDim * Math.pow(phi, theta / (2 * Math.PI)); // Exponentile groei
            const x = centerX + r * Math.cos(theta);
            const y = centerY + r * Math.sin(theta);
            if (theta === uniqueState.startAngle) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        }
        // Maak de spiraal compleet door terug te clippen naar de randen
        ctx.lineTo(width, height);
        ctx.lineTo(0, height);
        ctx.lineTo(0, 0);
        ctx.clip();
        
        ctx.drawImage(nextImage, 0, 0, width, height); 
        
        ctx.restore();

        // 3. Tekst
        drawSpiritualText(t, uniqueState.textMessage);

        if (uniqueState.currentFrame < uniqueState.totalFrames) {
            uniqueState.currentFrame++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, width, height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();


// ====================================================================
// 151. Universal Meditation (Universele Meditatie)
// ====================================================================
ANIMATION_LOGIC[151] = (function() {
    const uniqueState = { 
        totalFrames: 150, 
        currentFrame: 0,
        textMessage: "",
        noiseMap: null
    };

    // Een eenvoudige ruis generator om een 'statische' meditatie te simuleren
    function getNoise(x, y) {
        return Math.sin(x * 0.1 + uniqueState.currentFrame * 0.05) * Math.cos(y * 0.1 + uniqueState.currentFrame * 0.05);
    }

    function init() {
        uniqueState.currentFrame = 0;
        const randomIndex = Math.floor(Math.random() * WELCOME_MESSAGES.length);
        uniqueState.textMessage = WELCOME_MESSAGES[randomIndex].text;
    }
    
    function animate() {
        const t = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedT = easeInOutQuint(t); 
        const { width, height } = canvas;
        const centerX = width / 2;
        const centerY = height / 2;
        
        ctx.clearRect(0, 0, width, height);

        // FASE 1: Oude afbeelding (Dissolve via ruis)
        ctx.save();
        // Alpha zakt van 1 naar 0
        const oldAlpha = lerp(1, 0, t); 
        
        // Creer een maskereffect op basis van ruis
        for (let x = 0; x < width; x += 5) {
            for (let y = 0; y < height; y += 5) {
                const noiseVal = getNoise(x, y);
                // Hoe dichter bij 0.5 de ruis is, hoe sneller het stuk verdwijnt
                const threshold = lerp(0.5, 0.2, t);
                
                if (Math.abs(noiseVal) > threshold) {
                     ctx.globalAlpha = oldAlpha * 0.5; // Subtiele vervaging
                     ctx.drawImage(currentImage, x, y, 5, 5, x, y, 5, 5);
                }
            }
        }
        ctx.restore();

        // FASE 2: Nieuwe afbeelding (Kristallisatie en Ademhaling)
        // Schaal pulserend: 0.9 -> 1.1 -> 1.0
        const scale = lerp(0.9, 1.1, Math.sin(t * Math.PI));
        
        ctx.save();
        ctx.globalAlpha = easedT;
        ctx.translate(centerX, centerY);
        ctx.scale(scale, scale);
        ctx.drawImage(nextImage, -centerX, -centerY, width, height);
        ctx.restore();

        // 3. Tekst
        drawSpiritualText(t, uniqueState.textMessage);

        if (uniqueState.currentFrame < uniqueState.totalFrames) {
            uniqueState.currentFrame++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, width, height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();


// ====================================================================
// 152. Sacred Geometry Reveal (Bloem des Levens)
// ====================================================================
ANIMATION_LOGIC[152] = (function() {
    const uniqueState = { 
        totalFrames: 120, 
        currentFrame: 0,
        textMessage: "",
    };

    function init() {
        uniqueState.currentFrame = 0;
        const randomIndex = Math.floor(Math.random() * WELCOME_MESSAGES.length);
        uniqueState.textMessage = WELCOME_MESSAGES[randomIndex].text;
    }
    
    function animate() {
        const t = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedT = easeInOutQuint(t); 
        const { width, height } = canvas;
        const centerX = width / 2;
        const centerY = height / 2;
        
        ctx.clearRect(0, 0, width, height);
        ctx.drawImage(currentImage, 0, 0, width, height);

        // Basis straal van de cirkels (groeit tot buiten het scherm)
        const radius = Math.max(width, height) / 3 * easedT;
        
        ctx.save();
        ctx.beginPath();
        
        // Flower of Life-patroon: Begin met de centrale cirkel
        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);

        // Voeg 6 omringende cirkels toe die elkaar overlappen
        const hexPoints = [];
        for (let i = 0; i < 6; i++) {
            const angle = i * Math.PI / 3;
            const x = centerX + radius * Math.cos(angle);
            const y = centerY + radius * Math.sin(angle);
            
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            hexPoints.push({ x, y });
        }
        
        // Optioneel: Derde laag cirkels op de snijpunten
        if (easedT > 0.5) {
            const radius2 = radius / 1.5;
            for (let i = 0; i < 6; i++) {
                const angle1 = i * Math.PI / 3;
                const angle2 = (i + 1) * Math.PI / 3;
                
                const x1 = centerX + radius * Math.cos(angle1);
                const y1 = centerY + radius * Math.sin(angle1);
                const x2 = centerX + radius * Math.cos(angle2);
                const y2 = centerY + radius * Math.sin(angle2);
                
                // Midden tussen twee punten om de derde laag te creren
                const midX = (x1 + x2) / 2;
                const midY = (y1 + y2) / 2;
                
                // Extra cirkel in het midden van de 'petals'
                ctx.arc(midX, midY, radius2, 0, 2 * Math.PI);
            }
        }
        
        ctx.clip(); // Clip de nieuwe afbeelding in dit patroon
        ctx.drawImage(nextImage, 0, 0, width, height); 
        ctx.restore();

        // 3. Tekst
        drawSpiritualText(t, uniqueState.textMessage);

        if (uniqueState.currentFrame < uniqueState.totalFrames) {
            uniqueState.currentFrame++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, width, height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();


// ====================================================================
// 153. The Infinite Plane (Het Oneindige Vlak)
// ====================================================================
ANIMATION_LOGIC[153] = (function() {
    const uniqueState = { 
        totalFrames: 90, 
        currentFrame: 0,
        textMessage: "",
    };

    function init() {
        uniqueState.currentFrame = 0;
        const randomIndex = Math.floor(Math.random() * WELCOME_MESSAGES.length);
        uniqueState.textMessage = WELCOME_MESSAGES[randomIndex].text;
    }
    
    function animate() {
        const t = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedT = easeInOutQuint(t); 
        const { width, height } = canvas;
        
        ctx.clearRect(0, 0, width, height);
        
        // Oude Afbeelding: Kantelt en krimpt in de verte (verdwijnt in het 'Oneindige Vlak')
        ctx.save();
        const shearX = lerp(0, 0.5, easedT); 
        const scaleY = lerp(1, 0.1, easedT); 
        const translateY = lerp(0, height * 0.5, easedT);

        // Stapsgewijze transformatie om perspectief te simuleren
        ctx.translate(width / 2, height / 2);
        ctx.transform(1, 0, shearX, scaleY, 0, translateY);
        ctx.globalAlpha = 1 - easedT;
        ctx.drawImage(currentImage, -width / 2, -height / 2, width, height);
        ctx.restore();

        // Nieuwe Afbeelding: Kantelt en groeit uit de verte
        ctx.save();
        const shearXNew = lerp(-0.5, 0, easedT); 
        const scaleYNew = lerp(0.1, 1, easedT);
        const translateYNew = lerp(height * 0.5, 0, easedT);

        ctx.translate(width / 2, height / 2);
        ctx.transform(1, 0, shearXNew, scaleYNew, 0, translateYNew);
        ctx.globalAlpha = easedT;
        ctx.drawImage(nextImage, -width / 2, -height / 2, width, height);
        ctx.restore();
        
        // 3. Tekst
        drawSpiritualText(t, uniqueState.textMessage);

        if (uniqueState.currentFrame < uniqueState.totalFrames) {
            uniqueState.currentFrame++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, width, height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();


// ====================================================================
// 154. Vibrational Echo (Vibratie Echo)
// ====================================================================
ANIMATION_LOGIC[60] = (function() {
    const uniqueState = { 
        totalFrames: 80, 
        currentFrame: 0,
        textMessage: "",
        numStrips: 40,
    };

    function init() {
        uniqueState.currentFrame = 0;
        const randomIndex = Math.floor(Math.random() * WELCOME_MESSAGES.length);
        uniqueState.textMessage = WELCOME_MESSAGES[randomIndex].text;
    }
    
    function animate() {
        const t = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedT = easeInOutQuint(t); 
        const { width, height } = canvas;
        const stripH = height / uniqueState.numStrips;
        
        ctx.clearRect(0, 0, width, height);

        // De nieuwe afbeelding is de basis
        ctx.drawImage(nextImage, 0, 0, width, height);
        
        // De 'schok' amplitude is maximaal in het midden (t=0.5)
        const amplitude = 50 * Math.sin(t * Math.PI); 
        
        for (let i = 0; i < uniqueState.numStrips; i++) {
            const y = i * stripH;
            
            // Variabele schokfase, hoger/lager op basis van de index en tijd
            const wave = Math.sin(i * 0.3 + t * Math.PI * 8); 
            const displacement = amplitude * wave;

            ctx.save();
            ctx.beginPath();
            ctx.rect(0, y, width, stripH);
            ctx.clip();
            
            // Vertaal om de oude afbeelding te 'schudden'
            ctx.translate(displacement, 0); 
            
            // De oude afbeelding vervaagt terwijl hij trilt
            ctx.globalAlpha = 1 - easedT;
            ctx.drawImage(currentImage, 0, 0, width, height);
            
            ctx.restore();
        }
        
        // 3. Tekst
        drawSpiritualText(t, uniqueState.textMessage);

        if (uniqueState.currentFrame < uniqueState.totalFrames) {
            uniqueState.currentFrame++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, width, height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();


// ====================================================================
// 155. Emergence from Void (Opkomst uit de Leegte)
// ====================================================================
ANIMATION_LOGIC[136] = (function() {
    const uniqueState = { 
        totalFrames: 140, 
        currentFrame: 0,
        textMessage: "",
    };

    function init() {
        uniqueState.currentFrame = 0;
        const randomIndex = Math.floor(Math.random() * WELCOME_MESSAGES.length);
        uniqueState.textMessage = WELCOME_MESSAGES[randomIndex].text;
    }
    
    function animate() {
        const t = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedT = easeInOutQuint(t); 
        const { width, height } = canvas;
        
        ctx.clearRect(0, 0, width, height);

        // FASE 1 (t=0 tot 0.5): Oude afbeelding gaat naar Zwart-Wit en vervaagt
        if (t < 0.5) {
            const progress = easedT * 2;
            const saturation = lerp(1, 0, progress); // Saturatie van 100% naar 0%
            const blur = lerp(0, 5, progress); 
            const alpha = lerp(1, 0, progress);

            ctx.filter = `grayscale(${100 - saturation * 100}%) blur(${blur}px)`;
            ctx.globalAlpha = alpha;
            ctx.drawImage(currentImage, 0, 0, width, height);
            ctx.filter = 'none';
        }

        // FASE 2 (t=0.5 tot 1.0): Nieuwe afbeelding verschijnt uit Zwart-Wit
        if (t >= 0.5) {
            const progress = (easedT - 0.5) * 2;
            const saturation = lerp(0, 1, progress); // Saturatie van 0% naar 100%
            const alpha = lerp(0, 1, progress);

            ctx.filter = `grayscale(${100 - saturation * 100}%)`;
            ctx.globalAlpha = alpha;
            ctx.drawImage(nextImage, 0, 0, width, height);
            ctx.filter = 'none';
        }
        
        // 3. Tekst (de tekst is het helderst in de leegte/tussenfase)
        drawSpiritualText(t, uniqueState.textMessage);

        if (uniqueState.currentFrame < uniqueState.totalFrames) {
            uniqueState.currentFrame++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, width, height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();


// ====================================================================
// 156. Crystal Lattice (Kristalrooster)
// ====================================================================
ANIMATION_LOGIC[127] = (function() {
    const uniqueState = { 
        totalFrames: 120, 
        currentFrame: 0,
        textMessage: "",
        numX: 15,
        numY: 15
    };

    function init() {
        uniqueState.currentFrame = 0;
        const randomIndex = Math.floor(Math.random() * WELCOME_MESSAGES.length);
        uniqueState.textMessage = WELCOME_MESSAGES[randomIndex].text;
    }
    
    function animate() {
        const t = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedT = easeInOutQuint(t); 
        const { width, height } = canvas;
        
        const pieceW = width / uniqueState.numX;
        const pieceH = height / uniqueState.numY;
        
        ctx.clearRect(0, 0, width, height);
        
        for (let y = 0; y < uniqueState.numY; y++) {
            for (let x = 0; x < uniqueState.numX; x++) {
                const startX = x * pieceW;
                const startY = y * pieceH;
                const centerX = startX + pieceW / 2;
                const centerY = startY + pieceH / 2;

                ctx.save();
                ctx.translate(centerX, centerY);

                // Rotatie van 0 tot 180 graden (PI radialen)
                const rotation = easedT * Math.PI; 
                ctx.rotate(rotation);
                
                // Bij 90 graden (t=0.5) is de schaal X 0
                const scaleX = Math.abs(1 - 2 * t);
                ctx.scale(scaleX, 1);
                
                // Bepaal welke afbeelding te tekenen (voor 90 graden/t=0.5 switch)
                const imageToDraw = t < 0.5 ? currentImage : nextImage;
                
                ctx.drawImage(
                    imageToDraw, 
                    startX, startY, pieceW, pieceH, // Bron
                    -pieceW / 2, -pieceH / 2, pieceW, pieceH // Bestemming (gecentreerd)
                );
                
                ctx.restore();
            }
        }
        
        // 3. Tekst
        drawSpiritualText(t, uniqueState.textMessage);

        if (uniqueState.currentFrame < uniqueState.totalFrames) {
            uniqueState.currentFrame++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, width, height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();


// ====================================================================
// 157. The Flow State (Hydrodynamische Oplossing)
// ====================================================================
ANIMATION_LOGIC[124] = (function() {
    const uniqueState = { 
        totalFrames: 110, 
        currentFrame: 0,
        textMessage: "",
        numStrips: 80, // Fijnmazig effect
        maxDisplacement: 100,
    };

    function init() {
        uniqueState.currentFrame = 0;
        const randomIndex = Math.floor(Math.random() * WELCOME_MESSAGES.length);
        uniqueState.textMessage = WELCOME_MESSAGES[randomIndex].text;
    }
    
    function animate() {
        const t = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedT = easeInOutQuint(t); 
        const { width, height } = canvas;
        const stripW = width / uniqueState.numStrips;
        
        ctx.clearRect(0, 0, width, height);
        
        for (let i = 0; i < uniqueState.numStrips; i++) {
            const x = i * stripW;
            
            // Golf- en ruiseffect voor de y-verplaatsing
            const wave = Math.sin(i * 0.1 + t * Math.PI * 4);
            const displacement = uniqueState.maxDisplacement * wave * Math.sin(t * Math.PI); // Maximaal op t=0.5
            
            // Oude Afbeelding (schuift uit met golven)
            ctx.save();
            ctx.beginPath();
            ctx.rect(x, 0, stripW, height);
            ctx.clip();
            ctx.translate(0, displacement * (1 - easedT)); 
            ctx.globalAlpha = 1 - easedT;
            ctx.drawImage(currentImage, 0, 0, width, height);
            ctx.restore();
            
            // Nieuwe Afbeelding (schuift in met golven)
            ctx.save();
            ctx.beginPath();
            ctx.rect(x, 0, stripW, height);
            ctx.clip();
            ctx.translate(0, displacement * easedT); 
            ctx.globalAlpha = easedT;
            ctx.drawImage(nextImage, 0, 0, width, height);
            ctx.restore();
        }
        
        // 3. Tekst
        drawSpiritualText(t, uniqueState.textMessage);

        if (uniqueState.currentFrame < uniqueState.totalFrames) {
            uniqueState.currentFrame++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, width, height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();


// ====================================================================
// 158. The Unfolding Mandala (De Ontvouwende Mandala)
// ====================================================================
ANIMATION_LOGIC[119] = (function() {
    const uniqueState = { 
        totalFrames: 120, 
        currentFrame: 0,
        textMessage: "",
        numPetals: 12,
    };

    function init() {
        uniqueState.currentFrame = 0;
        const randomIndex = Math.floor(Math.random() * WELCOME_MESSAGES.length);
        uniqueState.textMessage = WELCOME_MESSAGES[randomIndex].text;
    }
    
    function animate() {
        const t = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedT = easeInOutQuint(t); 
        const { width, height } = canvas;
        const centerX = width / 2;
        const centerY = height / 2;
        const maxDim = Math.max(width, height);
        
        ctx.clearRect(0, 0, width, height);

        // De nieuwe afbeelding is zichtbaar in het midden (in de kern)
        const coreRadius = maxDim * easedT; 
        ctx.save();
        ctx.beginPath();
        ctx.arc(centerX, centerY, coreRadius * 0.1, 0, 2 * Math.PI);
        ctx.clip();
        ctx.drawImage(nextImage, 0, 0, width, height);
        ctx.restore();

        // Oude Afbeelding: Verdeeld in 'Bloembladen' die naar buiten schuiven
        for (let i = 0; i < uniqueState.numPetals; i++) {
            const angle = i * 2 * Math.PI / uniqueState.numPetals;
            const nextAngle = (i + 1) * 2 * Math.PI / uniqueState.numPetals;
            
            // Verplaatsing is maximaal op t=0.5 (midden van de transitie)
            const displacement = maxDim * 0.5 * Math.sin(t * Math.PI);

            ctx.save();
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.arc(centerX, centerY, maxDim, angle, nextAngle);
            ctx.closePath();
            ctx.clip();
            
            // Schuif elk bloemblad weg van het centrum
            const dx = Math.cos(angle + Math.PI / uniqueState.numPetals) * displacement;
            const dy = Math.sin(angle + Math.PI / uniqueState.numPetals) * displacement;
            
            ctx.translate(dx, dy);
            ctx.globalAlpha = 1 - easedT;
            ctx.drawImage(currentImage, 0, 0, width, height);
            ctx.restore();
        }

        // 3. Tekst
        drawSpiritualText(t, uniqueState.textMessage);

        if (uniqueState.currentFrame < uniqueState.totalFrames) {
            uniqueState.currentFrame++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, width, height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();


// ====================================================================
// 159. Chakra Fade (Chakra Vervaagt)
// ====================================================================
ANIMATION_LOGIC[118] = (function() {
    const uniqueState = { 
        totalFrames: 140, 
        currentFrame: 0,
        textMessage: "",
        numChakras: 7,
    };
    // Chakra kleuren van beneden naar boven: Rood, Oranje, Geel, Groen, Blauw, Indigo, Violet
    const chakraColors = ["#FF0000", "#FF8C00", "#FFFF00", "#00FF00", "#0000FF", "#4B0082", "#EE82EE"];

    function init() {
        uniqueState.currentFrame = 0;
        const randomIndex = Math.floor(Math.random() * WELCOME_MESSAGES.length);
        uniqueState.textMessage = WELCOME_MESSAGES[randomIndex].text;
    }
    
    function animate() {
        const t = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedT = easeInOutQuint(t); 
        const { width, height } = canvas;
        const stripH = height / uniqueState.numChakras;
        
        ctx.clearRect(0, 0, width, height);

        // Teken de nieuwe afbeelding als basis
        ctx.drawImage(nextImage, 0, 0, width, height);

        for (let i = 0; i < uniqueState.numChakras; i++) {
            const y = i * stripH;
            
            // De alpha van de Oude Afbeelding is afhankelijk van de positie.
            // De transitie "opent" van beneden naar boven, in lijn met de chakra's.
            const alphaProgress = Math.min(1, Math.max(0, (easedT * 1.5) - (i / uniqueState.numChakras)));
            const currentAlpha = 1 - alphaProgress;

            ctx.save();
            ctx.beginPath();
            ctx.rect(0, y, width, stripH);
            ctx.clip();

            // Voeg een subtiele kleurlaag toe die verdwijnt
            ctx.globalAlpha = currentAlpha * 0.5;
            ctx.fillStyle = chakraColors[uniqueState.numChakras - 1 - i]; // Kleuren van boven naar beneden
            ctx.fillRect(0, y, width, stripH);

            // Teken de oude afbeelding in de clip
            ctx.globalAlpha = currentAlpha; 
            ctx.drawImage(currentImage, 0, 0, width, height);
            
            ctx.restore();
        }
        
        // 3. Tekst
        drawSpiritualText(t, uniqueState.textMessage);

        if (uniqueState.currentFrame < uniqueState.totalFrames) {
            uniqueState.currentFrame++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, width, height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();



// ====================================================================
// 160. The Observer Effect (De Waarnemer)
// Geoptimaliseerd: Grid size verhoogd van 5 naar 10 en totalFrames verlaagd
// ====================================================================
ANIMATION_LOGIC[117] = (function() {
    const uniqueState = { 
        totalFrames: 90, // Verlaagd van 150 naar 90 (1.5 seconde)
        currentFrame: 0,
        textMessage: "",
        gridStep: 10 // VERHOOGD van 5 naar 10: 4x minder draw calls
    };
    
    // Functie om de tekst/emoji's te tekenen (aanname dat deze elders is gedefinieerd)
    // Deze functie moet nog de juiste data uit de HEALING_MESSAGES array halen, 
    // aangezien de originele code WELCOME_MESSAGES gebruikte (wat fout was voor deze context).
    function drawHealingText(t, message) {
        if (!ctx || !canvas) return;
        
        // Simpele tekstweergave voor de demo
        const alpha = Math.sin(t * Math.PI); 
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.textAlign = 'center';
        ctx.font = `30px 'Inter', sans-serif`;
        ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
        ctx.fillText(message, canvas.width / 2, canvas.height / 2);
        ctx.restore();
    }

    // Voorbeeld data om te gebruiken, aangezien WELCOME_MESSAGES niet is gedefinieerd
    const FALLBACK_MESSAGE = "Focus en Introspectie";

    function init() {
        uniqueState.currentFrame = 0;
        // Gebruik een eenvoudige fallback of een placeholder om de init te laten werken
        uniqueState.textMessage = FALLBACK_MESSAGE; 
    }
    
    function animate() {
        const t = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedT = easeInOutQuint(t); 
        const { width, height } = canvas;
        // Hardcoded positie voor het "Waarnemer" effect (ongeveer 2/3 van de breedte, 1/3 van de hoogte)
        const observerX = Math.floor(width / 1.5);
        const observerY = Math.floor(height / 2.5);
        const maxDist = Math.max(width, height) / 2;
        
        ctx.clearRect(0, 0, width, height);

        for (let x = 0; x < width; x += uniqueState.gridStep) {
            for (let y = 0; y < height; y += uniqueState.gridStep) {
                
                // Afstand van de waarnemer tot dit punt
                const dist = Math.sqrt(Math.pow(x - observerX, 2) + Math.pow(y - observerY, 2));
                // Genormaliseerde afstand (0 = bij waarnemer, 1 = ver weg)
                const distNorm = Math.min(1, dist / maxDist);
                
                // Hoe dichter bij de waarnemer, hoe meer "getransitoneerd"
                const localT = easedT + (distNorm * (1 - easedT) * 0.5); 
                
                // Alpha van de Oude Afbeelding (verdwijnt sneller bij de waarnemer)
                const alphaOld = lerp(1, 0, localT);
                
                const step = uniqueState.gridStep;

                // Teken de Oude Afbeelding
                ctx.save();
                ctx.globalAlpha = alphaOld;
                ctx.drawImage(currentImage, x, y, step, step, x, y, step, step);
                ctx.restore();
                
                // Teken de Nieuwe Afbeelding
                ctx.save();
                ctx.globalAlpha = 1 - alphaOld;
                ctx.drawImage(nextImage, x, y, step, step, x, y, step, step);
                ctx.restore();
            }
        }
        
        // Tekst (gebruikt de drawHealingText zoals gesuggereerd)
        drawHealingText(t, uniqueState.textMessage);

        if (uniqueState.currentFrame < uniqueState.totalFrames) {
            uniqueState.currentFrame++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, width, height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();

// ====================================================================
// 161. Ascension Path (Ascensie Pad)
// ====================================================================
ANIMATION_LOGIC[113] = (function() {
    const uniqueState = { 
        totalFrames: 100, 
        currentFrame: 0,
        textMessage: "",
        numBands: 60
    };

    function init() {
        uniqueState.currentFrame = 0;
        const randomIndex = Math.floor(Math.random() * WELCOME_MESSAGES.length);
        uniqueState.textMessage = WELCOME_MESSAGES[randomIndex].text;
    }
    
    function animate() {
        const t = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedT = easeInOutQuint(t); 
        const { width, height } = canvas;
        const bandW = width / uniqueState.numBands;
        const maxShift = height; // Shift van een volledige hoogte
        
        ctx.clearRect(0, 0, width, height);

        for (let i = 0; i < uniqueState.numBands; i++) {
            const x = i * bandW;
            
            // De verschuiving is verticaal en varieert per band (een helix-pad)
            const spiralShift = Math.sin(i * 0.4 + t * Math.PI * 4) * 20;
            
            // Verticale verschuiving: van 0 naar -maxShift (omhoog)
            const shiftY = lerp(0, -maxShift, easedT) + spiralShift;
            
            // Oude Afbeelding: Schuift uit en vervaagt
            ctx.save();
            ctx.beginPath();
            ctx.rect(x, 0, bandW, height);
            ctx.clip();
            ctx.translate(0, shiftY * (1 - easedT)); 
            ctx.globalAlpha = 1 - easedT;
            ctx.drawImage(currentImage, 0, 0, width, height);
            ctx.restore();
            
            // Nieuwe Afbeelding: Schuift in van onderaf en verschijnt
            ctx.save();
            ctx.beginPath();
            ctx.rect(x, 0, bandW, height);
            ctx.clip();
            ctx.translate(0, shiftY * easedT + maxShift * (1 - easedT)); 
            ctx.globalAlpha = easedT;
            ctx.drawImage(nextImage, 0, 0, width, height);
            ctx.restore();
        }
        
        // 3. Tekst
        drawSpiritualText(t, uniqueState.textMessage);

        if (uniqueState.currentFrame < uniqueState.totalFrames) {
            uniqueState.currentFrame++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, width, height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();


// ====================================================================
// 162. Cosmic Breath (Kosmische Adem)
// ====================================================================
ANIMATION_LOGIC[147] = (function() {
    const uniqueState = { 
        totalFrames: 160, // Lange ademhaling
        currentFrame: 0,
        textMessage: "",
    };

    function init() {
        uniqueState.currentFrame = 0;
        const randomIndex = Math.floor(Math.random() * WELCOME_MESSAGES.length);
        uniqueState.textMessage = WELCOME_MESSAGES[randomIndex].text;
    }
    
    function animate() {
        const t = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedT = easeInOutQuint(t); 
        const { width, height } = canvas;
        const centerX = width / 2;
        const centerY = height / 2;
        
        ctx.clearRect(0, 0, width, height);

        // De ademhalingsschaal (gaat van 1 naar 1.1 en terug naar 1)
        const breathScale = 1 + 0.1 * Math.sin(t * Math.PI); 
        
        // --- Oude Afbeelding: Zoom uit en vervaag ---
        ctx.save();
        ctx.globalAlpha = 1 - easedT;
        ctx.translate(centerX, centerY);
        ctx.scale(breathScale, breathScale);
        ctx.drawImage(currentImage, -centerX, -centerY, width, height);
        ctx.restore();

        // --- Nieuwe Afbeelding: Zoom in en verschijn met radiale gloed ---
        ctx.save();
        ctx.globalAlpha = easedT;
        ctx.translate(centerX, centerY);
        ctx.scale(breathScale, breathScale);
        
        // Radiale Gloed: Teken een lichte gloed achter de nieuwe afbeelding
        if (easedT > 0.1) {
            const glowRadius = Math.max(width, height) * easedT * 0.8;
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, glowRadius);
            gradient.addColorStop(0, `rgba(255, 255, 255, ${easedT * 0.5})`);
            gradient.addColorStop(1, `rgba(255, 255, 255, 0)`);
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, 0, glowRadius, 0, 2 * Math.PI);
            ctx.fill();
        }
        
        ctx.drawImage(nextImage, -centerX, -centerY, width, height);
        ctx.restore();

        // 3. Tekst
        drawSpiritualText(t, uniqueState.textMessage);

        if (uniqueState.currentFrame < uniqueState.totalFrames) {
            uniqueState.currentFrame++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, width, height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();





// ====================================================================
// Gedeelde Data en Hulpfuncties
// ====================================================================

// Gecombineerde data uit de 'spiritueel_weer_herstel.md' tabel
const HEALING_MESSAGES = [
    { text: "De Innerlijke Lentezon", emojis: "" }, // 1. Regeneratie & Celvernieuwing
    { text: "Stille Nachtrustmist", emojis: "" },     // 2. Slaapcyclus Optimalisatie
    { text: "Emotionele Hogedrukzone", emojis: "" },   // 3. Neuroplasticiteit
    { text: "De Zuiverende Dankbaarheidsbui", emojis: "" }, // 4. Stress-Adaptatie
    { text: "Mentale Windstilte", emojis: "" },     // 5. Homeostase
    { text: "Creatieve Onweerswolk", emojis: "" },   // 6. Divergent Denken
    { text: "Helende Mist van Acceptatie", emojis: "" }, // 7. Fysiologische Bufferzone
    { text: "De Zelfcompassie", emojis: "" }, // 8. Hechting en Sociale Immuniteit
    { text: "Intutieve Poollicht", emojis: "" },    // 9. Biofeedback
    { text: "Vrolijke Warmtefront (Humor)", emojis: "" }, // 10. Endogene Farmacologie
    { text: "Kritische Zelfreflectie Hagel", emojis: "" }, // 11. Feedback Loops
    { text: "De Aarding Dichte Sneeuwval", emojis: "" }, // 12. Posturale Stabilisatie (Anker ipv anchor)
    { text: "Geduldige Dageraad Daling", emojis: "" }, // 13. Energiebehoud
    { text: "Transformatieve Windvlaag", emojis: "" }, // 14. Adaptieve Response Systeem
    { text: "De Ethische Noorderster", emojis: "" }    // 15. Integriteit van het Zelfsysteem
];



/**
 * Tekent de gecombineerde boodschap (Tekst + Emoji's) met een pulserend, helend effect.
 * @param {number} t De geaste progress van de animatie (0 tot 1).
 * @param {object} message Het object met 'text' en 'emojis'.
 */
function drawHealingText(t, message) {
    if (!ctx || !canvas) return;
    
    const { width, height } = canvas;
    const easedT = easeInOutQuint(t);
    const alpha = Math.sin(t * Math.PI); // Gaat van 0 -> 1 -> 0
    
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.textAlign = 'center';
    
    // --- Emoji's (Gezond Verstand) ---
    const emojiScale = 1.5 + 0.5 * Math.sin(easedT * Math.PI); 
    ctx.font = `${60 * emojiScale}px sans-serif`;
    ctx.textBaseline = 'bottom';
    ctx.fillText(message.emojis, width / 2, height / 2 - 20);
    
    // --- Tekst (Spiritueel Weer) ---
    ctx.font = `30px 'Inter', sans-serif`;
    ctx.textBaseline = 'top';
    
    const gradient = ctx.createLinearGradient(0, 0, width, 0);
    gradient.addColorStop(0, `rgba(180, 255, 200, ${alpha * 0.2})`);
    gradient.addColorStop(0.5, `rgba(180, 255, 200, ${alpha})`);
    gradient.addColorStop(1, `rgba(180, 255, 200, ${alpha * 0.2})`);
    
    ctx.fillStyle = gradient;
    ctx.shadowColor = `rgba(100, 255, 100, ${alpha * 0.8})`;
    ctx.shadowBlur = 15 * alpha;
    
    ctx.fillText(message.text, width / 2, height / 2 + 30);
    
    ctx.restore();
}

// Functie om willekeurig een boodschap te selecteren
function getRandomMessage() {
    const randomIndex = Math.floor(Math.random() * HEALING_MESSAGES.length);
    return HEALING_MESSAGES[randomIndex];
}

// ====================================================================
// 163. Telomere Fusion (Celvernieuwing)
// Effect: Radiale lijnen trekken samen en fusioneren
// ====================================================================
ANIMATION_LOGIC[102] = (function() {
    const uniqueState = { totalFrames: 100, currentFrame: 0, message: null, numLines: 60 };
    function init() { uniqueState.currentFrame = 0; uniqueState.message = getRandomMessage(); }
    
    function animate() {
        const t = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedT = easeInOutQuint(t); 
        const { width, height } = canvas;
        const centerX = width / 2;
        const centerY = height / 2;
        const maxDim = Math.max(width, height);
        
        ctx.clearRect(0, 0, width, height);

        for (let i = 0; i < uniqueState.numLines; i++) {
            const angle = i * 2 * Math.PI / uniqueState.numLines;
            
            // Begin van de lijn (rand)
            const startX = centerX + Math.cos(angle) * maxDim;
            const startY = centerY + Math.sin(angle) * maxDim;
            
            // Eindpunt (waarmee de lijn samentrekt)
            const endX = lerp(startX, centerX, easedT);
            const endY = lerp(startY, centerY, easedT);
            
            // De oude afbeelding wordt getekend in de samentrekkende lijn
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(endX, endY);
            ctx.lineTo(centerX + Math.cos(angle + 0.05) * maxDim, centerY + Math.sin(angle + 0.05) * maxDim); // Iets bredere lijn
            ctx.closePath();
            ctx.clip();
            ctx.globalAlpha = 1 - easedT;
            ctx.drawImage(currentImage, 0, 0, width, height);
            ctx.restore();
            
            // De nieuwe afbeelding verschijnt in de kern zodra de lijnen samentrekken
            ctx.save();
            ctx.beginPath();
            ctx.arc(centerX, centerY, maxDim * easedT * 0.1, 0, 2 * Math.PI);
            ctx.clip();
            ctx.drawImage(nextImage, 0, 0, width, height);
            ctx.restore();
        }
        
        // Zorg ervoor dat de nieuwe afbeelding de overhand neemt aan het einde
        ctx.globalAlpha = easedT;
        ctx.drawImage(nextImage, 0, 0, width, height);

        drawHealingText(t, uniqueState.message);
        
        if (uniqueState.currentFrame < uniqueState.totalFrames) {
            uniqueState.currentFrame++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, width, height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();


// ====================================================================
// 164. Neural Net Rewiring (Neuroplasticiteit)
// Effect: Fragmenten verschuiven en maken nieuwe verbindingen
// ====================================================================
ANIMATION_LOGIC[90] = (function() {
    const uniqueState = { totalFrames: 120, currentFrame: 0, message: null, gridSize: 10 };
    function init() { uniqueState.currentFrame = 0; uniqueState.message = getRandomMessage(); }
    
    function animate() {
        const t = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedT = easeInOutQuint(t); 
        const { width, height } = canvas;
        const pieceW = width / uniqueState.gridSize;
        const pieceH = height / uniqueState.gridSize;
        
        ctx.clearRect(0, 0, width, height);
        
        for (let y = 0; y < uniqueState.gridSize; y++) {
            for (let x = 0; x < uniqueState.gridSize; x++) {
                const startX = x * pieceW;
                const startY = y * pieceH;
                
                // Chaos (t=0.5): Maximaal verschuiving. Orde (t=0 en t=1): Geen verschuiving.
                const shiftFactor = 1 - Math.abs(1 - 2 * easedT); 
                
                // Unieke 'neurale' verschuiving per stukje (gebruik random offset om chaos te simuleren)
                const offsetX = Math.sin(x * 0.5 + t * 4) * pieceW * shiftFactor * 2;
                const offsetY = Math.cos(y * 0.5 + t * 4) * pieceH * shiftFactor * 2;

                ctx.save();
                ctx.globalAlpha = 1 - shiftFactor; // Zichtbaarheid is maximaal als de verschuiving 0 is
                
                ctx.translate(startX + offsetX, startY + offsetY);
                
                // Teken beide afbeeldingen (Oud vervaagt, Nieuw verschijnt)
                // Oude afbeelding (verdwijnt in chaos)
                ctx.globalAlpha = lerp(1, 0, easedT); 
                ctx.drawImage(currentImage, startX, startY, pieceW, pieceH, 0, 0, pieceW, pieceH);
                
                // Nieuwe afbeelding (verschijnt uit chaos)
                ctx.globalAlpha = lerp(0, 1, easedT);
                ctx.drawImage(nextImage, startX, startY, pieceW, pieceH, 0, 0, pieceW, pieceH);
                
                ctx.restore();
            }
        }
        
        drawHealingText(t, uniqueState.message);

        if (uniqueState.currentFrame < uniqueState.totalFrames) {
            uniqueState.currentFrame++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, width, height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();


// ====================================================================
// 165. Homeostatic Rebound (Homeostase)
// Effect: Gewelddadige verstoring en perfecte terugkeer naar de nieuwe staat
// ====================================================================
ANIMATION_LOGIC[84] = (function() {
    const uniqueState = { totalFrames: 90, currentFrame: 0, message: null, maxWarp: 0.1 };
    function init() { uniqueState.currentFrame = 0; uniqueState.message = getRandomMessage(); }
    
    function animate() {
        const t = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedT = easeInOutQuint(t); 
        const { width, height } = canvas;
        
        ctx.clearRect(0, 0, width, height);

        // De verstoring is maximaal op t=0.5 (Stress-piek)
        const warpFactor = 1 - Math.abs(1 - 2 * easedT); 
        const warpX = Math.sin(t * Math.PI * 10) * uniqueState.maxWarp * width * warpFactor;
        const warpY = Math.cos(t * Math.PI * 10) * uniqueState.maxWarp * height * warpFactor;

        // Oude afbeelding: Vervormt en krimpt
        ctx.save();
        ctx.globalAlpha = 1 - easedT;
        
        ctx.translate(width / 2, height / 2);
        ctx.scale(1 - warpFactor * 0.1, 1 - warpFactor * 0.1); // Subtiele krimp
        
        ctx.drawImage(currentImage, -width / 2 + warpX, -height / 2 + warpY, width, height);
        ctx.restore();

        // Nieuwe afbeelding: Groeit en herstelt (rebound)
        ctx.save();
        ctx.globalAlpha = easedT;
        
        ctx.translate(width / 2, height / 2);
        ctx.scale(1 + warpFactor * 0.1, 1 + warpFactor * 0.1); // Subtiele groei (tegenovergestelde van oud)
        
        ctx.drawImage(nextImage, -width / 2 - warpX, -height / 2 - warpY, width, height);
        ctx.restore();
        
        drawHealingText(t, uniqueState.message);

        if (uniqueState.currentFrame < uniqueState.totalFrames) {
            uniqueState.currentFrame++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, width, height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();


ANIMATION_LOGIC[78] = (function() {
    const uniqueState = { totalFrames: 150, currentFrame: 0, message: null, numCells: 300 };
    
    function init() { 
        uniqueState.currentFrame = 0; 
        // Assume getRandomMessage() is defined elsewhere
        uniqueState.message = getRandomMessage(); 
    }
    
    function animate() {
        // Assume canvas, ctx, lerp, easeInOutQuint, currentImage, 
        // nextImage, drawHealingText, and startNextTransition are defined globally.
        
        const t = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedT = easeInOutQuint(t); 
        const { width, height } = canvas;
        const numCells = uniqueState.numCells;

        ctx.clearRect(0, 0, width, height);

        // 1. Old image (Fade Out)
        ctx.globalAlpha = 1 - easedT;
        ctx.drawImage(currentImage, 0, 0, width, height);
        ctx.globalAlpha = 1; // Reset alpha

        // 2. New image (Clipping/Masking Effect)
        ctx.save();

        // --- Step A: Draw the mask (all circles) ---
        // This is much faster as it avoids repeated compositing changes in the loop.
        ctx.globalCompositeOperation = 'source-over'; 

        for (let i = 0; i < numCells; i++) {
            // Unique position based on index and time
            const randX = (Math.sin(i * 10 + t * 5) * 0.5 + 0.5);
            const randY = (Math.cos(i * 10 + t * 5) * 0.5 + 0.5);
            
            // X/Y position (migrating along an axis)
            const cellX = lerp(width * randX, width * randX + width * 1.5, easedT) % (width * 1.5);
            const cellY = lerp(height * randY, height * randY + height * 1.5, easedT) % (height * 1.5);
            
            // Cell radius (grows slightly)
            const radius = 10 + Math.sin(t * Math.PI) * 5; 
            
            ctx.beginPath();
            ctx.arc(cellX, cellY, radius, 0, 2 * Math.PI);
            
            // The color of the cells is a healing green tint, fading in
            // Alpha here controls the visibility/strength of the mask pixels
            ctx.fillStyle = `rgba(100, 255, 100, ${easedT * 0.75})`;
            ctx.fill();
        }
        
        // --- Step B: Use the mask to clip the NEW image ---
        // 'source-atop' draws the new image only over the area covered by the circles (the mask).
        // This achieves the desired clipping/reveal effect in one call.
        ctx.globalCompositeOperation = 'source-atop'; 
        ctx.drawImage(nextImage, 0, 0, width, height);
        
        ctx.restore(); // Restore globalCompositeOperation to default ('source-over')

        // 3. Simplified blend: Draw the new image over everything for a final fade-in
        // This ensures a smooth full transition if the masking isn't complete.
        ctx.globalAlpha = easedT;
        ctx.drawImage(nextImage, 0, 0, width, height);
        ctx.globalAlpha = 1; // Reset alpha
        
        // Assume drawHealingText() is defined elsewhere
        drawHealingText(t, uniqueState.message);

        if (uniqueState.currentFrame < uniqueState.totalFrames) {
            uniqueState.currentFrame++;
            requestAnimationFrame(animate);
        } else {
            // End state: Ensure nextImage is fully drawn
            ctx.drawImage(nextImage, 0, 0, width, height);
            // Assume startNextTransition() is defined elsewhere
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();

// ====================================================================
// 167. Oxytocin Wave (Hechting en Sociale Immuniteit)
// Effect: Zachte, brede golf van kleur en blur vanuit het centrum
// ====================================================================
ANIMATION_LOGIC[77] = (function() {
    const uniqueState = { totalFrames: 110, currentFrame: 0, message: null };
    function init() { uniqueState.currentFrame = 0; uniqueState.message = getRandomMessage(); }
    
    function animate() {
        const t = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedT = easeInOutQuint(t); 
        const { width, height } = canvas;
        const centerX = width / 2;
        const centerY = height / 2;
        const maxDim = Math.max(width, height);
        
        ctx.clearRect(0, 0, width, height);

        // 1. Oude afbeelding (vervaagt met een blur)
        const blur = lerp(0, 20, Math.sin(t * Math.PI));
        ctx.filter = `blur(${blur}px)`;
        ctx.globalAlpha = 1 - easedT;
        ctx.drawImage(currentImage, 0, 0, width, height);
        ctx.filter = 'none';

        // 2. Nieuwe afbeelding
        ctx.globalAlpha = easedT;
        ctx.drawImage(nextImage, 0, 0, width, height);
        
        // 3. De Oxytocine Golf (een zachte, pulserende kleur)
        ctx.save();
        const waveRadius = maxDim * easedT * 1.5; 
        const waveAlpha = Math.sin(t * Math.PI); 

        const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, waveRadius);
        gradient.addColorStop(0, `rgba(255, 192, 203, ${waveAlpha * 0.8})`); // Roze (Liefde/Oxytocine)
        gradient.addColorStop(0.5, `rgba(255, 192, 203, ${waveAlpha * 0.3})`);
        gradient.addColorStop(1, `rgba(255, 192, 203, 0)`);
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, width, height);
        ctx.restore();
        
        drawHealingText(t, uniqueState.message);

        if (uniqueState.currentFrame < uniqueState.totalFrames) {
            uniqueState.currentFrame++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, width, height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();


// ====================================================================
// 168. Endorphin Cascade (Endogene Farmacologie)
// Effect: Heldere, kleine energiepartikels exploderen vanuit het centrum
// ====================================================================
ANIMATION_LOGIC[75] = (function() {
    const uniqueState = { totalFrames: 80, currentFrame: 0, message: null, particles: [] };
    
    function init() { 
        uniqueState.currentFrame = 0; 
        uniqueState.message = getRandomMessage(); 
        uniqueState.particles = [];
        const { width, height } = canvas;
        const centerX = width / 2;
        const centerY = height / 2;
        
        for(let i = 0; i < 50; i++) {
            uniqueState.particles.push({
                x: centerX,
                y: centerY,
                angle: Math.random() * Math.PI * 2,
                speed: Math.random() * 5 + 2,
                color: `hsl(${Math.random() * 60 + 30}, 100%, 70%)` // Goud/Oranje tinten
            });
        }
    }
    
    function animate() {
        const t = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedT = easeInOutQuint(t); 
        const { width, height } = canvas;
        
        ctx.clearRect(0, 0, width, height);

        // Oude afbeelding vervaagt
        ctx.globalAlpha = 1 - easedT;
        ctx.drawImage(currentImage, 0, 0, width, height);
        
        // Nieuwe afbeelding verschijnt
        ctx.globalAlpha = easedT;
        ctx.drawImage(nextImage, 0, 0, width, height);
        
        // De Endorfine Cascade
        ctx.save();
        uniqueState.particles.forEach(p => {
            // Update positie
            const distance = p.speed * uniqueState.currentFrame * 2;
            p.x = width / 2 + Math.cos(p.angle) * distance;
            p.y = height / 2 + Math.sin(p.angle) * distance;
            
            // Teken de deeltjes (maximaal zichtbaar in het midden)
            ctx.globalAlpha = Math.max(0, 1 - distance / Math.max(width, height) * 0.5);
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 3, 0, 2 * Math.PI);
            ctx.fill();
        });
        ctx.restore();
        
        drawHealingText(t, uniqueState.message);

        if (uniqueState.currentFrame < uniqueState.totalFrames) {
            uniqueState.currentFrame++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, width, height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();


// ====================================================================
// 169. Mitochondrial Power-Up (Energiebehoud)
// Effect: Pulserende gloed die energieoverdracht versnelt
// ====================================================================
ANIMATION_LOGIC[73] = (function() {
    const uniqueState = { totalFrames: 100, currentFrame: 0, message: null };
    function init() { uniqueState.currentFrame = 0; uniqueState.message = getRandomMessage(); }
    
    function animate() {
        const t = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedT = easeInOutQuint(t); 
        const { width, height } = canvas;
        const centerX = width / 2;
        const centerY = height / 2;
        const maxDim = Math.max(width, height);
        
        ctx.clearRect(0, 0, width, height);
        
        // De pulserende factor (snel knipperend, max amplitude op t=0.5)
        const pulse = 0.5 + 0.5 * Math.sin(t * Math.PI * 15); 
        const blurAmount = 10 * pulse * Math.sin(t * Math.PI); // Blur is maximaal in het midden

        // 1. Oude afbeelding (vervaagt met pulserende blur)
        ctx.filter = `blur(${blurAmount}px)`;
        ctx.globalAlpha = 1 - easedT;
        ctx.drawImage(currentImage, 0, 0, width, height);
        ctx.filter = 'none';

        // 2. Nieuwe afbeelding (verschijnt met pulserende helderheid)
        ctx.save();
        // Super-saturatie effect in het midden
        ctx.filter = `saturate(${1 + 2 * pulse * Math.sin(t * Math.PI)})`;
        ctx.globalAlpha = easedT;
        ctx.drawImage(nextImage, 0, 0, width, height);
        ctx.restore();
        
        // 3. De ATP-Gloed (Radiale groene gloed)
        ctx.save();
        const glowRadius = maxDim * easedT; 
        const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, glowRadius);
        gradient.addColorStop(0, `rgba(150, 255, 150, ${easedT * 0.5 * pulse})`);
        gradient.addColorStop(0.5, `rgba(150, 255, 150, ${easedT * 0.2 * pulse})`);
        gradient.addColorStop(1, 'rgba(150, 255, 150, 0)');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, width, height);
        ctx.restore();
        
        drawHealingText(t, uniqueState.message);

        if (uniqueState.currentFrame < uniqueState.totalFrames) {
            uniqueState.currentFrame++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, width, height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();


// ====================================================================
// 170. Epigenetic Shift (Adaptieve Response Systeem)
// Effect: Horizontale DNA-achtige strips onthullen de nieuwe afbeelding
// ====================================================================
ANIMATION_LOGIC[74] = (function() {
    const uniqueState = { totalFrames: 130, currentFrame: 0, message: null, numStrips: 30 };
    function init() { uniqueState.currentFrame = 0; uniqueState.message = getRandomMessage(); }
    
    function animate() {
        const t = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedT = easeInOutQuint(t); 
        const { width, height } = canvas;
        const stripH = height / uniqueState.numStrips;
        
        ctx.clearRect(0, 0, width, height);
        
        for (let i = 0; i < uniqueState.numStrips; i++) {
            const y = i * stripH;
            
            // Unieke vertraging per strip voor het 'onwinden' effect
            const delay = i / uniqueState.numStrips;
            const stripT = Math.min(1, Math.max(0, (easedT - delay * 0.2) * 1.5));
            
            // De verschuiving van de oude afbeelding (gaat naar links)
            const oldShiftX = lerp(0, -width, stripT); 
            // De verschuiving van de nieuwe afbeelding (komt van rechts)
            const newShiftX = lerp(width, 0, stripT); 
            
            // Teken de strip voor de Oude Afbeelding
            ctx.save();
            ctx.beginPath();
            ctx.rect(0, y, width, stripH);
            ctx.clip();
            ctx.translate(oldShiftX, 0);
            ctx.drawImage(currentImage, 0, 0, width, height);
            ctx.restore();
            
            // Teken de strip voor de Nieuwe Afbeelding
            ctx.save();
            ctx.beginPath();
            ctx.rect(0, y, width, stripH);
            ctx.clip();
            ctx.translate(newShiftX, 0);
            ctx.drawImage(nextImage, 0, 0, width, height);
            ctx.restore();
        }
        
        drawHealingText(t, uniqueState.message);

        if (uniqueState.currentFrame < uniqueState.totalFrames) {
            uniqueState.currentFrame++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, width, height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();


// ====================================================================
// 171. Frontal Lobe Cohesion (Integriteit van het Zelfsysteem)
// Effect: Geometrische stukken komen samen in een consistente grid
// ====================================================================
ANIMATION_LOGIC[72] = (function() {
    const uniqueState = { totalFrames: 110, currentFrame: 0, message: null, gridSize: 8 };
    function init() { uniqueState.currentFrame = 0; uniqueState.message = getRandomMessage(); }
    
    function animate() {
        const t = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedT = easeInOutQuint(t); 
        const { width, height } = canvas;
        const pieceW = width / uniqueState.gridSize;
        const pieceH = height / uniqueState.gridSize;
        
        ctx.clearRect(0, 0, width, height);
        
        for (let y = 0; y < uniqueState.gridSize; y++) {
            for (let x = 0; x < uniqueState.gridSize; x++) {
                const targetX = x * pieceW;
                const targetY = y * pieceH;
                const centerX = targetX + pieceW / 2;
                const centerY = targetY + pieceH / 2;
                
                // Beginpositie is willekeurig van de rand
                const startX = centerX + (x % 2 === 0 ? -width : width);
                const startY = centerY + (y % 2 === 0 ? -height : height);
                
                // Huidige positie
                const currentX = lerp(startX, centerX, easedT);
                const currentY = lerp(startY, centerY, easedT);

                ctx.save();
                ctx.translate(currentX, currentY);

                // Teken de nieuwe afbeelding (komt samen)
                ctx.globalAlpha = easedT;
                ctx.drawImage(nextImage, targetX, targetY, pieceW, pieceH, -pieceW / 2, -pieceH / 2, pieceW, pieceH);
                
                // Teken de oude afbeelding (gaat uit elkaar)
                ctx.globalAlpha = 1 - easedT;
                ctx.drawImage(currentImage, targetX, targetY, pieceW, pieceH, -pieceW / 2, -pieceH / 2, pieceW, pieceH);

                ctx.restore();
            }
        }
        
        drawHealingText(t, uniqueState.message);

        if (uniqueState.currentFrame < uniqueState.totalFrames) {
            uniqueState.currentFrame++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, width, height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();


// ====================================================================
// 172. Deep Sleep Theta Rhythm (Slaapcyclus Optimalisatie)
// Effect: Langzame, uitgestrekte, donkere golven wissen het beeld
// ====================================================================
ANIMATION_LOGIC[67] = (function() {
    const uniqueState = { totalFrames: 160, currentFrame: 0, message: null };
    function init() { uniqueState.currentFrame = 0; uniqueState.message = getRandomMessage(); }
    
    function animate() {
        const t = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedT = easeInOutQuint(t); 
        const { width, height } = canvas;
        
        ctx.clearRect(0, 0, width, height);

        // De golfbeweging (langzaam en diep)
        const wave = Math.sin(t * Math.PI * 2); // 2 volledige cycli
        const displacement = width * 0.1 * wave * (1 - easedT); // Wordt vlak aan het einde
        
        // 1. Oude afbeelding (vervaagt en wordt donkerder)
        ctx.globalAlpha = 1 - easedT;
        ctx.drawImage(currentImage, 0, 0, width, height);
        
        // 2. Nieuwe afbeelding (komt van donker en wordt helder)
        ctx.globalAlpha = easedT;
        ctx.drawImage(nextImage, 0, 0, width, height);
        
        // 3. De Theta Golf (donkere, vloeiende overlay)
        ctx.save();
        ctx.fillStyle = `rgba(0, 0, 50, ${Math.sin(t * Math.PI) * 0.7})`; // Diepblauwe/paarse kleur
        ctx.fillRect(0, 0, width, height);
        
        // Voeg de golvende verstoring toe
        for (let y = 0; y < height; y += 10) {
            ctx.beginPath();
            const offset = displacement + Math.sin(y * 0.05) * 50 * Math.sin(t * Math.PI);
            ctx.moveTo(0, y);
            ctx.lineTo(width, y + offset);
            ctx.lineTo(width, y + 10 + offset);
            ctx.lineTo(0, y + 10);
            ctx.closePath();
            ctx.fillStyle = `rgba(0, 0, 0, ${Math.sin(t * Math.PI) * 0.2})`;
            ctx.fill();
        }
        ctx.restore();
        
        drawHealingText(t, uniqueState.message);

        if (uniqueState.currentFrame < uniqueState.totalFrames) {
            uniqueState.currentFrame++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, width, height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();


// ====================================================================
// 173. Allostatic Relief Dissolve (Stress-Adaptatie)
// Effect: Ruis-gebaseerde verdwijning waar ruis wordt gereduceerd tot nul
// ====================================================================

// ====================================================================
// 173. The Stress Dissipation Effect (Geraas)
// Geoptimaliseerd: Step size verhoogd van 2 naar 4. Ongebruikte getImageData verwijderd.
// ====================================================================
ANIMATION_LOGIC[63] = (function() {
    const uniqueState = { 
        totalFrames: 100, 
        currentFrame: 0, 
        message: null, 
        noiseData: null,
        gridStep: 4 // VERHOOGD van 2 naar 4 om draw calls te verminderen
    };
    
    // De 'pseudo-ruis' functie is efficint genoeg, maar de frequentie van aanroepen was te hoog.
    function getNoiseValue(x, y, frame) {
        // Pseudo-ruis op basis van cordinaten en frame
        return Math.sin(x * 0.1) * Math.cos(y * 0.1) + Math.sin(frame * 0.05);
    }
    
    // Functie om willekeurig bericht op te halen (aanname dat deze elders is gedefinieerd)
    function getRandomMessage() {
        // Placeholder/Fallback
        return "Stress verdwijnt, Kalmte keert terug.";
    }

    // Functie om de tekst/emoji's te tekenen (aanname dat deze elders is gedefinieerd)
    function drawHealingText(t, message) {
        if (!ctx || !canvas) return;
        
        // Simpele tekstweergave voor de demo
        const alpha = Math.sin(t * Math.PI); 
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.textAlign = 'center';
        ctx.font = `30px 'Inter', sans-serif`;
        ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
        ctx.fillText(message, canvas.width / 2, canvas.height / 2);
        ctx.restore();
    }
    
    function init() { 
        uniqueState.currentFrame = 0; 
        uniqueState.message = getRandomMessage(); 
    }
    
    function animate() {
        const t = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedT = easeInOutQuint(t); 
        const { width, height } = canvas;
        const step = uniqueState.gridStep;
        
        // 1. Teken de nieuwe afbeelding als basis
        ctx.clearRect(0, 0, width, height);
        ctx.drawImage(nextImage, 0, 0, width, height); 
        
        // **OPRUIMING: ctx.getImageData is verwijderd omdat de data niet werd gebruikt.**
        
        // Ruisintensiteit (Stress) daalt van 1 naar 0
        const noiseIntensity = 1 - easedT;
        
        // Teken de Oude Afbeelding met ruis (lagere iteratie = sneller)
        // We gebruiken de stapgrootte (step) om de draw calls te verminderen
        for (let y = 0; y < height; y += step) {
            for (let x = 0; x < width; x += step) {
                
                // Noise threshold (bepaalt of het stukje van de oude afbeelding nog zichtbaar is)
                const noiseVal = getNoiseValue(x, y, uniqueState.currentFrame) * noiseIntensity * 0.5 + 0.5;
                
                if (noiseVal > 0.5 && noiseIntensity > 0) {
                    ctx.save();
                    ctx.globalAlpha = noiseIntensity * 0.8;
                    // Teken een klein stukje van de oude afbeelding (gebruikt de nieuwe stapgrootte)
                    ctx.drawImage(currentImage, x, y, step, step, x, y, step, step);
                    ctx.restore();
                }
            }
        }
        
        drawHealingText(t, uniqueState.message);

        if (uniqueState.currentFrame < uniqueState.totalFrames) {
            uniqueState.currentFrame++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, width, height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();


// ====================================================================
// 174. Proprioception Grid Lock (Posturale Stabilisatie)
// Effect: Een raster van punten snapt in positie
// ====================================================================
ANIMATION_LOGIC[40] = (function() {
    const uniqueState = { totalFrames: 80, currentFrame: 0, message: null, gridSize: 15 };
    function init() { uniqueState.currentFrame = 0; uniqueState.message = getRandomMessage(); }
    
    function animate() {
        const t = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedT = easeInOutQuint(t); 
        const { width, height } = canvas;
        const pieceW = width / uniqueState.gridSize;
        const pieceH = height / uniqueState.gridSize;
        
        ctx.clearRect(0, 0, width, height);
        
        for (let y = 0; y < uniqueState.gridSize; y++) {
            for (let x = 0; x < uniqueState.gridSize; x++) {
                const targetX = x * pieceW;
                const targetY = y * pieceH;

                // De Oude afbeelding is zichtbaar als de transitie niet 'vastklikt'
                const oldAlpha = 1 - easedT;
                ctx.globalAlpha = oldAlpha;
                ctx.drawImage(currentImage, targetX, targetY, pieceW, pieceH, targetX, targetY, pieceW, pieceH);

                // De Nieuwe afbeelding verschijnt in het midden van het 'klikken'
                const newAlpha = easedT;
                ctx.globalAlpha = newAlpha;
                
                // Snapping effect: schaal zakt snel naar 0 en komt terug (als een veer)
                const snapProgress = 1 - Math.abs(1 - 2 * t);
                const scale = 1 - snapProgress * 0.2 * (1 - easedT); // Lichte veer aan het begin
                
                ctx.save();
                ctx.translate(targetX + pieceW / 2, targetY + pieceH / 2);
                ctx.scale(scale, scale);
                ctx.drawImage(nextImage, targetX, targetY, pieceW, pieceH, -pieceW / 2, -pieceH / 2, pieceW, pieceH);
                
                // Teken het "ankerpunt" (proprioceptie punt)
                ctx.fillStyle = `rgba(100, 150, 255, ${snapProgress * 0.8})`;
                ctx.beginPath();
                ctx.arc(0, 0, 3, 0, 2 * Math.PI);
                ctx.fill();

                ctx.restore();
            }
        }
        
        drawHealingText(t, uniqueState.message);

        if (uniqueState.currentFrame < uniqueState.totalFrames) {
            uniqueState.currentFrame++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, width, height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();


// ====================================================================
// 175. Metacognitive Focus Aperture (Feedback Loops)
// Effect: Een scherp, instelbaar diafragma onthult de heldere nieuwe afbeelding
// ====================================================================
ANIMATION_LOGIC[34] = (function() {
    const uniqueState = { totalFrames: 120, currentFrame: 0, message: null, numBlades: 6 };
    function init() { uniqueState.currentFrame = 0; uniqueState.message = getRandomMessage(); }
    
    function animate() {
        const t = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedT = easeInOutQuint(t); 
        const { width, height } = canvas;
        const centerX = width / 2;
        const centerY = height / 2;
        const maxDim = Math.max(width, height);

        // 1. Oude afbeelding (blur en desaturatie als 'ruis')
        const blur = lerp(20, 0, easedT);
        const sat = lerp(0.5, 1.0, easedT);
        ctx.filter = `blur(${blur}px) saturate(${sat})`;
        ctx.drawImage(currentImage, 0, 0, width, height);
        ctx.filter = 'none';
        
        // 2. Nieuwe afbeelding (geclipt door het diafragma)
        ctx.save();
        ctx.beginPath();
        
        const radius = maxDim * (1 - easedT); // Het diafragma sluit
        
        // Creer het diafragma (een veelhoek die sluit)
        for (let i = 0; i < uniqueState.numBlades; i++) {
            const angle = i * 2 * Math.PI / uniqueState.numBlades;
            const x = centerX + Math.cos(angle) * radius;
            const y = centerY + Math.sin(angle) * radius;
            if (i === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        }
        ctx.closePath();
        ctx.clip();
        
        ctx.drawImage(nextImage, 0, 0, width, height);
        ctx.restore();
        
        drawHealingText(t, uniqueState.message);

        if (uniqueState.currentFrame < uniqueState.totalFrames) {
            uniqueState.currentFrame++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, width, height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();


// ====================================================================
// 176. Synaptic Pruning Wipe (Neuroplasticiteit)
// Effect: Willekeurige strips worden snel 'weggeveegd'
// ====================================================================
ANIMATION_LOGIC[23] = (function() {
    const uniqueState = { totalFrames: 90, currentFrame: 0, message: null, numWipes: 30 };
    function init() { uniqueState.currentFrame = 0; uniqueState.message = getRandomMessage(); }
    
    function animate() {
        const t = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedT = easeInOutQuint(t); 
        const { width, height } = canvas;
        const wipeW = width / uniqueState.numWipes;
        
        ctx.clearRect(0, 0, width, height);
        
        // Nieuwe afbeelding als basis (de schone lei)
        ctx.drawImage(nextImage, 0, 0, width, height);

        for (let i = 0; i < uniqueState.numWipes; i++) {
            const x = i * wipeW;
            
            // Unieke vertraging per strip
            const delay = (i % 5) / 5;
            const wipeT = Math.min(1, Math.max(0, (easedT - delay * 0.1) * 1.5));
            
            // Verticale verschuiving van de wipe (snelle schone beweging)
            const wipeY = lerp(0, height, wipeT); 
            
            ctx.save();
            ctx.beginPath();
            ctx.rect(x, 0, wipeW, height);
            ctx.clip();
            
            // Teken de Oude Afbeelding (gedeeltelijk bedekt door de wipe)
            ctx.drawImage(currentImage, 0, 0, width, height);
            
            // De wipe (een zwarte rechthoek die van boven naar beneden beweegt)
            ctx.fillStyle = `rgba(0, 0, 0, 1 - wipeT)`; // Vervaagt de wipe zelf op het einde
            ctx.fillRect(x, wipeY, wipeW, height - wipeY);
            
            ctx.restore();
        }
        
        drawHealingText(t, uniqueState.message);

        if (uniqueState.currentFrame < uniqueState.totalFrames) {
            uniqueState.currentFrame++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, width, height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();


// ====================================================================
// 177. Vagal Tone Harmonic (Homeostase/Windstilte)
// Effect: Een zachte, lage-frequentie golf breidt zich uit
// ====================================================================
ANIMATION_LOGIC[104] = (function() {
    const uniqueState = { totalFrames: 140, currentFrame: 0, message: null, maxWarp: 0.05 };
    function init() { uniqueState.currentFrame = 0; uniqueState.message = getRandomMessage(); }
    
    function animate() {
        const t = uniqueState.currentFrame / uniqueState.totalFrames;
        const easedT = easeInOutQuint(t); 
        const { width, height } = canvas;
        const centerX = width / 2;
        const centerY = height / 2;
        
        ctx.clearRect(0, 0, width, height);

        // De harmonische golf (langzaam pulserend)
        const wave = Math.sin(t * Math.PI); // Max amplitude op t=0.5
        const warpAmount = uniqueState.maxWarp * wave; 

        // 1. Oude afbeelding (vervaagt en vervormt zachtjes)
        ctx.save();
        ctx.globalAlpha = 1 - easedT;
        ctx.translate(centerX, centerY);
        ctx.scale(1 + warpAmount, 1 + warpAmount); 
        ctx.drawImage(currentImage, -centerX, -centerY, width, height);
        ctx.restore();

        // 2. Nieuwe afbeelding (verschijnt en wordt gladgestreken)
        ctx.save();
        ctx.globalAlpha = easedT;
        ctx.translate(centerX, centerY);
        ctx.scale(1 - warpAmount, 1 - warpAmount); // Tegenovergestelde golf (harmonie)
        ctx.drawImage(nextImage, -centerX, -centerY, width, height);
        ctx.restore();
        
        // 3. De Vagal Tone Gloed (zeer zachte, kalmerende cyaan gloed)
        ctx.save();
        ctx.globalAlpha = wave * 0.3;
        ctx.fillStyle = 'rgba(150, 200, 255, 0.5)'; // Kalmerend blauw
        ctx.fillRect(0, 0, width, height);
        ctx.restore();
        
        drawHealingText(t, uniqueState.message);

        if (uniqueState.currentFrame < uniqueState.totalFrames) {
            uniqueState.currentFrame++;
            requestAnimationFrame(animate);
        } else {
            ctx.drawImage(nextImage, 0, 0, width, height);
            startNextTransition();
        }
    }
    return { init: init, animate: animate, uniqueState: uniqueState };
})();



console.log(ANIMATION_LOGIC[162]);
    const container = document.getElementById('iframe-container');
    
    // Define the two extreme states for the animation
    const STATE_A = 'scale(1.1) translate(0%, 0%)'; // Zoom 10%, slight pan from top-left
    const STATE_B = 'scale(1.1) translate(-6%, -6%)'; // Zoom 10%, slight pan to bottom-right
    
    let currentState = 'A';

    /**
     * Toggles the transform state of the container.
     */
    function animateZoomAndPan() {
        if (currentState === 'A') {
            // Move to STATE_B
            container.style.transform = STATE_B;
            currentState = 'B';
        } else {
            // Move to STATE_A
            container.style.transform = STATE_A;
            currentState = 'A';
        }
        
        // The movement will automatically happen smoothly over the 20s defined in the CSS transition.
    }

    // Run the animation function once initially
    animateZoomAndPan(); 

  setInterval(animateZoomAndPan, 20000); 
</script>

